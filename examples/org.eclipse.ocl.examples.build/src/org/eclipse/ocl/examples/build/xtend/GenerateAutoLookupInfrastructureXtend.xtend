/*******************************************************************************
 * Copyright (c) 2015 Willink Transformations, University of York and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Adolfo Sanchez-Barbudo Herrera (University of York) - initial API and implementation
 *******************************************************************************/
package org.eclipse.ocl.examples.build.xtend

import java.util.ArrayList
import java.util.List
import org.eclipse.emf.codegen.ecore.genmodel.GenClassifier
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage
import org.eclipse.emf.ecore.EPackage
import org.eclipse.jdt.annotation.NonNull
import org.eclipse.ocl.examples.autogen.lookup.LookupCGUtil
import org.eclipse.ocl.examples.codegen.generator.AbstractGenModelHelper
import org.eclipse.ocl.examples.codegen.generator.GenModelHelper
import org.eclipse.ocl.pivot.Class
import org.eclipse.ocl.pivot.Operation
import org.eclipse.ocl.pivot.Type
import org.eclipse.ocl.pivot.internal.manager.PivotMetamodelManager
import org.eclipse.ocl.pivot.internal.utilities.PivotUtilInternal
import org.eclipse.ocl.pivot.utilities.ClassUtil
import org.eclipse.ocl.pivot.utilities.EnvironmentFactory
import org.eclipse.emf.mwe.core.issues.Issues

public class GenerateAutoLookupInfrastructureXtend extends GenerateAutoLookupVisitors
{
	// The lookupVisitor will be in the normal visitors folder, but all the artifacts generated by this compoenent
	// will be in a different one
	String lookupArtifactsJavaPackage;
	String lookupArtifactsOutputFolder;
	String lookupPackageName
	String superLookupPackageName
	GenModelHelper genModel;
	
	
	override checkConfiguration(Issues issues) {
		super.checkConfiguration(issues);
		if (this.lookupPackageName.length() == 0 ) {
			issues.addError(this, "lookupPackageName must be specified");
		}
	}

	public def setLookupPackageName(String lookupPackageName) {
		this.lookupPackageName = lookupPackageName;
	}
	
	public def setSuperLookupPackageName(String superLookupPackageName) {
		this.superLookupPackageName = superLookupPackageName;
	}
	
	protected def void generateAutoLookupResultItf(@NonNull EPackage ePackage) {
		var boolean isDerived = isDerived();
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + projectPrefix + "LookupResult.java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import java.util.List;
	
	import org.eclipse.jdt.annotation.NonNull;
	import org.eclipse.jdt.annotation.Nullable;
	
	/**
	 * The lookup result returned by the name lookup solver
	 */
	public interface «projectPrefix»LookupResult<NE> {
	
		@Nullable
		NE getSingleResult();
		
		@NonNull
		List<NE> getAllResults();
		
		int size();
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateAutoLookupResultClass(@NonNull EPackage ePackage) {
		var boolean isDerived = isDerived();
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + projectPrefix + "LookupResultImpl.java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	
	import org.eclipse.jdt.annotation.NonNull;
	import org.eclipse.jdt.annotation.Nullable;
	
	public class «projectPrefix»LookupResultImpl<NE> implements «projectPrefix»LookupResult<NE> {
		
		private List<NE> results = new ArrayList<NE>();
		
		public «projectPrefix»LookupResultImpl(List<NE> results){
			this.results.addAll(results);
		}
		
		@SuppressWarnings("null")
		@Override
		@NonNull
		public List<NE> getAllResults() {
			return Collections.unmodifiableList(results);
		}
		
		@Override
		@Nullable
		public NE getSingleResult() {
			return results.size() == 0 ? null : results.get(0);
		}
		
		@Override
		public int size() {
			return results.size();
		}
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateSingleResultLookupEnvironment(@NonNull EPackage ePackage) { 
		
		var boolean isDerived = isDerived();
		var className = projectPrefix + "SingleResultLookupEnvironment";
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className+ ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import org.eclipse.emf.common.util.EList;
	import org.eclipse.emf.ecore.EClass;
	import org.eclipse.jdt.annotation.NonNull;
	import org.eclipse.jdt.annotation.Nullable;
	import org.eclipse.ocl.pivot.evaluation.Executor;
	
	import «lookupPackageName».LookupEnvironment;
	import «lookupPackageName».impl.LookupEnvironmentImpl;
	import «modelPackageName».NamedElement;
	
	public class «className» extends LookupEnvironmentImpl   {
		
		private @NonNull Executor executor;
		private @NonNull String name;
		private @NonNull EClass typeFilter;
		private boolean isLocal;
		
		public «className»(@NonNull Executor executor, @NonNull EClass typeFilter, @NonNull String name, boolean isLocalLookup) {
			this.executor = executor;
			this.name = name;
			this.typeFilter = typeFilter;
			this.isLocal = isLocalLookup;
		}
		
		@Override
		@NonNull
		public Executor getExecutor() {
			return executor;
		}
		
		@Override
		public boolean hasFinalResult() {
			if (isLocal) {
				return true;
			}
			for (NamedElement element : getNamedElements()) {
				if (name.equals(element.getName())) {
					return true;
				}
			}
			return false;
		}
		
		@Override
		@NonNull
		public LookupEnvironment addElement(@Nullable NamedElement namedElement) {
			if (namedElement != null) {
				if (name.equals(namedElement.getName())) {
					if (typeFilter.isInstance(namedElement)) {
						EList<NamedElement> elements = getNamedElements();
						if (!elements.contains(namedElement)) { 	// FIXME use a set ?
							elements.add(namedElement);
						}
					}
				}
			}
			return this;
		}
		
		@Override
		@NonNull
		public <NE extends NamedElement > LookupEnvironment addElements(
				@Nullable EList<NE> namedElements) {
			
			if (namedElements != null) {
				for (NamedElement namedElement : namedElements) {
					addElement(namedElement);
				}	
			}
			return this;
		}
	}
			''');
			writer.close();
		}
	}
	
		protected def void generateDefaultLookupVisitor(@NonNull EPackage ePackage) { 
		
		var boolean isDerived = isDerived();
		var className = projectPrefix + "DefaultLookupVisitor";
		if (!isDerived) {
			var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className+ ".java");
			writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
	
	import org.eclipse.jdt.annotation.NonNull;
	import «lookupPackageName».LookupEnvironment;
	import «visitorPackageName».Abstract«projectPrefix»LookupVisitor;
	
	public class «className» extends Abstract«projectPrefix»LookupVisitor {
	
		public «className»(@NonNull LookupEnvironment context) {
			super(context);
		}
	
	}
			''');
			writer.close();
		}
	}
	
	protected def void generateAutoLookupSolver(@NonNull GenPackage genPackage) {
		var EPackage ePackage = genPackage.getEcorePackage;
		var String fqPackageItf = genModel.getQualifiedPackageInterfaceName(ePackage)
		var List<Operation> lookupOps = genPackage.lookupMethods;
		var boolean isDerived = isDerived();
		var String className = projectPrefix + "LookupSolver";
		var String superClassName = superProjectPrefix + "LookupSolver";
		var MergeWriter writer = new MergeWriter(lookupArtifactsOutputFolder + className + ".java");
		writer.append('''
	«ePackage.generateHeader(lookupArtifactsJavaPackage)»
			
	import java.util.ArrayList;
	import java.util.List;

	import org.eclipse.ocl.pivot.evaluation.Executor;
	import «modelPackageName».*;
	import «lookupPackageName».LookupEnvironment;
	import «lookupPackageName».util.*;
	import «visitablePackageName».«visitableClassName»;	
	«IF isDerived»import «superLookupPackageName».util.«superClassName»;«ENDIF»
	
	public class «className»«IF isDerived» extends «superClassName»«ENDIF» {
		
		private Executor executor;
			
		public «className» (Executor executor) {
			this.executor = executor;
		}
		
		«FOR op : lookupOps»
		«var typeName = op.type.name»
		«var typeFQName = getTypeFQName(op.type)»
		«var typeLiteral = getTypeLiteral(op.type)»
		
		public «projectPrefix»LookupResult<«typeFQName»> lookup«typeName»(«visitableClassName» fromElement«FOR param:op.ownedParameters», «param.type.name» «param.name»«ENDFOR») {
			LookupEnvironment _lookupEnv = new «projectPrefix»SingleResultLookupEnvironment(executor, «fqPackageItf».Literals.«typeLiteral»«FOR param:op.ownedParameters», «param.name»«ENDFOR»);
			«projectPrefix»DefaultLookupVisitor _lookupVisitor = new «projectPrefix»DefaultLookupVisitor(_lookupEnv);
			List<«typeFQName»> nLookupResults = new ArrayList<«typeFQName»>();
			for (NamedElement ne : fromElement.accept(_lookupVisitor).getNamedElements()) {
				nLookupResults.add((«typeFQName»)ne);
			}
			return new «projectPrefix»LookupResultImpl<«typeFQName»>(nLookupResults);
		}
		«ENDFOR»
	}
		''');
		writer.close();
	}
	
	override generateVisitors(GenPackage genPackage) {
		super.generateVisitors(genPackage);
		
		genModel = createGenModelHelper(genPackage);
		lookupArtifactsJavaPackage = lookupPackageName + ".util";
		lookupArtifactsOutputFolder = modelFolder + lookupArtifactsJavaPackage.replace('.', '/') + "/";
		
		var EPackage ePackage = genPackage.getEcorePackage();
		
		ePackage.generateAutoLookupResultClass;
		ePackage.generateAutoLookupResultItf;
		ePackage.generateSingleResultLookupEnvironment;
		ePackage.generateDefaultLookupVisitor;
		genPackage.generateAutoLookupSolver;
	}

	protected def List<Operation> getLookupMethods(GenPackage genPackage) {
		
		var List<Operation> result = new ArrayList<Operation>;
		var EnvironmentFactory envFact = PivotUtilInternal.getEnvironmentFactory(genPackage.getEcorePackage.eResource);		
		for (oclPackage : LookupCGUtil.getTargetPackages(genPackage, envFact, lookupFilePath, projectName, projectPrefix)) {
			for (oclClass : oclPackage.ownedClasses) {
				for (oclOp : oclClass.ownedOperations) {
					if (oclOp.isLookupOperation) {
						result.add(oclOp);
					}
				}
			}
		} 
		return result;
	}
		
	private def boolean isLookupOperation(Operation op){
		// internal lookup ops...
		if (!op.name.startsWith("_lookup")) {
			return false;
		}
		
		// ...which don't have the env parameter
		// FIXME more robust check of the parameter
		for (param : op.ownedParameters) {
			if ("env".equals(param.name)) {
				return false
			}
		}
		
		return true;
	}
	
	private def GenModelHelper createGenModelHelper(GenPackage genPackage) {
		var PivotMetamodelManager mManager = PivotUtilInternal.getEnvironmentFactory(genPackage.getEcorePackage().eResource).metamodelManager;
		return new AbstractGenModelHelper(mManager);
	}
	
	private def String getTypeLiteral(Type type) {
		var GenClassifier genClassifier = genModel.getGenClassifier(type as Class);
		return ClassUtil.nonNullState(genClassifier).classifierID; 
	}
	
	private def String getTypeFQName(Type type) {
		return genModel.getEcoreInterfaceName(type as Class)	
	}
	

}
