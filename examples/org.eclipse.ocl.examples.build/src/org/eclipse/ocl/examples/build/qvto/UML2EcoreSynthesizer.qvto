
modeltype UML2Ecore uses 'http://www.eclipse.org/ocl/2012/UML2EcoreMapping';
modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';

transformation PruneUML(in analysis : UML2Ecore, out Ecore);

property mappings : Set(UML2Ecore::Mapping) = analysis.objectsOfType(UML2Ecore::Mappings).mappings->asSet();
property createPackages : Set(UML2Ecore::CreatePackage) = mappings->selectByKind(UML2Ecore::CreatePackage)->asSet();
--property createTypes : Set(UML2Ecore::CreateType) = analysis.objectsOfType(UML2Ecore::CreateType)->asSet();

property packageMappings : Set(UML2Ecore::PackageMapping) = analysis.objectsOfType(UML2Ecore::PackageMapping);
property deletePackageMappings : Set(UML2Ecore::DeletePackage) = analysis.objectsOfType(UML2Ecore::DeletePackage);
property renamePackageMappings : Set(UML2Ecore::CreatePackage) = analysis.objectsOfType(UML2Ecore::CreatePackage);
property deleteTypeMappings : Set(UML2Ecore::DeleteType) = analysis.objectsOfType(UML2Ecore::DeleteType);
property createTypeMappings : Set(UML2Ecore::CreateType) = analysis.objectsOfType(UML2Ecore::CreateType);

property oldPackages : Set(UML::Package) = packageMappings.oldPackages->asSet();
property nestingPackages : Set(UML::Package) = oldPackages->closure(nestingPackage);
property allPackages : Set(UML::Package) = nestingPackages->closure(nestedPackage)->union(nestingPackages);
property deletePackages : Set(UML::Package) = deletePackageMappings.oldPackages->asSet();
property renamePackages : Set(UML::Package) = renamePackageMappings.oldPackages->asSet();
property copyPackages : Set(UML::Package) = allPackages - deletePackages - renamePackages;

property allTypes : Set(UML::Type) = allPackages.ownedType->asSet();
property allClasses : Set(UML::Class) = allPackages.ownedType->selectByKind(UML::Class)->asSet();

property deletePackageTypes : Set(UML::Type) = deletePackages.ownedType->asSet();
property deleteTypes : Set(UML::Type) = deleteTypeMappings.oldTypes->union(deleteTypeMappings.oldTypes)->asSet();
property deleteTypeNames : Set(String) = deleteTypes.name->asSet();
property deleteClasses : Set(UML::Class) = deleteTypeMappings.oldTypes->selectByKind(UML::Class)->asSet();

property umlType2createType : Dict(UML::Type, UML2Ecore::CreateType) = Dict{};
property umlType2deleteType : Dict(UML::Type, UML2Ecore::DeleteType) = Dict{};

property umlType2depth : Dict(UML::Type, Integer) = Dict{};

helper Set(UML::NamedElement)::display() : String {
	return self->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name);
}

helper Set(UML::Type)::display() : String {
	return self->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.getTypeName());
}

helper Set(UML::Property)::display() : String {
	return self->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.getPropertyName());
}

helper Set(UML2EcoreMapping::CreateProperty)::display() : String {
	return self->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName);
}

helper Set(UML2EcoreMapping::CreateType)::display() : String {
	return self->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName);
}

helper Set(UML2EcoreMapping::DeleteProperty)::display() : String {
	return self->sortedBy(oldName)->iterate(c; acc : String = '' | acc + ' ' + c.oldName);
}

helper Set(UML2EcoreMapping::DeleteType)::display() : String {
	return self->sortedBy(oldName)->iterate(c; acc : String = '' | acc + ' ' + c.oldName);
}

helper Set(String)::display() : String {
	return self->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c);
}

helper UML::NamedElement::getName() : String {
	return if self.name <> null then self.name else 'null' endif;
}

helper UML::Property::getOwningType() : Type {
	return if self._'class' <> null then self._'class' else self.getOtherEnd().type endif;
}

helper UML::Type::getTypeName() : String {
	return self.package.getName() + '::' + self.getName();
}

helper UML::Property::getPropertyName() : String {
	var type : Type := self.getOwningType();
	return type.getTypeName() + '::' + self.getName();
}

main() {
	--
	-- Pass 0: Analyze the input model and select the required elements
	--
--	log('packageMappings', packageMappings);
--	log('deletePackages', deletePackages.name->asSet()->sortedBy(n | n));
--	log('renamePackages', renamePackages.name->asSet()->sortedBy(n | n));
--	log('copyPackages', copyPackages.name->asSet()->sortedBy(n | n));
--	log('nestingPackages', nestingPackages.name->asSet()->sortedBy(n | n));
--	log('allPackages', allPackages.name->asSet()->sortedBy(n | n));
--	log('deleteTypes', deleteTypes.name->asSet());
--	log('createPackages', createPackages.newName->asSet());
--	log('createTypeMappings', createTypeMappings.newName->asSet());
	createTypeMappings->forEach(createType) {
		createType.oldTypes->forEach(oldType) {
			umlType2createType->put(oldType, createType);
		};
	};
	deleteTypeMappings->forEach(deleteType) {
		deleteType.oldTypes->forEach(oldType) {
			umlType2deleteType->put(oldType, deleteType);
		};
	};
	--	log('oldType2createType', oldType2createType);
	--
	-- Pass 1: Create the output containment hierarchy
	--
	createPackages->map createPackage();
	--
	-- Pass 2: Resolve references within the output containment hierarchy
	--
	umlType2eClass->values()->sortedBy(name)->map resolveEClass();
	umlProperty2eReference->values()->sortedBy(name)->map resolveEReference();
--	object Comment { body := 'association keys size = ' + out2in->keys()->select(oclIsKindOf(Association))->size().toString(); };
}

/**
 * Pass 1 convert the containment tree.
 */
mapping UML2Ecore::CreatePackage::createPackage() : Ecore::EPackage
{
--	self.oldPackages->forEach(p) { umlPackage2ePackage->put(p, result); };
	var createTypes : Set(UML2Ecore::CreateType) := self.typeMappings->selectByKind(UML2Ecore::CreateType)->asSet();
--	self.convertNamedElement(result);
	result.name := self.newName;
	result.nsURI := self.nsURI;
	result.nsPrefix := self.nsPrefix;
	result.eClassifiers += createTypes->select(let t = oldTypes->any(true) in t.oclIsKindOf(UML::DataType) and not t.oclIsKindOf(UML::Enumeration))->createType(self)->sortedBy(name);
	result.eClassifiers += createTypes->select(oldTypes->any(true).oclIsKindOf(UML::Enumeration))->createType(self)->sortedBy(name);
--	result.eClassifiers += createTypes->select(oldTypes->any(true).oclIsKindOf(UML::Interface))->createType(self)->sortedBy(name);
	result.eClassifiers += createTypes->select(oldTypes->any(true).oclIsKindOf(UML::Class) or oldTypes->any(true).oclIsKindOf(UML::Interface))->createType(self)->sortedBy(name);
--	result.eAnnotations += object Ecore::EAnnotation {
--		source := 'http://www.eclipse.org/ocl/2012/UML2EcoreMapping';
--		_references := self.oldPackages->sortedBy(name).oclAsType(ecore::EObject);
--	};
}

helper UML2Ecore::CreateType::createType(createPackage : UML2Ecore::CreatePackage) : Ecore::EClassifier
{
	return self.oldTypes->at(1).map createType(self);
--	result.eAnnotations += object Ecore::EAnnotation {
--		source := 'http://www.eclipse.org/ocl/2012/UML2EcoreMapping';
--		_references := self.oldTypes->sortedBy(name).oclAsType(ecore::EObject);
--	}
}
mapping UML::Type::createType(createType : UML2Ecore::CreateType) : Ecore::EClassifier
disjuncts UML::Class::createClass, UML::Interface::createInterface, UML::Enumeration::createEnumeration, UML::DataType::createDataType;
abstract mapping UML::Type::createAbstractType(createType : UML2Ecore::CreateType) : Ecore::EClassifier
{
--	log('  createAbstractType', self.name);
	result.name := createType.newName;
	result.map installComments(createType.oldTypes.ownedComment->asSet());
	createType.oldTypes->forEach(t) {
--	    log('  <= ', t.name);
		umlType2eClassifier->put(t, result);
	};
	eClassifier2createType->put(result, createType);
}
mapping UML::Class::createClass(createType : UML2Ecore::CreateType) : Ecore::EClass
inherits UML::Type::createAbstractType
{
--	log('  createClass', self.name);
	createType.oldTypes->forEach(t) { umlType2eClass->put(t, result); };
	var oldClasses : Set(UML::Class) := createType.oldTypes->selectByKind(UML::Class)->asSet();
--	log('    oldClasses', oldClasses->display());
	var oldSameNamedClasses : Set(UML::Class) := oldClasses->select(c | c.name = self.name);
--	log('    oldSameNamedClasses', oldSameNamedClasses->display());
	var oldAbstractClasses : Set(UML::Class) := oldSameNamedClasses->select(isAbstract);
--	log('    oldAbstractClasses', oldAbstractClasses->display());
	result._'abstract' := oldAbstractClasses->notEmpty();
}
mapping UML::Interface::createInterface(createType : UML2Ecore::CreateType) : Ecore::EClass
inherits UML::Type::createAbstractType
{
--	log('  createInterface', self.name);
	createType.oldTypes->forEach(t) { umlType2eClass->put(t, result); };
	result.map installInstanceClassName(createType.oldTypes, 'Ecore::EClass');
	result._'abstract' := true;
	result.interface := true;
}

mapping UML::DataType::createDataType(createType : UML2Ecore::CreateType) : Ecore::EDataType
inherits UML::Type::createAbstractType
{
	result.map installInstanceClassName(createType.oldTypes, 'Ecore::EDataType');
}
mapping UML::Enumeration::createEnumeration(createType : UML2Ecore::CreateType) : Ecore::EEnum
inherits UML::Type::createAbstractType
{
	result.eLiterals := self.ownedLiteral->map createEnumerationLiteral();
}
 
mapping UML::EnumerationLiteral::createEnumerationLiteral() : Ecore::EEnumLiteral
{	
	var idx : Integer := self.enumeration.ownedLiteral->indexOf(self)-1;
--	log('  convertEnumerationLiteral', self.name + self.enumeration.ownedLiteral->iterate(l; acc : String = ':' | acc + ' ' + l.name) + ' / ' + idx.toString());
	umlEnumerationLiteral2eEnumLiteral->put(self, result);
	result.name := self.name;
	result.map installComments(self.ownedComment);
	result.value := self.enumeration.ownedLiteral->indexOf(self)-1;
}

mapping UML2EcoreMapping::CreateOperation::createOperation(type : Ecore::EClassifier, oldOperations : Set(UML::Operation), newType : Ecore::EClassifier) : Ecore::EOperation
{
	oldOperations->forEach(p) { umlOperation2eOperation->put(p, result); };
	eOperation2createOperation->put(result, self);
	var oldOperation : Operation := oldOperations->any(true);
--	log('  createOperation', self.newName);
	result.name := self.newName;
	result.map installComments(oldOperations.ownedComment->asSet());
	result.lowerBound := oldOperation.lower;
	result.upperBound := oldOperation.upper;
	result.unique := oldOperation.isUnique;
	result._'ordered' := if (0 <= oldOperation.upper) and (oldOperation.upper <= 1) then true else oldOperation.isOrdered endif;
--	log('    createOperation', Sequence{oldType, newType});
	result.eType := newType;
--	log('  defaultValues', defaultValues->iterate(l; acc : String = ':' | acc + ' ' + l.toString()));
}

mapping UML2EcoreMapping::CreateProperty::createProperty(type : Ecore::EClassifier, oldProperties : Set(UML::Property), newType : Ecore::EClassifier) : Ecore::EStructuralFeature
disjuncts UML2EcoreMapping::CreateProperty::createAttribute, UML2EcoreMapping::CreateProperty::createReference;
mapping UML2EcoreMapping::CreateProperty::createAttribute(type : Ecore::EClassifier, oldProperties : Set(UML::Property), newType : Ecore::EClassifier) : Ecore::EAttribute
when { newType.oclIsKindOf(Ecore::EDataType) }
{
--	log('  createAttribute', self.newName);
	self.createStructuralFeature(result, oldProperties, newType);
	result.map installUnsettable(oldProperties, 'Ecore::EAttribute');
	var isDerived : Boolean := oldProperties->forAll(isDerived);
	result._'derived' := isDerived;
//	result.transient := isDerived;
	result.map installTransient(oldProperties, 'Ecore::EAttribute', isDerived);
	result.volatile := isDerived;
}
mapping UML2EcoreMapping::CreateProperty::createReference(type : Ecore::EClassifier, oldProperties : Set(UML::Property), newType : Ecore::EClassifier) : Ecore::EReference
when { not newType.oclIsKindOf(Ecore::EDataType) }
{
	oldProperties->forEach(p) { umlProperty2eReference->put(p, result); };
	eReference2createProperty->put(result, self);
	var oldProperty : Property := oldProperties->any(true);
--	log('  createReference', self.newName);
	self.createStructuralFeature(result, oldProperties, newType);
	result.map installUnsettable(oldProperties, 'Ecore::EReference');
	result.containment := oldProperty.aggregation = UML::AggregationKind::composite;
}

helper UML2EcoreMapping::CreateProperty::createStructuralFeature(inout output : Ecore::EStructuralFeature, oldProperties : Set(UML::Property), newType : Ecore::EClassifier)
{
	var oldProperty : Property := oldProperties->any(true);
	var defaultValues : Set(UML::ValueSpecification) := oldProperties.defaultValue->excluding(null)->asSet();
	output.name := self.newName;
	output.map installComments(oldProperties.ownedComment->asSet());
	output.lowerBound := oldProperties.lower->max();
	output.upperBound := oldProperty->upper->min();
	output.unique := oldProperty->exists(isUnique);
	output._'ordered' := if (0 <= output.upperBound) and (output.upperBound <= 1) then true else oldProperty->exists(isOrdered) endif;
	output.changeable := oldProperties->forAll(not isReadOnly);
	output._derived := oldProperties->forAll(isDerived);
--	output.unsettable := false; --oldProperty.lower < 1;
--	output.unsettable := false; --(oldProperty.lower = 1) and (oldProperty.upper = 1) and defaultValues->isEmpty() and output.oclIsKindOf(EAttribute); -- BooleanLiteralExp.booleanSymbol
--	log('    createStructuralFeature', Sequence{oldType, newType});
	output.eType := newType;
--	log('  defaultValues', defaultValues->iterate(l; acc : String = ':' | acc + ' ' + l.toString()));
	var oldDefaultValue : String := if defaultValues->notEmpty() then defaultValues->any(true).getDefaultValue() else null endif;
--	var newDefaultValue : OclAny := if oldDefaultValue.oclIsKindOf(UML::EnumerationLiteral) and (umlEnumerationLiteral2eEnumLiteral->get(oldDefaultValue.oclAsType(UML::EnumerationLiteral)) <> null) then umlEnumerationLiteral2eEnumLiteral->get(oldDefaultValue.oclAsType(UML::EnumerationLiteral)) else oldDefaultValue endif;
	output.defaultValueLiteral := oldDefaultValue;
	return;
}

helper UML::ValueSpecification::getDefaultValue() : String
{
	return self.toString();
}
helper UML::InstanceValue::getDefaultValue() : String
{
	return self.instance.name;
}
helper UML::LiteralBoolean::getDefaultValue() : String
{
	return self.value.toString();
}
helper UML::LiteralString::getDefaultValue() : String
{
	return self.value;
}

mapping inout Ecore::ENamedElement::installComments(in comments : Set(UML::Comment))
{
	var eComment : Ecore::EAnnotation := if comments->notEmpty() then object Ecore::EAnnotation {
		source := 'http://www.eclipse.org/emf/2002/GenModel';
		details += object Ecore::EStringToStringMapEntry {
			key := 'documentation';
			value := comments->iterate(c; acc : String = '' | acc + c.body)
		};
	} else null endif;
	self.eAnnotations += if eComment <> null then Set{eComment} else Set{} endif;
}

mapping inout Ecore::EClassifier::installInstanceClassName(in types : Set(UML::Type), stereotypeName : String)
{
	var stereotypedTypes : Set(UML::Type) := types->select(getAppliedStereotype(stereotypeName) <> null)->asSet();
	var stereotypedType : UML::Type := stereotypedTypes->any(true);
--	var stereotypes : Set(UML::Stereotype) := createType.oldTypes.oclAsType(UML::DataType).getAppliedStereotype('Ecore::EDataType')->asSet();
--	log('stereotypedType', stereotypedType);
	var instanceClassName : String := stereotypedType.getValue(stereotypedType.getAppliedStereotype(stereotypeName), 'instanceClassName').oclAsType(String);
--	log('instanceClassName', instanceClassName);
	self.instanceClassName := instanceClassName;
--	result.defaultValue := instanceClassName;
}

mapping inout Ecore::EStructuralFeature::installTransient(in properties : Set(UML::Property), stereotypeName : String, defaultValue : Boolean)
{
	var stereotypedProperties : Set(UML::Property) := properties->select(getAppliedStereotype(stereotypeName) <> null)->asSet();
	var stereotypedProperty : UML::Property := if stereotypedProperties->notEmpty() then stereotypedProperties->any(true) else null endif;
--	var stereotypes : Set(UML::Stereotype) := createType.oldTypes.oclAsType(UML::DataType).getAppliedStereotype('Ecore::EDataType')->asSet();
--	log('stereotypedType', stereotypedType);
	var transient : Boolean := if stereotypedProperty <> null then stereotypedProperty.getValue(stereotypedProperty.getAppliedStereotype(stereotypeName), 'isTransient').oclAsType(Boolean) else defaultValue endif;
--	log('instanceClassName', instanceClassName);
	self.transient := transient ;
--	result.defaultValue := instanceClassName;
}

mapping inout Ecore::EStructuralFeature::installUnsettable(in properties : Set(UML::Property), stereotypeName : String)
{
	var stereotypedProperties : Set(UML::Property) := properties->select(getAppliedStereotype(stereotypeName) <> null)->asSet();
	var stereotypedProperty : UML::Property := if stereotypedProperties->notEmpty() then stereotypedProperties->any(true) else null endif;
--	var stereotypes : Set(UML::Stereotype) := createType.oldTypes.oclAsType(UML::DataType).getAppliedStereotype('Ecore::EDataType')->asSet();
--	log('stereotypedType', stereotypedType);
	var unsettable : Boolean := stereotypedProperty <> null and stereotypedProperty.getValue(stereotypedProperty.getAppliedStereotype(stereotypeName), 'isUnsettable').oclAsType(Boolean);
--	log('instanceClassName', instanceClassName);
	self.unsettable := unsettable ;
--	result.defaultValue := instanceClassName;
}

/**
 *	Pass 1 results for use in pass 2.
 */
property umlType2eClassifier : Dict(UML::Type, Ecore::EClassifier) = Dict{};
property umlType2eClass : Dict(UML::Type, Ecore::EClass) = Dict{};
property umlEnumerationLiteral2eEnumLiteral : Dict(UML::EnumerationLiteral, Ecore::EEnumLiteral) = Dict{};
--property umlPackage2ePackage : Dict(UML::Package, Ecore::EPackage) = Dict{};
property umlOperation2eOperation : Dict(UML::Operation, Ecore::EOperation) = Dict{};
property umlProperty2eReference : Dict(UML::Property, Ecore::EReference) = Dict{};

property eClassifier2createType : Dict(Ecore::EClassifier, UML2Ecore::CreateType) = Dict{};
--property ePackage2createPackage : Dict(Ecore::EPackage, UML2Ecore::CreatePackage) = Dict{};
property eOperation2createOperation : Dict(Ecore::EOperation, UML2Ecore::CreateOperation) = Dict{};
property eReference2createProperty : Dict(Ecore::EReference, UML2Ecore::CreateProperty) = Dict{};

/**
 * Pass 2 install all references.
 */
mapping inout Ecore::EClass::resolveEClass()
{
	log('resolveEClass', self.name);
	var createType : UML2Ecore::CreateType := eClassifier2createType->get(self);
	var allOldTypes : Set(UML::Type) := getAllTypes(createType.oldTypes);
	log('  allOldTypes', allOldTypes->display());
	var oldProperSuperClassClosure : Set(UML::Type) :=
		getProperSuperTypes(allOldTypes);
	log('  oldProperSuperClassClosure', oldProperSuperClassClosure->display());
	var newSuperClassClosure : Set(UML::Type) :=
		oldProperSuperClassClosure->reject(deleteTypeNames->includes(name))-createType.oldTypes;
	var newProperSuperClassClosure : Set(UML::Type) :=
		getAllTypes(newSuperClassClosure);
	log('  newProperSuperClassClosure', newProperSuperClassClosure->display());
	var newSuperSuperClassClosure2 : Set(UML::Type) :=
		getProperSuperTypes(newProperSuperClassClosure);
	log('  newSuperSuperClassClosure', newSuperSuperClassClosure2->display());
	var requiredSuperClasses : Set(UML::Type) :=
		newProperSuperClassClosure - newSuperSuperClassClosure2;
	log('  requiredSuperClasses', requiredSuperClasses->display());
	self.eSuperTypes := requiredSuperClasses->collect(sc | umlType2eClass->get(sc))->asSet()->sortedBy(sc | if sc.oclIsKindOf(UML::Class) then sc.name else '_'+sc.name endif);
	var oldInheritedClasses : Set(UML::Type) := createType.oldTypes->union(oldProperSuperClassClosure);
	log('  oldInheritedClasses', oldInheritedClasses->display());
	var newInheritedClasses : Set(UML::Type) := requiredSuperClasses->union(getProperSuperTypes(requiredSuperClasses));
	log('  newInheritedClasses', newInheritedClasses->display());
	var localClasses : Set(UML::Type) := oldInheritedClasses - newInheritedClasses;
	log('  localClasses', localClasses->display());
	var localCreateTypes : Set(UML2EcoreMapping::CreateType) :=
		localClasses->collect(t | umlType2createType->get(t))->excluding(null)->asSet();
	log('  localCreateTypes', localCreateTypes.oldTypes->asSet()->display());
	var localDeleteTypes : Set(UML2EcoreMapping::DeleteType) :=
		localClasses->collect(t | umlType2deleteType->get(t))->excluding(null)->asSet();
	log('  localDeleteTypes', localDeleteTypes.oldTypes->asSet()->display());
	var inheritedCreateTypes : Set(UML2EcoreMapping::CreateType) :=
		newProperSuperClassClosure->collect(t | umlType2createType->get(t))->excluding(null)->asSet();
	log('  inheritedCreateTypes', inheritedCreateTypes.oldTypes->asSet()->display());
	var inheritedDeleteTypes : Set(UML2EcoreMapping::DeleteType) :=
		oldProperSuperClassClosure->collect(t | umlType2deleteType->get(t))->excluding(null)->asSet() - localDeleteTypes;
	log('  inheritedDeleteTypes', inheritedDeleteTypes.oldTypes->asSet()->display());

	var propertyCreates  : Set(UML2EcoreMapping::CreateProperty) :=
		localCreateTypes.propertyMappings->selectByKind(UML2EcoreMapping::CreateProperty)->asSet();
	log('  propertyCreates', propertyCreates.oldProperties->asSet()->display());
	var inheritedPropertyCreates1  : Set(UML2EcoreMapping::CreateProperty) :=
		inheritedCreateTypes.propertyMappings->selectByKind(UML2EcoreMapping::CreateProperty)->asSet();
	var inheritedPropertyCreates2  : Set(UML2EcoreMapping::CreateProperty) :=
		inheritedDeleteTypes.propertyMappings->selectByKind(UML2EcoreMapping::CreateProperty)->asSet();
	var inheritedPropertyCreates  : Set(UML2EcoreMapping::CreateProperty) :=
		inheritedPropertyCreates1->union(inheritedPropertyCreates2);
	log('  inheritedPropertyCreates', inheritedPropertyCreates.oldProperties->asSet()->display());
	var inheritedPropertyMerges  : Set(UML2EcoreMapping::CreateProperty) :=
		localDeleteTypes.propertyMappings->selectByKind(UML2EcoreMapping::CreateProperty)->asSet();
	log('  inheritedPropertyMerges', inheritedPropertyMerges.oldProperties->asSet()->display());
	var inheritedPropertyDeletes  : Set(UML2EcoreMapping::DeleteProperty) :=
		inheritedDeleteTypes.propertyMappings->selectByKind(UML2EcoreMapping::DeleteProperty)->asSet();
	log('  inheritedPropertyDeletes', inheritedPropertyDeletes.oldProperties->asSet()->display());
	var propertyCreateNames  : Set(String) := 
		propertyCreates.newName->asSet();
	log('  propertyCreateNames', propertyCreateNames->display());
	var inheritedPropertyCreateNames  : Set(String) := 
		inheritedPropertyCreates.newName->asSet();
	log('  inheritedPropertyCreateNames', inheritedPropertyCreateNames->display());
	var inheritedPropertyMergeNames  : Set(String) := 
		inheritedPropertyMerges.newName->asSet();
	log('  inheritedPropertyMergeNames', inheritedPropertyMergeNames->display());
	var localPropertyCreateNames  : Set(String) :=
		propertyCreateNames->union(inheritedPropertyMergeNames) - inheritedPropertyCreateNames;
	log('  localPropertyCreateNames', localPropertyCreateNames->display());
	var localPropertyCreates  : Set(UML2EcoreMapping::CreateProperty) := 
		propertyCreates->union(inheritedPropertyMerges)->select(localPropertyCreateNames->includes(newName));
	log('  localPropertyCreates', localPropertyCreates->display());
	localPropertyCreateNames->sortedBy(n | n)->forEach(createName) {
		var thePropertyCreates  : Set(UML2EcoreMapping::CreateProperty) := localPropertyCreates->select(newName = createName);
		log('  thePropertyCreates', thePropertyCreates.oldProperties->asSet()->display());
		var pc  : UML2EcoreMapping::CreateProperty := thePropertyCreates->any(true);
		var oldProperty : Property := pc.oldProperties->any(true);
		var oldType : UML::Type := selectType(pc.oldProperties.type->asSet());
		var newType : Ecore::EClassifier := umlType2eClassifier->get(oldType);
		if (newType <> null) then {
			self.eStructuralFeatures += pc.map createProperty(self, pc.oldProperties, newType);
		} else {
        	log('    obsolete referenced type', self.name + "::" + oldProperty.name + " : " + oldType.name);
		} endif;
	};
	
	
	var operationCreates  : Set(UML2EcoreMapping::CreateOperation) := localCreateTypes.operationMappings->selectByKind(UML2EcoreMapping::CreateOperation)->asSet();
--	log('  operationCreates', operationCreates->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	var inheritedOperationCreates  : Set(UML2EcoreMapping::CreateOperation) := inheritedCreateTypes.operationMappings->selectByKind(UML2EcoreMapping::CreateOperation)->asSet();
--	log('  inheritedOperationCreates', inheritedOperationCreates->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	var operationCreateNames  : Set(String) := operationCreates.newName->asSet();
--	log('  operationCreateNames', operationCreateNames->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c));
	var inheritedOperationCreateNames  : Set(String) := inheritedOperationCreates.newName->asSet();
--	log('  inheritedOperationCreateNames', inheritedOperationCreateNames->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c));
	var localOperationCreateNames  : Set(String) := operationCreateNames - inheritedOperationCreateNames;
--	log('  localOperationCreateNames', localOperationCreateNames->sortedBy(n | n)->iterate(c; acc : String = '' | acc + ' ' + c));
	var localOperationCreates  : Set(UML2EcoreMapping::CreateOperation) := operationCreates->select(localOperationCreateNames->includes(newName));
--	log('  localOperationCreates', localOperationCreates->sortedBy(newName)->iterate(c; acc : String = '' | acc + ' ' + c.newName));
	localOperationCreates->sortedBy(newName)->forEach(pc) {
		var oldOperation : Operation := pc.oldOperations->any(true);
		var oldType : UML::Type := selectType(pc.oldOperations.type->asSet());
		var newType : Ecore::EClassifier := umlType2eClassifier->get(oldType);
		if (newType <> null) then {
			self.eOperations += pc.map createOperation(self, pc.oldOperations, newType);
		} endif;
	};
	
}

mapping inout Ecore::EReference::resolveEReference()
{
--	log('resolveEReference', self.eContainingClass.name + "::" + self.name);
	var createProperty : UML2EcoreMapping::CreateProperty := eReference2createProperty->get(self);
	var oldProperties : Set(UML::Property) := createProperty.oldProperties;
--	log('  oldProperties', oldProperties->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
--	var oppositeProperties : Set(UML::Property) := oldProperties.getOtherEnd()->excluding(null)->asSet();
--	log('  oppositeProperties', oppositeProperties->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
--	var oppositeReferences : Set(Ecore::EReference) := oppositeProperties->collect(c | umlProperty2eReference->get(c))->excluding(null)->asSet();
	var oppositeReference : Ecore::EReference := if createProperty.opposite <> null then umlProperty2eReference->get(createProperty.opposite) else null endif;
--	log('  oppositeReferences', oppositeReferences->sortedBy(name)->iterate(c; acc : String = '' | acc + ' ' + c.name));
--	self.eOpposite := if oppositeReferences->notEmpty() and not self._'derived' and oppositeReferences->forAll(not _'derived') then oppositeReferences->any(true) else null endif;
	self.eOpposite := oppositeReference; --if oppositeReferences->notEmpty() then oppositeReferences->any(true) else null endif;
	var isDerived : Boolean := oldProperties->forAll(isDerived) and (oppositeReference = null);
	self._'derived' := isDerived;
	self.map installTransient(oldProperties, 'Ecore::EReference', isDerived);
	self.volatile := isDerived;
}

helper getAllClasses(classes : Set(UML::Class)) : Set(UML::Class) {
	return getAllTypes(classes)->selectByKind(UML::Class)->asSet();
}
  
helper getAllTypes(types : Set(UML::Type)) : Set(UML::Type) {
	return getAllTypes(types.name->asSet()) - deletePackageTypes;
}
  
helper getAllTypes(names : Set(String)) : Set(UML::Type) {
--	log('  types', types->sortedBy(name)->iterate(t; acc : String = '' | acc + ' ' + t._package.name + '::' + t.name));
	return allTypes->select(names->includes(name));
}

helper getProperSuperTypes(types : Set(UML::Type)) : Set(UML::Type) {
--	log('  types', types->sortedBy(name)->iterate(t; acc : String = '' | acc + ' ' + t._package.name + '::' + t.name));
	var classes : Set(UML::Class) := types->selectByKind(UML::Class)->asSet();
	var selfClasses : Set(UML::Class) := getAllClasses(classes);
	var properSuperClassClosure1 : Set(UML::Class) := getAllClasses(selfClasses->closure(superClass));
	var properSuperClassClosure2 : Set(UML::Class) := getAllClasses(properSuperClassClosure1->closure(superClass))->union(properSuperClassClosure1);
	var properSuperClassClosure : Set(UML::Class) := getAllClasses(properSuperClassClosure2->closure(superClass))->union(properSuperClassClosure2);
	var interfaceRealizations : Set(UML::InterfaceRealization) := properSuperClassClosure->union(selfClasses).interfaceRealization->asSet()->excluding(null);
--	log('  interfaceRealizations', interfaceRealizations);
	var superInterfaces : Set(UML::Interface) := interfaceRealizations.contract->asSet();
--	log('  superInterfaces', superInterfaces.name->asSet()->sortedBy(n | n)->iterate(n; acc : String = '' | acc + ' ' + n));
	var names : Set(String) := properSuperClassClosure.name->union(superInterfaces.name)->asSet();
	return getAllTypes(names);
}

helper selectType(types : Set(UML::Type)) : UML::Type {
	var classes : Set(UML::Class) = types->selectByKind(UML::Class)->asSet();
	if (classes->size() <= 1) return types->any(true);
	var type : UML::Type = classes->sortedBy(t | depth(t))->last();
--	if (types->size() > 1) {
--		log('    ', types->display() + '  => ' + type->display());
--	};
	return type;
}

helper depth(type : UML::Class) : Integer {
    var depth : Integer = umlType2depth->get(type);
    if (depth <> null) return depth;
	var allClasses : Set(UML::Class) = allTypes->select(name = type.name)->selectByKind(UML::Class)->asSet();
	var allSuperClasses : Set(UML::Class) = allClasses.superClass->asSet();
	depth := if allSuperClasses->notEmpty() then allSuperClasses->collect(t | depth(t))->max()+1 else 0 endif;
--	log('    ', type->display() + '  => ' + depth.toString());
	allClasses->forEach(t) { umlType2depth->put(t, depth); };
	return depth;
}