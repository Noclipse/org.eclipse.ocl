[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::tables::model2operations('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/Ecore','http://www.eclipse.org/emf/2002/GenModel')/]

[import org::eclipse::ocl::examples::codegen::common::constantTemplates/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::expressionTemplates/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::importTemplates/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]

[template public generateOperations(genModel : GenModel)]
[comment @main /]
[for (genPackage : GenPackage | genModel.genPackages)]
[let pPackage : Package = genPackage.getPivotPackage()]
[for (pType : Type | pPackage.ownedType->select(ownedRule->notEmpty() or ownedOperation.ownedRule->notEmpty() or ownedAttribute.ownedRule->notEmpty()))]
[generateType(genPackage, pPackage, pType)/]
[/for]
[/let]
[/for]
[/template]

[template public generateType(genPackage : GenPackage, pPackage : Package, pType : Type)]
[let packagePathPrefix : String = if genPackage.basePackage->notEmpty() and genPackage.basePackage.size() > 0 then genPackage.basePackage.replaceAll('\\.', '/') + '/' else '' endif]
[let packagePrefix : String = packagePathPrefix.replaceAll('/', '.')]
[file (packagePathPrefix + pPackage.name + '/operations/' + pType.name + 'Operations.java', false, 'UTF-8')]
/**
 * [genPackage.getCopyright(' * ')/]
 *************************************************************************
 * This code is 100% auto-generated
 * from: [pPackage.name/]
 * using: org.eclipse.ocl.examples.codegen.tables.model2tables.mtl
 *
 * Do not edit it.
 */
package [genPackage.getQualifiedPackageName()/].operations;

[let garbage : String = declareImport(genPackage.getQualifiedPackageName() + '.' + pType.name)][/let]
[genPackage.emitImports(pPackage, pType)/]
/**
 * [pType.name/]Operations provides the Java implementations of OCL-defined [pType.name/] operations and properties.
 */
@SuppressWarnings("nls")
public class [pType.name/]Operations
{
[for (pConstraint : Constraint | pType.ownedRule->sortedBy(name)) before ('\n') separator ('\n')]
	/** 
	 * Implementation of the [pType.name/] '[pConstraint.name/]' invariant.
	 *
	 * [pConstraint.specification.toString()/]
	 */
	[genPackage.generateInvariant('_invariant_' + pConstraint.name, pPackage, pType, pConstraint, pConstraint.specification)/]
[/for]
[if (pType.oclIsKindOf(Class))]
[for (pOperation : Operation | pType.oclAsType(Class).ownedOperation->sortedBy(getMoniker())) before ('\n') separator ('\n')]
[for (pConstraint : Constraint | pOperation.ownedRule) separator ('\n')]
[if (false and pConstraint.stereotype = 'body')]
	public static [pOperation.type.name/] [pOperation.name/]([pType.name/] self[for (parameter : Parameter | pOperation.ownedParameter)], [parameter.type.name/] [parameter.name/][/for]) {
		final ExecutorManager evaluator = EcoreExecutorManager.INSTANCE;
		final ValueFactory valueFactory = evaluator.getValueFactory();
		Library[getArityPlusOneName(pOperation.ownedParameter->size())/]Operation codeGen = [pType.name + '_' + pOperation.name + '_' + pConstraint.stereotype + '_' + pConstraint.name/].INSTANCE;
		try {
			final Value result = codeGen.evaluate(evaluator, null, valueFactory.valueOf(self)[for (parameter : Parameter | pOperation.ownedParameter)], valueFactory.valueOf([parameter.name/])[/for]);
			return ([pOperation.type.name/]) valueFactory.getEcoreValueOf(result);
		} catch (InvalidValueException e) {
			throw new WrappedException(e);
		}
	}

[/if]
[let className : String = '_' + pOperation.name + '_' + pConstraint.stereotype + '_' + pConstraint.name]
	/** 
	 * Implementation of the [pType.name/]::[pOperation.name/] '[pConstraint.name/]' <[pConstraint.stereotype/]>.
	 *
	 * [pConstraint.specification.toString()/]
	 */
	[genPackage.generateOperationConstraint(className, pPackage, pType, pOperation, pConstraint, pConstraint.specification)/]
[/let]
[/for]
[/for]
[for (pProperty : Property | pType.oclAsType(Class).ownedAttribute->sortedBy(name)) before ('\n') separator ('\n')]
[for (pConstraint : Constraint | pProperty.ownedRule) separator ('\n')]
[let className : String = '_' + pProperty.name + '_' + pConstraint.stereotype + '_' + pConstraint.name]
	/** 
	 * Implementation of the [pType.name/]::[pProperty.name/] '[pConstraint.name/]' <[pConstraint.stereotype/]>.
	 *
	 * [pConstraint.specification.toString()/]
	 */
	[genPackage.generatePropertyConstraint(className, pPackage, pType, pProperty, pConstraint, pConstraint.specification)/]
[/let]
[/for]
[/for]
[/if]
}
[/file]
[/let]
[/let]
[/template]

[template public generateInvariant(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pConstraint : Constraint, specification : ValueSpecification)]
public static class [className/] extends LibraryOperation
{
	public Value evaluate(DomainEvaluator domainEvaluator, DomainCallExp callExp, Value sourceValue, Value... argValues) {
		return null;
	}
}[/template]

[template public generateInvariant(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pConstraint : Constraint, specification : OpaqueExpression)]
[let spec : ExpressionInOcl = getExpressionInOcl(pType, specification)]
[genPackage.generateInvariant(className, pPackage, pType, pConstraint, spec)/][/let][/template]

[template public generateInvariant(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pConstraint : Constraint, expressionInOcl : ExpressionInOcl)]
[let className : String = '_invariant_' + pConstraint.name]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
public static class [className/] extends Abstract[getArityPlusOneName(arity)/]Operation
{
	public static [className/] INSTANCE = new [className/]();

	public Value evaluate(DomainEvaluator evaluator, DomainType returnType, Value [defineSymbolName(expressionInOcl.contextVariable, 'self')/][if expressionInOcl.parameterVariable->notEmpty()]
[for (parameter : Variable | expressionInOcl.parameterVariable)]
, Value [defineSymbolName(parameter, parameter.name)/][/for][/if]) throws InvalidValueException {
		[genPackage.emitConstants(pPackage, expressionInOcl, expressionInOcl)/][genPackage.generateExpression(expressionInOcl, expressionInOcl.bodyExpression)/]
		return [expressionInOcl.symbolName(expressionInOcl.bodyExpression)/];
	}
[if (expressionInOcl.messageExpression->notEmpty())]
	public static class Message extends Abstract[getArityPlusOneName(arity)/]Operation
	{
		public static [className/] INSTANCE = new [className/]();
	
		public Value evaluate(DomainEvaluator evaluator, DomainType returnType, Value [defineSymbolName(expressionInOcl.contextVariable, 'self')/][if expressionInOcl.parameterVariable->notEmpty()]
	[for (parameter : Variable | expressionInOcl.parameterVariable)]
	, Value [defineSymbolName(parameter, parameter.name)/][/for][/if]) throws InvalidValueException {
			[genPackage.emitConstants(pPackage, expressionInOcl, expressionInOcl)/][genPackage.generateExpression(expressionInOcl, expressionInOcl.messageExpression)/]
			return [expressionInOcl.symbolName(expressionInOcl.messageExpression)/];
		}
	}
[/if]
}[/let][/let][/template]

[template public generateOperationConstraint(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pOperation : Operation, pConstraint : Constraint, specification : ValueSpecification)]
public static class [className/] extends LibraryOperation
{
	public Value evaluate(DomainEvaluator domainEvaluator, DomainCallExp callExp, Value sourceValue, Value... argValues) {
		return null;
	}
}[/template]

[template public generateOperationConstraint(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pOperation : Operation, pConstraint : Constraint, specification : OpaqueExpression)]
[let spec : ExpressionInOcl = getExpressionInOcl(pOperation, specification)]
[genPackage.generateOperationConstraint(className, pPackage, pType, pOperation, pConstraint, spec)/][/let][/template]

[template public generateOperationConstraint(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pOperation : Operation, pConstraint : Constraint, expressionInOcl : ExpressionInOcl)]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
public static class [className/] extends Abstract[getArityPlusOneName(arity)/]Operation
{
	public static [className/] INSTANCE = new [className/]();

	public Value evaluate(DomainEvaluator evaluator, DomainType returnType, Value [defineSymbolName(expressionInOcl.contextVariable, 'self')/][if expressionInOcl.parameterVariable->notEmpty()]
[for (parameter : Variable | expressionInOcl.parameterVariable)]
, Value [defineSymbolName(parameter, parameter.name)/][/for][/if]) throws InvalidValueException {
		[genPackage.emitConstants(pPackage, expressionInOcl, expressionInOcl)/][genPackage.generateExpression(expressionInOcl, expressionInOcl.bodyExpression)/]
		return [expressionInOcl.symbolName(expressionInOcl.bodyExpression)/];
	}
}[/let][/template]

[template public generatePropertyConstraint(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pProperty : Property, pConstraint : Constraint, specification : ValueSpecification)]
public static class [className/] extends AbstractProperty
{
	public Value evaluate(DomainEvaluator domainEvaluator, DomainType returnType, Value sourceValue, DomainProperty property) {
		return null;
	}
}[/template]

[template public generatePropertyConstraint(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pProperty : Property, pConstraint : Constraint, specification : OpaqueExpression)]
[let spec : ExpressionInOcl = getExpressionInOcl(pType, specification)]
[genPackage.generatePropertyConstraint(className, pPackage, pType, pProperty, pConstraint, spec)/][/let][/template]

[template public generatePropertyConstraint(genPackage : GenPackage, className : String, pPackage : Package, pType : Type, pProperty : Property, pConstraint : Constraint, expressionInOcl : ExpressionInOcl)]
public static class [className/] extends AbstractProperty
{
	public static [className/] INSTANCE = new [className/]();

	public Value evaluate(DomainEvaluator evaluator, DomainType returnType, Value [defineSymbolName(expressionInOcl.contextVariable, 'self')/], DomainProperty property) throws InvalidValueException {
		[genPackage.emitConstants(pPackage, expressionInOcl, expressionInOcl)/][genPackage.generateExpression(expressionInOcl, expressionInOcl.bodyExpression)/]
		return [expressionInOcl.symbolName(expressionInOcl.bodyExpression)/];
	}
}[/template]
