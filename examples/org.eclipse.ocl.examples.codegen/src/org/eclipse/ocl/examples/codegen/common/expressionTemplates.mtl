[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::common::expressionTemplates('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/GenModel','http://www.eclipse.org/ocl/3.1.0/OCL4Acceleo')/]

[import org::eclipse::ocl::examples::codegen::common::constantQueries/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::iteratorTemplates/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::qualifiedLiteralTemplates/]
[import org::eclipse::ocl::examples::codegen::common::stringQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]
[import org::eclipse::ocl::examples::codegen::common::typeIdTemplates/]

[template public emitBox(ast : pivot::OCLExpression, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[let type : Type = ast.type]
[if (type.oclIsKindOf(pivot::Enumeration))]
final <%Value%> [ast.symbolName(expInOcl)/] = createEnumerationLiteralValue(unboxed_[ast.symbolName(expInOcl)/], [type.getEscapedLiteralsName(genPackage)/]);
[elseif (type.oclIsKindOf(OrderedSetType))]
assert unboxed_[ast.symbolName(expInOcl)/] != null;
final @NonNull <%Value%> [ast.symbolName(expInOcl)/] = [if (ast.type.oclAsType(OrderedSetType).elementType.isBoxable())]standardLibrary.createOrderedSetValueOf[else]createOrderedSetValue[/if]([ast.type.typeId(expInOcl)/], unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.oclIsKindOf(SetType))] 
assert unboxed_[ast.symbolName(expInOcl)/] != null;
final @NonNull <%Value%> [ast.symbolName(expInOcl)/] = [if (ast.type.oclAsType(SetType).elementType.isBoxable())]standardLibrary.createSetValueOf[else]createSetValue[/if]([ast.type.typeId(expInOcl)/], unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.oclIsKindOf(SequenceType))]
assert unboxed_[ast.symbolName(expInOcl)/] != null;
final @NonNull <%Value%> [ast.symbolName(expInOcl)/] = [if (ast.type.oclAsType(SequenceType).elementType.isBoxable())]standardLibrary.createSequenceValueOf[else]createSequenceValue[/if]([ast.type.typeId(expInOcl)/], unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.oclIsKindOf(BagType))]
assert unboxed_[ast.symbolName(expInOcl)/] != null;
final @NonNull <%Value%> [ast.symbolName(expInOcl)/] = [if (ast.type.oclAsType(BagType).elementType.isBoxable())]standardLibrary.createBagValueOf[else]createBagValue[/if]([ast.type.typeId(expInOcl)/], unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.oclIsKindOf(LambdaType))]
final <%Value%> [ast.symbolName(expInOcl)/] = valueOf(unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.oclIsKindOf(TupleType))]
final <%Value%> [ast.symbolName(expInOcl)/] = valueOf(unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.oclIsKindOf(PrimitiveType))]
[if (type.name = 'Boolean')]
final Object [ast.symbolName(expInOcl)/] = unboxed_[ast.symbolName(expInOcl)/];
[elseif (type.name = 'UnlimitedNatural')]
final Object [ast.symbolName(expInOcl)/] = integerValueOf((<%java.lang.Number%>)unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.name = 'Integer')]
final Object [ast.symbolName(expInOcl)/] = integerValueOf((<%java.lang.Number%>)unboxed_[ast.symbolName(expInOcl)/]);
[elseif (type.name = 'Real')]
final Object [ast.symbolName(expInOcl)/] = realValueOf((<%java.lang.Number%>)unboxed_[ast.symbolName(expInOcl)/]);
[else]
final Object [ast.symbolName(expInOcl)/] = unboxed_[ast.symbolName(expInOcl)/]; // [type.name/]
[/if]
[elseif ((type.name = 'Type') or (type.name = 'CollectionType'))]
final Object [ast.symbolName(expInOcl)/] = createTypeValue(unboxed_[ast.symbolName(expInOcl)/]);
[else]
final Object [ast.symbolName(expInOcl)/] = valueOf(unboxed_[ast.symbolName(expInOcl)/]); // [type.name/]
[/if][/let][/template]

[template public emitExpression(ast : CollectionItem, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (not ast.item.isConstant())]
[ast.item.emitExpression(importer, genPackage, expInOcl)/][/if]
[/template]

[template public emitExpression(ast : CollectionLiteralExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL) ? (not ast.isConstant())]
[for (part : CollectionLiteralPart | ast.part->reject(isConstantCollectionLiteralPart()))]
[part.emitExpression(importer, genPackage, expInOcl)/]
[/for]
final @NonNull Object [ast.symbolName(expInOcl)/] = standardLibrary.create[ast.kind.toString()/]ValueOf([ast.type.typeId(expInOcl)/][for (part : CollectionLiteralPart | ast.part)], [(if part.oclIsKindOf(CollectionItem) then part.oclAsType(CollectionItem).item.symbolName(expInOcl) else 'createRange((<%IntegerValue%>)'+part.oclAsType(CollectionRange).first.symbolName(expInOcl)+', (<%IntegerValue%>)'+part.oclAsType(CollectionRange).last.symbolName(expInOcl)+')' endif)/][/for]);
[/template]

[template public emitExpression(ast : CollectionRange, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (not ast.first.isConstant())]
[ast.first.emitExpression(importer, genPackage, expInOcl)/]
[/if]
[if (not ast.last.isConstant())]
[ast.last.emitExpression(importer, genPackage, expInOcl)/]
[/if]
[/template]

[template public emitExpression(ast : ConstructorExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
final <%DomainType%> type_[ast.symbolName(expInOcl)/] = [ast.type.typeIdLiteral(genPackage, expInOcl)/];
final <%Object%> [ast.symbolName(expInOcl)/] = type_[ast.symbolName(expInOcl)/].createInstance(standardLibrary[if (ast.value <> null)], "[ast.javaString()/]"[/if]);
[for (part : ConstructorPart | ast.part)]
[part.initExpression.emitExpression(importer, genPackage, expInOcl)/]
[part.referredProperty.symbolName(expInOcl)/].initValue(standardLibrary, [ast.symbolName(expInOcl)/], [part.initExpression.symbolName(expInOcl)/]);
[/for][/template]

[template public emitExpression(ast : Element, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
Object [ast.symbolName(expInOcl)/] = <<[ast.eClass().name/]>>;
[/template]

[template public emitExpression(ast : IfExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (not ast.condition.isConstant())]
	[ast.condition.emitExpression(importer, genPackage, expInOcl)/]
[/if]
[let astName : String = ast.symbolName(expInOcl)]
Object [astName/];
if ([ast.condition.symbolName(expInOcl)/] == <%ValuesUtil%>.TRUE_VALUE) {
[if (not ast.thenExpression.isConstant())]
	[ast.thenExpression.emitExpression(importer, genPackage, expInOcl)/]
[/if]
	[astName/] = [ast.thenExpression.symbolName(expInOcl)/];
}
else if ([ast.condition.symbolName(expInOcl)/] == <%ValuesUtil%>.FALSE_VALUE) {
[if (not ast.elseExpression.isConstant())]
	[ast.elseExpression.emitExpression(importer, genPackage, expInOcl)/]
[/if]
	[astName/] = [ast.elseExpression.symbolName(expInOcl)/];
}
else {
	throw new <%InvalidValueException%>("non-Boolean if condition");
}[/let][/template]

[template public emitExpression(ast : InvalidLiteralExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
final Object [ast.symbolName(expInOcl)/] = throwInvalidValueException();[/template]

[template public emitExpression(ast : IterateExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[let arity : OCLInteger = ast.iterator->size()]
[let leftVarName : String = ast.source.symbolName(expInOcl)]
[let accVarName : String = ast.result.symbolName(expInOcl)]
[let astName : String = ast.symbolName(expInOcl)]
[let operationTypeName : String = 'org.eclipse.ocl.examples.domain.library.AbstractBinaryOperation']
[let iterationTypeName : String = 'org.eclipse.ocl.examples.domain.library.LibraryIteration']
[let managerTypeName : String = 'org.eclipse.ocl.examples.library.executor.' + genPackage.emitManagerArity(arity)]
[ast.source.emitExpression(importer, genPackage, expInOcl)/]
if ([ast.source.symbolName(expInOcl)/] == null) throw new <%InvalidValueException%>("''Collection'' rather than ''OclVoid'' value required");
if ([ast.source.symbolName(expInOcl)/] instanceof <%InvalidValue%>) throw ((<%InvalidValue%>)[ast.source.symbolName(expInOcl)/]).getException();
[ast.result.initExpression.emitExpression(importer, genPackage, expInOcl)/]
[for (i : Variable | ast.iterator)]
//Iterator<Value> [i.symbolName(expInOcl)/]_var = [leftVarName/].toIteratorValue();	// iterator: [i.name/]
[/for]  

/** 
 * Implementation of the iterate body.
 */
final <%[operationTypeName/]%> body_[astName/] = new <%[operationTypeName/]%>()
{
/*
[ast._'body'.prettyPrint().trim()/]
*/
	public @Nullable Object evaluate(@NonNull <%DomainEvaluator%> evaluator, @NonNull <%TypeId%> returnTypeId, @Nullable Object [ast.result.symbolName(expInOcl)/][for (i : Variable | ast.iterator)], @Nullable Object [i.symbolName(expInOcl)/][/for]) throws Exception {
		[ast._'body'.emitExpression(importer, genPackage, expInOcl)/]
		return [ast._'body'.symbolName(expInOcl)/];
	}
};
final <%org.eclipse.ocl.examples.domain.elements.DomainType%> static_[astName/] = evaluator.getStaticTypeOf([ast.source.symbolName(expInOcl)/]);
final <%[iterationTypeName/]%> dynamic_[astName/] = (<%[iterationTypeName/]%>)static_[astName/].lookupImplementation(standardLibrary, [ast.referredIteration.symbolName(expInOcl)/]);
final <%[managerTypeName/]%> manager_[astName/] = new <%[managerTypeName/]%>(evaluator, [ast.result.type.typeId(expInOcl)/], body_[astName/], (<%CollectionValue%>)[leftVarName/], [ast.result.initExpression.symbolName(expInOcl)/]);
final Object [astName/] = dynamic_[astName/].evaluateIteration(manager_[astName/]);[/let][/let][/let][/let][/let][/let][/let][/template]

[template public emitExpression(ast : IteratorExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL) ?(ast.isInlineable())]
[let astName : String = ast.symbolName(expInOcl)]
[ast.source.emitExpression(importer, genPackage, expInOcl)/]
if ([ast.source.symbolName(expInOcl)/] == null) throw new <%InvalidValueException%>("''Collection'' rather than ''OclVoid'' value required");
if ([ast.source.symbolName(expInOcl)/] instanceof <%InvalidValue%>) throw ((<%InvalidValue%>)[ast.source.symbolName(expInOcl)/]).getException();
[ast.emitIterator_createAccumulatorValue(importer, genPackage, expInOcl)/]
final @NonNull <%java.util.Iterator%><?> [astName/]_iteratorVal = ((<%CollectionValue%>)[ast.source.symbolName(expInOcl)/]).iterator();
Object [ast.iterator->at(1).symbolName(expInOcl)/] = null;	// iterator: [ast.iterator->at(1).name/]
Object [astName/];
while (true) {
	if (![astName/]_iteratorVal.hasNext()) {
		[ast.emitIterator_resolveTerminalValue(importer, genPackage, expInOcl)/]
		break;
	}
	/*
		[ast._'body'.emitPrettyPrintHeader()/]
	*/
	[ast.iterator->at(1).symbolName(expInOcl)/] = [astName/]_iteratorVal.next();
	[ast._'body'.emitExpression(importer, genPackage, expInOcl)/]
	Object [astName/]_bodyVal = [ast._'body'.symbolName(expInOcl)/];
	[ast.emitIterator_updateAccumulator(importer, genPackage, expInOcl)/]
}
[/let][/template]

[template public emitExpression(ast : IteratorExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL) ?(not ast.isInlineable())]
[let arity : OCLInteger = ast.iterator->size()]
[let leftVarName : String = ast.source.symbolName(expInOcl)]
[let astName : String = ast.symbolName(expInOcl)]
[let operationTypeName : String = 'org.eclipse.ocl.examples.domain.library.Abstract' + genPackage.emitOperationArity(arity)]
[let iterationTypeName : String = 'org.eclipse.ocl.examples.domain.library.LibraryIteration']
[let managerTypeName : String = 'org.eclipse.ocl.examples.library.executor.' + genPackage.emitManagerArity(arity)]
[ast.source.emitExpression(importer, genPackage, expInOcl)/]
if ([ast.source.symbolName(expInOcl)/] == null) throw new <%InvalidValueException%>("null '[ast.referredIteration.name/]' source");
if ([ast.source.symbolName(expInOcl)/] instanceof <%InvalidValue%>) throw ((<%InvalidValue%>)[ast.source.symbolName(expInOcl)/]).getException();

/** 
 * Implementation of the iterator body.
 */
<%[operationTypeName/]%> body_[astName/] = new <%[operationTypeName/]%>()
{
/*
[ast._'body'.prettyPrint().trim()/]
*/
	@Override
    public @Nullable Object evaluate(@NonNull <%DomainEvaluator%> evaluator, @NonNull <%TypeId%> returnTypeId, @Nullable Object sourceValue[for (i : OCLInteger | Sequence{1..arity})], @Nullable Object iterator[i/][/for]) throws Exception {
[for (i : OCLInteger | Sequence{1..arity})]
		final Object [ast.iterator->at(i).symbolName(expInOcl)/] = iterator[i/];	// iterator: [ast.iterator->at(i).name/]
[/for]  
		[ast._'body'.emitExpression(importer, genPackage, expInOcl)/]
		return [ast._'body'.symbolName(expInOcl)/];
	}
};
<%org.eclipse.ocl.examples.domain.elements.DomainType%> static_[astName/] = evaluator.getStaticTypeOf([ast.source.symbolName(expInOcl)/]);
<%[iterationTypeName/]%> dynamic_[astName/] = (<%[iterationTypeName/]%>)static_[astName/].lookupImplementation(standardLibrary, [ast.referredIteration.symbolName(expInOcl)/]);
Object acc_[astName/] = dynamic_[astName/].createAccumulatorValue(evaluator, [ast.type.typeId(expInOcl)/], [ast._body.type.typeId(expInOcl)/]);
<%[managerTypeName/]%> manager_[astName/] = new <%[managerTypeName/]%>(evaluator, [ast.type.typeId(expInOcl)/], body_[astName/], (<%CollectionValue%>)[ast.source.symbolName(expInOcl)/], acc_[astName/]);
Object [astName/] = dynamic_[astName/].evaluateIteration(manager_[astName/]);[/let][/let][/let][/let][/let][/let][/template]

[template public emitExpression(ast : LetExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (ast.variable.initExpression.isConstant())]
final @NonNull Object [ast.variable.symbolName(expInOcl)/] = [ast.variable.initExpression.symbolName(expInOcl)/];
[else]
Object let_[ast.variable.symbolName(expInOcl)/];
try {
	[ast.variable.initExpression.emitExpression(importer, genPackage, expInOcl)/]
	let_[ast.variable.symbolName(expInOcl)/] = [ast.variable.initExpression.symbolName(expInOcl)/];
}
catch (Exception e) {
	let_[ast.variable.symbolName(expInOcl)/] = new <%InvalidValueImpl%>(e);
}
final Object [ast.variable.symbolName(expInOcl)/] = let_[ast.variable.symbolName(expInOcl)/];
[/if]
[if (not ast._in.isConstant())]
[ast._in.emitExpression(importer, genPackage, expInOcl)/]
[/if]
final Object [ast.symbolName(expInOcl)/] = [ast._in.symbolName(expInOcl)/];[/template]

[template public emitExpression(ast : LiteralExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)][/template]

[template public emitExpression(ast : OperationCallExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL) ? (ast.referredOperation.usesInvalid())]
[let astName : String = ast.symbolName(expInOcl)]
[if (not ast.source.isConstant() and not ast.source.oclIsKindOf(VariableExp))]
Object a[ast.source.symbolName(expInOcl)/];
try {
	[ast.source.emitExpression(importer, genPackage, expInOcl)/]
	a[ast.source.symbolName(expInOcl)/] = [ast.source.symbolName(expInOcl)/];
} [ast.resetFlags()/]catch (Exception e) {
	a[ast.source.symbolName(expInOcl)/] = new <%InvalidValueImpl%>(e);
}
[/if]
[if (ast.argument->notEmpty())]
[let right : OCLExpression = ast.argument->at(1)]
[if (not right.isConstant() and not right.oclIsKindOf(VariableExp ))]
Object a[right.symbolName(expInOcl)/];
try {
	[right.emitExpression(importer, genPackage, expInOcl)/]
	a[right.symbolName(expInOcl)/] = [right.symbolName(expInOcl)/];
} [ast.resetFlags()/]catch (Exception e) {
	a[right.symbolName(expInOcl)/] = new <%InvalidValueImpl%>(e);
}
[/if]
[/let]
[/if]
[ast.generateCall(importer, genPackage, expInOcl, if (not ast.source.isConstant() and not ast.source.oclIsKindOf(VariableExp)) then 'a' else '' endif)/][/let][/template]

[template public emitExpression(ast : OperationCallExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL) ? (not ast.referredOperation.usesInvalid())]
[if (not ast.source.isConstant())]
[ast.source.emitExpression(importer, genPackage, expInOcl)/]
[/if]
[for (argument : OCLExpression | ast.argument->reject(isConstant()))]
[argument.emitExpression(importer, genPackage, expInOcl)/]
[/for]
[ast.generateCall(importer, genPackage, expInOcl, '')/][/template]

[template public generateCall(ast : OperationCallExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL, pfx : String) ?(genPackage.isFinal(ast.referredOperation))]
[let arity : OCLInteger = ast.referredOperation.ownedParameter->size()]
[let astName : String = ast.symbolName(expInOcl)]
[let operationTypeName : String = 'org.eclipse.ocl.examples.domain.library.Library' + genPackage.emitOperationArity(arity)]
[let generatedClassName : String = '_' + ast.referredOperation.name + '_' + 'body' + '_' + '']
[let className : String = if ast.referredOperation.implementationClass <> null then '<%' + ast.referredOperation.implementationClass + '%>.INSTANCE' else genPackage.getImplementationName(ast.referredOperation) endif]
Object [astName/] = [className/].evaluate(evaluator, [ast.type.typeId(expInOcl)/], [pfx/][ast.source.symbolName(expInOcl)/][for (argument : OCLExpression | ast.argument) before (', ') separator (', ')][pfx/][argument.symbolName(expInOcl)/][/for]);[/let][/let][/let][/let][/let][/template]

[template public generateCall(ast : OperationCallExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL, pfx : String) ?(not genPackage.isFinal(ast.referredOperation))]
[let arity : OCLInteger = ast.referredOperation.ownedParameter->size()]
[let astName : String = ast.symbolName(expInOcl)]
[let operationTypeName : String = 'org.eclipse.ocl.examples.domain.library.Library' + genPackage.emitOperationArity(arity)]
// [arity/] [ast.referredOperation/] [ast.referredOperation.implementationClass/]
<%org.eclipse.ocl.examples.domain.elements.DomainType%> static_[astName/] = [genPackage.generateTypeOf(expInOcl, ast.source)/][if arity > 0]
[for (index : OCLInteger | Sequence{1..arity})]
[if ast.referredOperation.ownedParameter->at(index).type.oclIsKindOf(SelfType)]
, [ast.argument->at(index).symbolName(expInOcl)/][/if][/for][/if]);
<%[operationTypeName/]%> dynamic_[astName/] = (<%[operationTypeName/]%>)static_[astName/].lookupImplementation(standardLibrary, [ast.referredOperation.symbolName(expInOcl)/]);
Object [astName/] = dynamic_[astName/].evaluate(evaluator, [ast.type.typeId(expInOcl)/], [pfx/][ast.source.symbolName(expInOcl)/][for (argument : OCLExpression | ast.argument) before (', ') separator (', ')][pfx/][argument.symbolName(expInOcl)/][/for]);[/let][/let][/let][/template]

[template public emitExpression(ast : PropertyCallExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (not ast.source.isConstant())]
[ast.source.emitExpression(importer, genPackage, expInOcl)/]
[/if]
[if (ast.source.type.oclIsKindOf(TupleType))]
[let tupleType : TupleType = ast.source.type.oclAsType(TupleType)]
[let tuplePartName : String = ast.referredProperty.name]
[let tuplePartIndex : OCLInteger = tupleType.ownedAttribute.name->sortedBy(n|n)->indexOf(tuplePartName)]
Object [ast.symbolName(expInOcl)/] = ((<%TupleValue%>)[ast.source.symbolName(expInOcl)/]).getValue([tuplePartIndex - 1/]);[/let][/let][/let]
[elseif (ast.referredProperty.isStatic)]
[let astName : String = ast.symbolName(expInOcl)]
[let className : String = if ast.referredProperty.implementationClass <> null then '<%' + ast.referredProperty.implementationClass + '%>.INSTANCE' else genPackage.getImplementationName(ast.referredProperty) endif]
Object [astName/] = [className/].evaluate(evaluator, [ast.type.typeId(expInOcl)/], [ast.source.symbolName(expInOcl)/]);
[/let][/let]
[else]
if ([ast.source.symbolName(expInOcl)/] == null) { throw new <%InvalidValueException%>("Null property source"); }
[ast.source.emitUnbox(ast, genPackage, expInOcl)/][genPackage.getEscapedPropertyType(ast.referredProperty)/] [ast.defineFlag('unboxed_' + ast.symbolName(expInOcl))/] = unboxed_[ast.source.symbolName(expInOcl)/].[genPackage.getPropertyGetter(ast.referredProperty)/]();
[ast.emitBox(importer, genPackage, expInOcl)/]
[/if][/template]

[template public emitExpression(ast : TupleLiteralExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[for (part : TupleLiteralPart | ast.part->reject(initExpression.isConstant()))]
[part.initExpression.emitExpression(importer, genPackage, expInOcl)/]
[/for]
<%TupleValue%> [ast.symbolName(expInOcl)/] = createTupleValue([ast.type.typeId(expInOcl)/][for (part : TupleLiteralPart | ast.part)], [part.initExpression.symbolName(expInOcl)/][/for]);[/template]

[template public emitExpression(ast : TypeExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)][/template]

[template public emitExpression(ast : VariableExp, importer : NamedElement, genPackage : GenPackage, expInOcl : ExpressionInOCL)][/template]

[template public emitPrettyPrintHeader(ast : OCLExpression)]
[ast.prettyPrint().trim()/]
[/template]

[template public emitUnbox(ast : OCLExpression, disambiguator : OclAny, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[let type : Type = ast.type]
[let sourceTypeName : String = ast.type.getEscapedInterfaceName(genPackage)]
[let boxedName : String = ast.symbolName(expInOcl)]
[let unboxedName : String = 'unboxed_' + boxedName]
[let isUnboxed : Boolean = (if 'self' = boxedName then expInOcl else disambiguator endif).isDefinedFlag(unboxedName)]
[if (not isUnboxed)]
[if (type.oclIsKindOf(pivot::Enumeration))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(OrderedSetType))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(SetType))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(SequenceType))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(BagType))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(LambdaType))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(TupleType))]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.oclIsKindOf(PrimitiveType))]
[if (type.name = 'Boolean')]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/];
[elseif (type.name = 'UnlimitedNatural')]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.name = 'Integer')]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[elseif (type.name = 'Real')]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/].asNavigableObject();
[else]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/];	// [type.name/]
[/if]
[elseif ((type.name = 'Type') or (type.name = 'CollectionType'))]
assert [boxedName/] != null;
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])((<%TypeValue%>)[boxedName/]).getInstanceType();
[elseif (not isUnboxed)]
[sourceTypeName/] [disambiguator.defineFlag(unboxedName)/] = ([sourceTypeName/])[boxedName/];	// [type.name/]
[/if][/if][/let][/let][/let][/let][/let][/template]

[template public generateTypeOf(genPackage : GenPackage, expInOcl : ExpressionInOCL, ast : OCLExpression)]
evaluator.getStaticTypeOf([ast.symbolName(expInOcl)/][/template]

[template public generateTypeOf(genPackage : GenPackage, expInOcl : ExpressionInOCL, ast : VariableExp)]
evaluator.getStaticTypeOf([ast.referredVariable.symbolName(expInOcl)/][/template]

[query public usesInvalid(operation : Operation) : Boolean =
((operation.owningType.name = 'Boolean') and (operation.ownedParameter->size() = 1))
or ((operation.owningType.name = 'OclAny')  and (operation.ownedParameter->size() = 0))/]

[query public isBoxable(type : Type) : Boolean =
type.oclIsKindOf(pivot::Enumeration) or type.oclIsKindOf(CollectionType) or type.oclIsKindOf(LambdaType) or type.oclIsKindOf(TupleType)
or (type.oclIsKindOf(PrimitiveType) and ((type.name = 'UnlimitedNatural') or (type.name = 'Integer') or (type.name = 'Real')))
or (type.name = 'Type') or (type.name = 'CollectionType')/]

