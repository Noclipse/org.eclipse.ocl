[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::common::expressionTemplates('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/GenModel')/]

[import org::eclipse::ocl::examples::codegen::common::constantTemplates/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::stringQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : CollectionItem)]
[if (not ast.item.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast.item)/]
[/if]
[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : CollectionLiteralExp) ? (not ast.isConstant())]
[for (part : CollectionLiteralPart | ast.part->reject(isConstantCollectionLiteralPart()))]
[genPackage.generateExpression(expressionInOcl, part)/]
[/for]
[genPackage.generateLiteral(expressionInOcl, ast)/]
[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : CollectionRange)]
[if (not ast.first.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast.first)/]
[/if]
[if (not ast.last.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast.last)/]
[/if]
[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : Element)]
Value [expressionInOcl.symbolName(ast)/] = <<[ast.eClass().name/]>>;
[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : IfExp)]
[if (not ast.condition.isConstant())]
	[genPackage.generateExpression(expressionInOcl, ast.condition)/]
[/if]
[let astName : String = expressionInOcl.symbolName(ast)]
Value [astName/];
if ([expressionInOcl.symbolName(ast.condition)/].isTrue()) {
[if (not ast.thenExpression.isConstant())]
	[genPackage.generateExpression(expressionInOcl, ast.thenExpression)/]
[/if]
	[astName/] = [expressionInOcl.symbolName(ast.thenExpression)/];
}
else if ([expressionInOcl.symbolName(ast.condition)/].isFalse()) {
[if (not ast.elseExpression.isConstant())]
	[genPackage.generateExpression(expressionInOcl, ast.elseExpression)/]
[/if]
	[astName/] = [expressionInOcl.symbolName(ast.elseExpression)/];
}
else if ([expressionInOcl.symbolName(ast.condition)/].isNull()) {
	[astName/] = valueFactory.throwInvalidValueException("null if condition");
}
else {
	[astName/] = valueFactory.throwInvalidValueException("invalid if condition");
}[/let][/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : IterateExp)]
[let arity : Integer = ast.iterator->size()]
[let leftVarName : String = expressionInOcl.symbolName(ast.source)]
[let accVarName : String = expressionInOcl.symbolName(ast.result)]
[let astName : String = expressionInOcl.symbolName(ast)]
[genPackage.generateExpression(expressionInOcl, ast.source)/]
[genPackage.generateExpression(expressionInOcl, ast.result.initExpression)/]
[for (i : Variable | ast.iterator)]
//Iterator<Value> [expressionInOcl.symbolName(i)/]_var = [leftVarName/].toIteratorValue();	// iterator: [i.name/]
[/for]  

/** 
 * Implementation of the iterate body.
 *
 * [ast._'body'.toString()/]
 */
AbstractBinaryOperation body_[astName/] = new AbstractBinaryOperation()
{
	public Value evaluate([emitDomainEvaluationType('DomainEvaluator')/] evaluator, [emitDomainElementsType('DomainType')/] returnType, Value [expressionInOcl.symbolName(ast.result)/][for (i : Variable | ast.iterator)], Value [expressionInOcl.symbolName(i)/][/for]) throws [emitDomainEvaluationType('InvalidValueException')/] {
		[genPackage.generateExpression(expressionInOcl, ast._'body')/]
		return [expressionInOcl.symbolName(ast._'body')/];
	}
};
[emitDomainElementsType('DomainType')/] static_[astName/] = [expressionInOcl.symbolName(ast.source)/].getType();
LibraryIteration dynamic_[astName/] = (LibraryIteration)static_[astName/].lookupImplementation(standardLibrary, [genPackage.importQualifiedLiteralName(ast.referredIteration)/]);
Executor[getArityMultiple(arity)/]IterationManager manager_[astName/] = new Executor[getArityMultiple(arity)/]IterationManager(evaluator, [expressionInOcl.symbolName(ast.result.type)/], body_[astName/], ([emitDomainValuesType('CollectionValue')/])[leftVarName/], [expressionInOcl.symbolName(ast.result.initExpression)/]);
Value [astName/] = dynamic_[astName/].evaluateIteration(manager_[astName/]);[/let][/let][/let][/let][/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : IteratorExp)]
[let arity : Integer = ast.iterator->size()]
[let leftVarName : String = expressionInOcl.symbolName(ast.source)]
[let astName : String = expressionInOcl.symbolName(ast)]
[genPackage.generateExpression(expressionInOcl, ast.source)/]

/** 
 * Implementation of the iterator body.
 *
 * [ast._'body'.toString()/]
 */
[emitOperationType('Abstract', arity+1)/] body_[astName/] = new [emitOperationType('Abstract', arity+1)/]()
{
	public Value evaluate([emitDomainEvaluationType('DomainEvaluator')/] evaluator, [emitDomainElementsType('DomainType')/] returnType, Value sourceValue[for (i : Integer | Sequence{1..arity})]
, Value iterator[i/][/for]) throws [emitDomainEvaluationType('InvalidValueException')/] {
[for (i : Integer | Sequence{1..arity})]
		Value [expressionInOcl.symbolName(ast.iterator->at(i))/] = iterator[i/];	// iterator: [ast.iterator->at(i).name/]
[/for]  
		[genPackage.generateExpression(expressionInOcl, ast._'body')/]
		return [expressionInOcl.symbolName(ast._'body')/];
	}
};
[emitDomainElementsType('DomainType')/] static_[astName/] = [expressionInOcl.symbolName(ast.source)/].getType();
LibraryIteration dynamic_[astName/] = (LibraryIteration)static_[astName/].lookupImplementation(standardLibrary, [genPackage.importQualifiedLiteralName(ast.referredIteration)/]);
Value acc_[astName/] = dynamic_[astName/].createAccumulatorValue(evaluator, [genPackage.importQualifiedLiteralName(ast.type)/], [genPackage.importQualifiedLiteralName(ast._body.type)/]);
Executor[getArityMultiple(arity)/]IterationManager manager_[astName/] = new Executor[getArityMultiple(arity)/]IterationManager(evaluator, [genPackage.importQualifiedLiteralName(ast.type)/], body_[astName/], ([emitDomainValuesType('CollectionValue')/])[expressionInOcl.symbolName(ast.source)/], acc_[astName/]);
Value [astName/] = dynamic_[astName/].evaluateIteration(manager_[astName/]);[/let][/let][/let][/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : LetExp)]
[if (not ast.variable.initExpression.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast.variable.initExpression)/]
[/if]
final Value [expressionInOcl.symbolName(ast.variable)/] = [expressionInOcl.symbolName(ast.variable.initExpression)/];
[if (not ast._in.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast._in)/]
[/if]
final Value [expressionInOcl.symbolName(ast)/] = [expressionInOcl.symbolName(ast.variable)/];[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : LiteralExp)][/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : OperationCallExp) ? ((ast.referredOperation.owningType.name = 'Boolean') and (ast.referredOperation.ownedParameter->size() = 1))]
[let astName : String = expressionInOcl.symbolName(ast)]
[if (not ast.source.isConstant())]
Value left[astName/];
try {[emitSuppressThrowWarnings(genPackage)/]
	[genPackage.generateExpression(expressionInOcl, ast.source)/]
	left[astName/] = [expressionInOcl.symbolName(ast.source)/];
} catch ([emitDomainEvaluationType('InvalidValueException')/] e) {
	left[astName/] = valueFactory.getInvalid();
}
Value [expressionInOcl.symbolName(ast.source)/] = left[astName/];
[/if]
[let right : OclExpression = ast.argument->at(1)]
[if (not right.isConstant())]
Value right[astName/];
try {[emitSuppressThrowWarnings(genPackage)/]
	[genPackage.generateExpression(expressionInOcl, right)/]
	right[astName/] = [expressionInOcl.symbolName(right)/];
} catch ([emitDomainEvaluationType('InvalidValueException')/] e) {
	right[astName/] = valueFactory.getInvalid();
}
Value [expressionInOcl.symbolName(right)/] = right[astName/];
[/if]
[/let]
[generateCall(expressionInOcl, ast)/][/let][/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : OperationCallExp) ? ((ast.referredOperation.owningType.name <> 'Boolean') or (ast.referredOperation.ownedParameter->size() <> 1))]
[if (not ast.source.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast.source)/]
[/if]
[for (argument : OclExpression | ast.argument->reject(isConstant()))]
[genPackage.generateExpression(expressionInOcl, argument)/]
[/for]
[generateCall(expressionInOcl, ast)/][/template]

[template public generateCall(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : OperationCallExp)]
[let arity : Integer = ast.referredOperation.ownedParameter->size()]
[let astName : String = expressionInOcl.symbolName(ast)]
[emitDomainElementsType('DomainType')/] static_[astName/] = [genPackage.generateTypeOf(expressionInOcl, ast.source)/][if arity > 0]
[for (index : Integer | Sequence{1..arity})]
[if ast.referredOperation.ownedParameter->at(index).type.oclIsKindOf(SelfType)]
, [expressionInOcl.symbolName(ast.argument->at(index))/][/if][/for][/if]);
[emitOperationType('Library', arity+1)/] dynamic_[astName/] = ([emitOperationType('Library', arity+1)/])static_[astName/].lookupImplementation(standardLibrary, [expressionInOcl.symbolName(ast.referredOperation)/]);
Value [astName/] = dynamic_[astName/].evaluate(evaluator, [expressionInOcl.symbolName(ast.type)/], [expressionInOcl.symbolName(ast.source)/][for (argument : OclExpression | ast.argument) before (', ') separator (', ')][expressionInOcl.symbolName(argument)/][/for]);[/let][/let][/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : PropertyCallExp)]
[if (not ast.source.isConstant())]
[genPackage.generateExpression(expressionInOcl, ast.source)/]
[/if]
Value [expressionInOcl.symbolName(ast)/] = I[expressionInOcl.symbolName(ast.referredProperty)/].evaluate(evaluator, [expressionInOcl.symbolName(ast.type)/], [expressionInOcl.symbolName(ast.source)/], [expressionInOcl.symbolName(ast.referredProperty)/]);[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : TupleLiteralExp)]
final [emitJavaUtilType('Map')/]<[emitDomainElementsType('DomainTypedElement')/], Value> m[expressionInOcl.symbolName(ast)/] = new [emitJavaUtilType('HashMap')/]<[emitDomainElementsType('DomainTypedElement')/], Value>();
[for (part : TupleLiteralPart | ast.part->reject(initExpression.isConstant()))]
[genPackage.generateExpression(expressionInOcl, part.initExpression)/]
[/for]
[for (part : TupleLiteralPart | ast.part)]
m[expressionInOcl.symbolName(ast)/].put([genPackage.getTupleLiteralPartLookup(part).getPrefixedSymbolName('tuple_part_')/], [expressionInOcl.symbolName(part)/]);
[/for]
Value [expressionInOcl.symbolName(ast)/] = valueFactory.createTupleValue([expressionInOcl.symbolName(ast.type)/], m[expressionInOcl.symbolName(ast)/]);[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : TypeExp)]
Value [expressionInOcl.symbolName(ast)/] = valueFactory.createTypeValue([genPackage.importQualifiedLiteralName(ast.referredType)/]);[/template]

[template public generateExpression(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : VariableExp)][/template]

[template public generateTypeOf(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : OclExpression)]
valueFactory.typeOf([expressionInOcl.symbolName(ast)/][/template]

[template public generateTypeOf(genPackage : GenPackage, expressionInOcl : ExpressionInOcl, ast : VariableExp)]
valueFactory.typeOf([expressionInOcl.symbolName(ast.referredVariable)/][/template]

[query public getAritySuffix(arity : Integer) : String = 
if arity > 2 then 'N' else arity.toString() endif/]
