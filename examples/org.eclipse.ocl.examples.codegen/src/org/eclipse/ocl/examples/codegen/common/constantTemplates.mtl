[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::common::constantTemplates('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/GenModel','http://www.eclipse.org/ocl/3.1.0/OCL4Acceleo')/]

[import org::eclipse::ocl::examples::codegen::common::constantQueries/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::qualifiedLiteralTemplates/]
[import org::eclipse::ocl::examples::codegen::common::stringQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]
[import org::eclipse::ocl::examples::codegen::common::typeIdTemplates/]
[import org::eclipse::ocl::examples::codegen::common::valueQueries/]

[template public emitConstants(expInOcl : ExpressionInOCL, genPackage : GenPackage)]
[let constants : String = expInOcl.bodyExpression.emitConstants(genPackage, expInOcl)]
[emitConstants(constants)/]
[/let]
[/template]

[template public gatherConstants(ast : Element, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.emitConstants(genPackage, expInOcl)/]
[let allElements : Sequence(Element) = ast.eAllContents()->filter(Element)]
[debug(allElements, 'allElements')/]
[let allCandidates : Sequence(Element) = allElements->reject(oclIsKindOf(CollectionLiteralPart) or oclIsKindOf(TupleLiteralPart) or let container : OclAny = eContainer() in container.oclIsKindOf(CollectionLiteralPart) or container.oclIsKindOf(TupleLiteralPart))]
[debug(allCandidates, 'allCandidates')/]
[for (pElement : Element | allCandidates)]
[pElement.emitConstants(genPackage, expInOcl)/]
[/for][/let][/let]
[/template]

[template public emitConstants(dummy : OclAny, constants : String)]
[let uniqueConstants : OrderedSet(String) = constants.tokenize('\n').trim()->excluding('')->asOrderedSet()]
[for (uniqueConstant : String | uniqueConstants)]
[uniqueConstant.replace('static ', '')/]
[/for][/let][/template]

[template public emitNonStatics(dummy : OclAny, constants : String)]
[let uniqueConstants : OrderedSet(String) = constants.tokenize('\n').trim()->excluding('')->asOrderedSet()]
[for (uniqueConstant : String | uniqueConstants->reject(indexOf('static ') > 0))]
[uniqueConstant/]
[/for][/let][/template]

[template public emitStatics(dummy : OclAny, constants : String)]
[let uniqueConstants : OrderedSet(String) = constants.tokenize('\n').trim()->excluding('')->asOrderedSet()]
[for (uniqueConstant : String | uniqueConstants->select(indexOf('static ') > 0))]
[uniqueConstant/]
[/for][/let][/template]

[template protected emitConstants(ast : BagType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.BAG.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : BooleanLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [ast.symbolName(expInOcl)/] = [if (ast.booleanSymbol)]true[else]false[/if];
[/template]

[template protected emitConstants(ast : CollectionItem, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.item.emitConstants(genPackage, expInOcl)/]
[/template]

[template protected emitConstants(ast : CollectionLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.type.emitConstants(genPackage, expInOcl)/]
[if (not ast.isConstantCollectionLiteralExp())]
[for (part : CollectionLiteralPart | ast.part)]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
[debug(ast, 'nonConstant')/]
[elseif ((ast.part->size() = 1) and ast.type.oclIsKindOf(SequenceType) and ast.part->at(1).oclIsKindOf(CollectionRange))]
[for (part : CollectionLiteralPart | ast.part)]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
[let range : CollectionRange = ast.part->at(1).oclAsType(CollectionRange)]
[debug(ast, 'oneRange')/]
static final @NonNull Object [ast.symbolName(expInOcl)/] = create[ast.kind.toString()/]Range([ast.type.typeId(expInOcl)/], createRange([range.first.symbolName(expInOcl)/], [range.last.symbolName(expInOcl)/]));[/let]
[else]
[let folded : CollectionLiteralExp = if ast.isFoldable() then ast.evaluate().oclAsType(CollectionLiteralExp) else ast endif]
[debug(folded, 'folded')/]
[for (part : CollectionLiteralPart | folded.part)]
[debug(part, 'foldedPart')/]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
static final @NonNull Object [ast.symbolName(expInOcl)/] = create[folded.kind.toString()/]Value([folded.type.typeId(expInOcl)/][for (part : CollectionLiteralPart | folded.part)], [part.oclAsType(CollectionItem).item.symbolName(expInOcl)/][/for]);[/let]
[/if]
[/template]

[template protected emitConstants(ast : CollectionRange, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.first.emitConstants(genPackage, expInOcl)/]
[ast.last.emitConstants(genPackage, expInOcl)/]
[/template]

[template public emitConstants(ast : ConstructorExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[/template]

[template public emitConstants(ast : ConstructorPart, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%ExecutorProperty%> [ast.referredProperty.symbolName(expInOcl)/] = [ast.referredProperty.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : Element, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[/template]

[template protected emitConstants(ast : EnumLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [ast.symbolName(expInOcl)/] = createEnumerationLiteralValue([ast.referredEnumLiteral.emitQualifiedLiteralName(genPackage)/]);
[/template]

[template protected emitConstants(ast : IntegerLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%IntegerValue%> [ast.symbolName(expInOcl)/] = integerValueOf([ast.integerValueOfInitializer()/]);
[/template]

[template protected emitConstants(ast : InvalidLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[/template]

[template protected emitConstants(ast : IterateExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredIteration.symbolName(expInOcl)/] = [ast.referredIteration.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : IteratorExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
[ast._body.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredIteration.symbolName(expInOcl)/] = [ast.referredIteration.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : Metaclass, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.instanceType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.METACLASS.getSpecializedId([ast.instanceType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : NullLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final Object [ast.symbolName(expInOcl)/] = null;
[/template]

[template protected emitConstants(ast : OperationCallExp, genPackage : GenPackage, expInOcl : ExpressionInOCL) ?(genPackage.isFinal(ast.referredOperation))]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredOperation.symbolName(expInOcl)/] = [ast.referredOperation.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : OperationCallExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredOperation.symbolName(expInOcl)/] = [ast.referredOperation.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : OrderedSetType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.ORDERED_SET.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(type : PrimitiveType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%PrimitiveTypeId%> [type.symbolName(expInOcl)/] = <%TypeId%>.[type.upperName()/];
[/template]

[template protected emitConstants(ast : PropertyCallExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[if (true or ast.referredProperty.owningType.oclIsKindOf(TupleType))]
[ast.type.emitConstants(genPackage, expInOcl)/]
[/if]
[/template]

[template protected emitConstants(ast : RealLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%RealValue%> [ast.symbolName(expInOcl)/] = realValueOf([ast.realValueOfInitializer()/]);
[/template]

[template protected emitConstants(ast : SequenceType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.SEQUENCE.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : SetType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.SET.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : StringLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [ast.symbolName(expInOcl)/] = "[ast.javaString()/]";
[/template]

[template protected emitConstants(ast : TupleLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[for (part : TupleLiteralPart | ast.part)]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
[if (ast.isConstantTupleLiteralExp())]
static final @NonNull <%TupleValue%> [ast.symbolName(expInOcl)/] = createTupleValue([ast.type.typeId(expInOcl)/][for (part : TupleLiteralPart | ast.part)], [part.initExpression.symbolName(expInOcl)/][/for]);
[/if]
[/template]

[template protected emitConstants(ast : TupleLiteralPart, genPackage : GenPackage, expInOcl : ExpressionInOCL)][/template]

[template protected emitConstants(ast : TupleType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[for (part : Property | ast.ownedAttribute)]
[part.type.emitConstants(genPackage, expInOcl)/]
[/for]
static final @NonNull <%TupleTypeId%> [ast.symbolName(expInOcl)/] = <%IdManager%>.INSTANCE.getTupleTypeId("Tuple"[for (part : Property | ast.ownedAttribute)], <%IdManager%>.INSTANCE.createTuplePartId("[part.javaString()/]", [part.type.typeId(expInOcl)/])[/for]);
[/template]

[template protected emitConstants(type : Type, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%TypeId%> [type.symbolName(expInOcl)/] = [type.emitQualifiedLiteralName(genPackage)/].getTypeId();
[/template]

[template protected emitConstants(ast : TypeExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [type.symbolName(expInOcl)/] = createTypeValue([ast.referredType.emitQualifiedLiteralName(genPackage)/]);[/template]

[template protected emitConstants(ast : UnlimitedNaturalLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (ast.asIntegerStringOrEmpty() = '')]
static final @NonNull <%UnlimitedValue%> [ast.symbolName(expInOcl)/] = UNLIMITED_VALUE;
[else]
static final @NonNull <%IntegerValue%> [ast.symbolName(expInOcl)/] = integerValueOf([ast.integerValueOfInitializer()/]);
[/if]
[/template]

[template protected emitStandardLibrary(dummy : OclAny)]
final @NonNull <%DomainStandardLibrary%> standardLibrary = evaluator.getStandardLibrary();
[/template]
