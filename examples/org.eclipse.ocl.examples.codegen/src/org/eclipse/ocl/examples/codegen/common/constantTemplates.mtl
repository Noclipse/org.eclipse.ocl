[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::common::constantTemplates('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/GenModel')/]

[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::qualifiedLiteralTemplates/]
[import org::eclipse::ocl::examples::codegen::common::stringQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]
[import org::eclipse::ocl::examples::codegen::common::typeIdTemplates/]

[template public emitConstants(expInOcl : ExpressionInOCL, genPackage : GenPackage)]
[let constants : String = expInOcl.bodyExpression.emitConstants(genPackage, expInOcl)]
[emitConstants(constants)/]
[/let]
[/template]

[template public gatherConstants(ast : Element, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.emitConstants(genPackage, expInOcl)/]
[for (pElement : Element | ast.eAllContents()->filter(Element))]
[pElement.emitConstants(genPackage, expInOcl)/]
[/for]
[/template]

[template public emitConstants(dummy : OclAny, constants : String)]
[let uniqueConstants : OrderedSet(String) = constants.tokenize('\n').trim()->excluding('')->asOrderedSet()]
[for (uniqueConstant : String | uniqueConstants)]
[uniqueConstant.replace('static ', '')/]
[/for][/let][/template]

[template public emitNonStatics(dummy : OclAny, constants : String)]
[let uniqueConstants : OrderedSet(String) = constants.tokenize('\n').trim()->excluding('')->asOrderedSet()]
[for (uniqueConstant : String | uniqueConstants->reject(startsWith('static')))]
[uniqueConstant/]
[/for][/let][/template]

[template public emitStatics(dummy : OclAny, constants : String)]
[let uniqueConstants : OrderedSet(String) = constants.tokenize('\n').trim()->excluding('')->asOrderedSet()]
[for (uniqueConstant : String | uniqueConstants->select(startsWith('static')))]
[uniqueConstant/]
[/for][/let][/template]

[template protected emitConstants(ast : BagType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.BAG.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : BooleanLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [ast.symbolName(expInOcl)/] = [if (ast.booleanSymbol)]true[else]false[/if];
[/template]

[template protected emitConstants(ast : CollectionLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL) ? ((ast.part->size() = 1) and (ast.part->filter(CollectionRange)->size() = 1))]
[ast.type.emitConstants(genPackage, expInOcl)/]
[if (ast.isConstantCollectionLiteralExp())]
[for (part : CollectionLiteralPart | ast.part)]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
[ast.emitLiteral(genPackage, expInOcl, true)/]
[/if]
[/template]

[template protected emitConstants(ast : CollectionLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL) ? ((ast.part->size() <> 1) or (ast.part->filter(CollectionRange)->size() <> 1))]
[ast.type.emitConstants(genPackage, expInOcl)/]
[if (ast.isConstantCollectionLiteralExp())]
[for (part : CollectionLiteralPart | ast.part)]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
[ast.emitLiteral(genPackage, expInOcl, true)/]
[/if]
[/template]

[template protected emitConstants(ast : CollectionItem, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.item.emitConstants(genPackage, expInOcl)/]
[/template]

[template protected emitConstants(ast : CollectionRange, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[ast.first.emitConstants(genPackage, expInOcl)/]
[ast.last.emitConstants(genPackage, expInOcl)/]
[/template]

[template public emitConstants(ast : ConstructorExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[/template]

[template public emitConstants(ast : ConstructorPart, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%ExecutorProperty%> [ast.referredProperty.symbolName(expInOcl)/] = [ast.referredProperty.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : Element, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[/template]

[template protected emitConstants(ast : EnumLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [ast.symbolName(expInOcl)/] = createEnumerationLiteralValue([ast.referredEnumLiteral.emitQualifiedLiteralName(genPackage)/]);
[/template]

[template protected emitConstants(ast : IntegerLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%IntegerValue%> [ast.symbolName(expInOcl)/] = integerValueOf([ast.integerSymbol/]);
[/template]

[template protected emitConstants(ast : InvalidLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%InvalidValue%> [ast.symbolName(expInOcl)/] = INVALID_VALUE;
[/template]

[template protected emitConstants(ast : IterateExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredIteration.symbolName(expInOcl)/] = [ast.referredIteration.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : IteratorExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
[ast._body.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredIteration.symbolName(expInOcl)/] = [ast.referredIteration.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : Metaclass, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.instanceType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.METACLASS.getSpecializedId([ast.instanceType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : NullLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final Object [ast.symbolName(expInOcl)/] = null;
[/template]

[template protected emitConstants(ast : OperationCallExp, genPackage : GenPackage, expInOcl : ExpressionInOCL) ?(genPackage.isFinal(ast.referredOperation))]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredOperation.symbolName(expInOcl)/] = [ast.referredOperation.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : OperationCallExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.type.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%ExecutorOperation%> [ast.referredOperation.symbolName(expInOcl)/] = [ast.referredOperation.emitQualifiedLiteralName(genPackage)/];
[/template]

[template protected emitConstants(ast : OrderedSetType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.ORDERED_SET.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(type : PrimitiveType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%PrimitiveTypeId%> [type.symbolName(expInOcl)/] = <%TypeId%>.[type.upperName()/];
[/template]

[template protected emitConstants(ast : PropertyCallExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[if (true or ast.referredProperty.owningType.oclIsKindOf(TupleType))]
[ast.type.emitConstants(genPackage, expInOcl)/]
[/if]
[/template]

[template protected emitConstants(ast : RealLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%RealValue%> [ast.symbolName(expInOcl)/] = realValueOf([ast.realSymbol/]);
[/template]

[template protected emitConstants(ast : SequenceType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.SEQUENCE.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : SetType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[ast.elementType.emitConstants(genPackage, expInOcl)/]
static final @NonNull <%CollectionTypeId%> [ast.symbolName(expInOcl)/] = <%TypeId%>.SET.getSpecializedId([ast.elementType.typeId(expInOcl)/]);
[/template]

[template protected emitConstants(ast : StringLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [ast.symbolName(expInOcl)/] = "[ast.javaString()/]";
[/template]

[template protected emitConstants(ast : TupleLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (ast.isConstantTupleLiteralExp())]
[for (part : TupleLiteralPart | ast.part)]
[part.emitConstants(genPackage, expInOcl)/]
[/for]
[ast.emitLiteral(genPackage, expInOcl, true)/]
[/if]
[/template]

[template protected emitConstants(ast : TupleLiteralPart, genPackage : GenPackage, expInOcl : ExpressionInOCL)][/template]

[template protected emitConstants(ast : TupleType, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[emitStandardLibrary()/]
[for (part : Property | ast.ownedAttribute)]
[part.type.emitConstants(genPackage, expInOcl)/]
[/for]
static final @NonNull <%TupleTypeId%> [ast.symbolName(expInOcl)/] = <%IdManager%>.INSTANCE.getTupleTypeId("Tuple"[for (part : Property | ast.ownedAttribute)], <%IdManager%>.INSTANCE.createTuplePartId("[part.javaString()/]", [part.type.typeId(expInOcl)/])[/for]);
[/template]

[template protected emitConstants(type : Type, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull <%TypeId%> [type.symbolName(expInOcl)/] = [type.emitQualifiedLiteralName(genPackage)/].getTypeId();
[/template]

[template protected emitConstants(ast : TypeExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
static final @NonNull Object [type.symbolName(expInOcl)/] = createTypeValue([ast.referredType.emitQualifiedLiteralName(genPackage)/]);[/template]

[template protected emitConstants(ast : UnlimitedNaturalLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL)]
[if (ast.asIntegerStringOrNull() = null)]
static final @NonNull <%UnlimitedValue%> [ast.symbolName(expInOcl)/] = UNLIMITED_VALUE;
[else]
static final @NonNull <%IntegerValue%> [ast.symbolName(expInOcl)/] = integerValueOf([ast.unlimitedNaturalSymbol/]);
[/if]
[/template]

[template public emitLiteral(ast : BagType, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
standardLibrary.getBagType([ast.elementType.emitLiteral(genPackage, expInOcl, isStatic)/])[/template]

[template public emitLiteral(ast : Metaclass, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
standardLibrary.getMetaclass([ast.instanceType.emitLiteral(genPackage, expInOcl, isStatic)/])[/template]

[template public emitLiteral(ast : CollectionItem, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
l[ast.eContainer().oclAsType(Element).symbolName(expInOcl)/].add([ast.item.symbolName(expInOcl)/]); // [ast.symbolName(expInOcl)/]
[/template]

[template public emitLiteral(ast : CollectionLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean) ? (ast.rangesAreUnused())]
[let astName : String = ast.symbolName(expInOcl)]
[if (isStatic)]static [/if]final @NonNull Object [astName/] = create[ast.kind.toString()/]Value([ast.type.typeId(expInOcl)/][for (part : CollectionItem | ast.part->filter(CollectionItem))], [part.item.symbolName(expInOcl)/][/for]);[/let][/template]

[template public emitLiteral(ast : CollectionLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean) ? (ast.rangesAreSimple())]
[let astName : String = ast.symbolName(expInOcl)]
[let range : CollectionRange = ast.part->at(1).oclAsType(CollectionRange)]
[if (isStatic)]static [/if]final @NonNull <%IntegerRange%> r[astName/] = createRange([range.first.symbolName(expInOcl)/].asIntegerValue(), [range.last.symbolName(expInOcl)/].asIntegerValue());
[if (isStatic)]static [/if]final @NonNull Object [astName/] = create[ast.kind.toString()/]Range([ast.type.typeId(expInOcl)/], r[astName/]);[/let][/let][/template]

[template public emitLiteral(ast : CollectionLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean) ? (not ast.rangesAreUnused() and not ast.rangesAreSimple())]
[let astName : String = ast.symbolName(expInOcl)]
[if (isStatic)]static [/if]final @NonNull <%java.util.List%><Object> l[astName/] = new <%java.util.ArrayList%><Object>();
[for (part : CollectionLiteralPart | ast.part)]
[part.emitLiteral(genPackage, expInOcl, isStatic)/]
[/for]
[if (isStatic)]static [/if]final @NonNull Object [astName/] = standardLibrary.create[ast.kind.toString()/]ValueOf([ast.type.typeId(expInOcl)/], l[astName/]);
[/let][/template]

[template public emitLiteral(ast : CollectionLiteralPart, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)][/template]

[template public emitLiteral(ast : CollectionRange, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
for (long [ast.symbolName(expInOcl)/] = [ast.first.symbolName(expInOcl)/].asInteger(), z[ast.symbolName(expInOcl)/] = [ast.last.symbolName(expInOcl)/].asInteger(); [ast.symbolName(expInOcl)/] <= z[ast.symbolName(expInOcl)/]; [ast.symbolName(expInOcl)/]++) {
	l[ast.eContainer().oclAsType(Element).symbolName(expInOcl)/].add(integerValueOf([ast.symbolName(expInOcl)/]));
} // [ast.symbolName(expInOcl)/]
[/template]

[template public emitLiteral(ast : OrderedSetType, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
standardLibrary.getOrderedSetType([ast.elementType.emitLiteral(genPackage, expInOcl, isStatic)/])[/template]

[template public emitLiteral(ast : SequenceType, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
standardLibrary.getSequenceType([ast.elementType.emitLiteral(genPackage, expInOcl, isStatic)/])[/template]

[template public emitLiteral(ast : SetType, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
standardLibrary.getType([ast.elementType.emitLiteral(genPackage, expInOcl, isStatic)/])[/template]

[template public emitLiteral(ast : TupleLiteralExp, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
[let astName : String = ast.symbolName(expInOcl)]
<%TupleValue%> [astName/] = createTupleValue([ast.type.typeId(expInOcl)/][for (part : TupleLiteralPart | ast.part)], [part.initExpression.symbolName(expInOcl)/][/for]);[/let][/template]

[template public emitLiteral(ast : Type, genPackage : GenPackage, expInOcl : ExpressionInOCL, isStatic : Boolean)]
[ast.emitQualifiedLiteralName(genPackage)/][/template]

[template protected emitStandardLibrary(dummy : OclAny)]
final @NonNull <%DomainStandardLibrary%> standardLibrary = evaluator.getStandardLibrary();
[/template]

[query public isConstant(ast : OCLExpression) : Boolean =
if ast.oclIsKindOf(PrimitiveLiteralExp) then isConstantPrimitiveLiteralExp(ast.oclAsType(PrimitiveLiteralExp))
else if ast.oclIsKindOf(CollectionLiteralExp) then isConstantCollectionLiteralExp(ast.oclAsType(CollectionLiteralExp))
else if ast.oclIsKindOf(TupleLiteralExp) then isConstantTupleLiteralExp(ast.oclAsType(TupleLiteralExp))
else if ast.oclIsKindOf(TypeExp) then isConstantTypeExp(ast.oclAsType(TypeExp))
else false
endif endif endif endif /]

[query public isConstantCollectionItem(ast : CollectionItem) : Boolean =
ast.item.isConstant() /]

[query public isConstantCollectionLiteralExp(ast : CollectionLiteralExp) : Boolean =
ast.part->forAll(isConstantCollectionLiteralPart()) /]

[query public isConstantCollectionLiteralPart(ast : CollectionLiteralPart) : Boolean =
if ast.oclIsKindOf(CollectionItem) then isConstantCollectionItem(ast.oclAsType(CollectionItem))
else if ast.oclIsKindOf(CollectionRange) then isConstantCollectionRange(ast.oclAsType(CollectionRange))
else false
endif endif /]

[query public isConstantCollectionRange(ast : CollectionRange) : Boolean =
ast.first.isConstant() and ast.last.isConstant() /]

[query public isConstantPrimitiveLiteralExp(ast : PrimitiveLiteralExp) : Boolean =
true /]

[query public isConstantTupleLiteralExp(ast : TupleLiteralExp) : Boolean =
ast.part->forAll(isConstantTupleLiteralPart()) /]

[query public isConstantTupleLiteralPart(ast : TupleLiteralPart) : Boolean =
ast.initExpression.isConstant() /]

[query public isConstantTypeExp(ast : TypeExp) : Boolean =
true /]

[query public rangesAreSimple(ast : CollectionLiteralExp) : Boolean = (ast.part->size() = 1) and (ast.part->filter(CollectionRange)->size() = 1)/]

[query public rangesAreUnused(ast : CollectionLiteralExp) : Boolean = ast.part->filter(CollectionRange)->size() = 0/]
