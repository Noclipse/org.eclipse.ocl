[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::ecore::ocl2java4genmodel('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/Ecore','http://www.eclipse.org/emf/2002/GenModel')/]

[import org::eclipse::ocl::examples::codegen::common::ePackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::expressionTemplates/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]

[template public generateModel(genModel : GenModel)]
[comment @main /]
[for (genPackage : GenPackage | genModel.genPackages)]
[let ePackage : EPackage = genPackage.ecorePackage]
[let pPackage : Package = ePackage.getPivotPackage()]
[generatePackage(genPackage, pPackage)/]
[/let]
[/let]
[/for]
[/template]

[template public generatePackage(genPackage : GenPackage, pkg : Package)]
[let packagePathPrefix : String = if genPackage.basePackage->notEmpty() then genPackage.basePackage.replaceAll('\\.', '/') + '/' else '' endif]
[let packagePrefix : String = packagePathPrefix.replaceAll('/', '.')]
[for (type : Type | pkg.ownedType)]
[generateType(genPackage, type)/]
[for (operation : Operation | type.ownedOperation)]
[generateOperation(genPackage, type, operation)/]
[/for]
[for (property : Property | type.ownedAttribute)]
[generateProperty(genPackage, type, property)/]
[/for]
[/for]
[/let]
[/let]
[/template]

[template public generateType(genPackage : GenPackage, type : Type)]
[let pkg : Package = type._'package']
[for (rule : Constraint | type.ownedRule->select(stereotype = 'invariant'))]
[file (type.getFragmentURI() + '==' + rule.name, false, 'UTF-8')]
[let className : String = type.name + '_' + rule.stereotype + '_' + rule.name]
[let specification : OpaqueExpression = rule.specification.oclAsType(OpaqueExpression)]
/** 
 * [specification.toString()/]
 */
[let expressionInOcl : ExpressionInOcl = type.getExpressionInOcl(specification)]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
try {
	final [importDomainEvaluationType('DomainEvaluator')/] evaluator = [importType('org.eclipse.ocl.examples.library.ecore.EcoreExecutorManager')/].INSTANCE;
	final [importDomainValuesType('ValueFactory')/] valueFactory = evaluator.getValueFactory();
	final [importDomainElementsType('DomainStandardLibrary')/] standardLibrary = valueFactory.getStandardLibrary();
	final [importDomainValuesType('Value')/] [defineSymbolName(expressionInOcl.contextVariable, 'self')/] = valueFactory.valueOf(this);
	[generateExpression(genPackage, 'result', expressionInOcl.bodyExpression, pkg)/]
	final boolean resultIsNull = result.isNull();
	if (!resultIsNull && result.asBoolean()) {	// true => true, false/null => dropthrough, invalid => exception
		return true;
	}
	if (diagnostics != null) {
		int severity = resultIsNull ? [importEmfCommonUtilType('Diagnostic')/].ERROR : [importEmfCommonUtilType('Diagnostic')/].WARNING;
[if (expressionInOcl.messageExpression->notEmpty())]
		[generateExpression(genPackage, 'messageValue', expressionInOcl.messageExpression, pkg)/]
		String message;
		if (messageValue != null) {
			message = messageValue.asString();
		}
		else {
			Object objectLabel;
			if (this instanceof [importEcoreType('EDataType')/]) {
				objectLabel = [importEcoreUtilType('EObjectValidator')/].getValueLabel(([importEcoreType('EDataType')/]) this, result, context);
			}
			else if (result instanceof [importEcoreType('EObject')/]) {
				objectLabel = [importEcoreUtilType('EObjectValidator')/].getObjectLabel(([importEcoreType('EObject')/]) result, context);
			}
			else {
				objectLabel = String.valueOf(result);
			}
			message = [importType('org.eclipse.osgi.util.NLS')/].bind([importDomainMessagesType('EvaluatorMessages')/].ValidationConstraintIsNotSatisfied_ERROR_, "[genPackage.getOperationID(type, rule, false)/]", objectLabel);
		}
	    diagnostics.add(new [importEmfCommonUtilType('BasicDiagnostic')/](severity, [importType(genPackage.getQualifiedValidatorClassName())/].DIAGNOSTIC_SOURCE, [importType(genPackage.getQualifiedValidatorClassName())/].[genPackage.getOperationID(type, rule, true)/], message, new Object ['[]'/] { result }));
[else]
	    diagnostics.add(new [importEmfCommonUtilType('BasicDiagnostic')/](severity, [importType(genPackage.getQualifiedValidatorClassName())/].DIAGNOSTIC_SOURCE, [importType(genPackage.getQualifiedValidatorClassName())/].[genPackage.getOperationID(type, rule, true)/], [importDomainMessagesType('EvaluatorMessages')/].ValidationConstraintIsNotSatisfied_ERROR_, new Object ['[]'/] { result }));
[/if]
	}
	return false;
} catch ([importDomainEvaluationType('InvalidValueException')/] e) {
	throw new [importEmfCommonUtilType('WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/let][/let][/file][/for][/let][/template]

[template public generateOperation(genPackage : GenPackage, type : Type, operation : Operation)]
[let rule : Constraint = operation.ownedRule->any(stereotype = 'body')]
[file (operation.getFragmentURI(), false, 'UTF-8')]
[let className : String = type.name + '_' + operation.name + '_' + rule.stereotype + '_' + rule.name]
/** 
 * [rule.specification.toString()/]
 */
[generateSpecification(genPackage, className, operation, genPackage.getOperationReturnType(operation), rule.specification, type._'package')/][/let][/file][/let][/template]

[template public generateProperty(genPackage : GenPackage, type : Type, property : Property)]
[let derivationRules : OrderedSet(Constraint) = property.ownedRule->select(stereotype = 'derivation')]
[let initialRules : OrderedSet(Constraint) = property.ownedRule->select(stereotype = 'initial')]
[let rule : Constraint = if derivationRules->notEmpty() then derivationRules->any(true) else initialRules->any(true) endif]
[file (property.getFragmentURI(), false, 'UTF-8')]
[let className : String = type.name + '_' + property.name + '_' + rule.stereotype + '_' + rule.name]
/** 
 * [rule.specification.toString()/]
 */
[generateSpecification(genPackage, className, property, genPackage.getPropertyType(property), rule.specification, type._'package')/][/let][/file][/let][/let][/let][/template]

[template public generateSpecification(genPackage : GenPackage, className : String, contextElement : NamedElement, returnCast : String, specification : ValueSpecification, pkg : Package)]
throw new UnsupportedOperationException();
[/template]

[template public generateSpecification(genPackage : GenPackage, className : String, contextElement : NamedElement, returnCast : String, specification : OpaqueExpression, pkg : Package)]
[let expressionInOcl : ExpressionInOcl = contextElement.getExpressionInOcl(specification)]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
try {
	final [importDomainEvaluationType('DomainEvaluator')/] evaluator = [importType('org.eclipse.ocl.examples.library.ecore.EcoreExecutorManager')/].INSTANCE;
	final [importDomainValuesType('ValueFactory')/] valueFactory = evaluator.getValueFactory();
	final [importDomainElementsType('DomainStandardLibrary')/] standardLibrary = valueFactory.getStandardLibrary();
	final [importDomainValuesType('Value')/] [defineSymbolName(expressionInOcl.contextVariable, 'self')/] = valueFactory.valueOf(this);
	[generateConstantLiterals(genPackage, expressionInOcl.bodyExpression, pkg)/][generateConstantTupleParts(genPackage, expressionInOcl.bodyExpression, pkg)/][generateExpression(importDomainValuesType('Value') + ' ', 'result', expressionInOcl.bodyExpression, pkg)/]
	return [returnCast/] valueFactory.getEcoreValueOf(result);
} catch ([importDomainEvaluationType('InvalidValueException')/] e) {
	throw new [importType('org.eclipse.emf.common.util.WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/template]

[template public generateExpression(genPackage : GenPackage, result : String, expression : OclExpression, pkg : Package)]
[let constantLiterals : String = generateConstantLiterals(genPackage, expression, pkg)]
[let constantTupleParts : String = generateConstantTupleParts(genPackage, expression, pkg)]
[let expression : String = generateExpression(genPackage, importDomainValuesType('Value') + ' ', result, expression, pkg)]
[constantLiterals/][constantTupleParts/][expression/][/let][/let][/let][/template]
