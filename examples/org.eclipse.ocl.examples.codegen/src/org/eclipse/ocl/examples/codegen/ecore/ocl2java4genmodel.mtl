[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::ecore::ocl2java4genmodel('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/GenModel')/]

[import org::eclipse::ocl::examples::codegen::common::constantTemplates/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::expressionTemplates/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]

[template public generateModel(genModel : GenModel)]
[comment @main /]
[for (genPackage : GenPackage | genModel.genPackages)]
[let pPackage : Package = genPackage.getPivotPackage()]
[generatePackage(genPackage, pPackage)/]
[/let]
[/for]
[/template]

[template public generatePackage(genPackage : GenPackage, pkg : Package)]
[let packagePathPrefix : String = if genPackage.basePackage->notEmpty() then genPackage.basePackage.replaceAll('\\.', '/') + '/' else '' endif]
[let packagePrefix : String = packagePathPrefix.replaceAll('/', '.')]
[for (type : Type | pkg.ownedType)]
[generateType(genPackage, type)/]
[for (operation : Operation | type.ownedOperation)]
[generateOperation(genPackage, type, operation)/]
[/for]
[for (property : Property | type.ownedAttribute)]
[generateProperty(genPackage, type, property)/]
[/for]
[/for]
[/let]
[/let]
[/template]

[template public generateType(genPackage : GenPackage, type : Type)]
[let packagePathPrefix : String = genPackage.getQualifiedPackageName()]
[let pkg : Package = type._'package']
[for (rule : Constraint | type.ownedRule->select(stereotype = 'invariant'))]
[file (type.getFragmentURI() + '==' + rule.name, false, 'UTF-8')]
[let className : String = packagePathPrefix + '.operations.' + type.name + 'Operations']
[let constraintName : String = '_' + rule.stereotype + '_' + rule.name]
[let specification : OpaqueExpression = rule.specification.oclAsType(OpaqueExpression)]
/** 
 * [specification.toString()/]
 */
[let expressionInOcl : ExpressionInOcl = type.getExpressionInOcl(specification)]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
try {
	final [emitDomainEvaluationType('DomainEvaluator')/] evaluator = [emitType('org.eclipse.ocl.examples.library.ecore.EcoreExecutorManager')/].INSTANCE;
[let constants : String = genPackage.gatherSpecificationConstants(expressionInOcl)]
	[genPackage.emitConstants(constants)/][/let]
final [emitDomainElementsType('DomainType')/] returnType = [expressionInOcl.symbolName(expressionInOcl.type)/];
	final [emitDomainValuesType('Value')/] result = [emitType(className)/].[constraintName/].INSTANCE.evaluate(evaluator, returnType, self);
	final boolean resultIsNull = result.isNull();
	if (!resultIsNull && result.asBoolean()) {	// true => true, false/null => dropthrough, invalid => exception
		return true;
	}
	if (diagnostics != null) {
		int severity = resultIsNull ? [emitEmfCommonUtilType('Diagnostic')/].ERROR : [emitEmfCommonUtilType('Diagnostic')/].WARNING;
[if (expressionInOcl.messageExpression->notEmpty())]
		final [emitDomainValuesType('Value')/] messageValue = [emitType(className)/].[constraintName/].Message.INSTANCE.evaluate(evaluator, returnType, self);
		String message;
		if (messageValue != null) {
			message = messageValue.asString();
		}
		else {
			Object objectLabel;
			if (this instanceof [emitEcoreType('EDataType')/]) {
				objectLabel = [emitEcoreUtilType('EObjectValidator')/].getValueLabel(([emitEcoreType('EDataType')/]) this, result, context);
			}
			else if (result instanceof [emitEcoreType('EObject')/]) {
				objectLabel = [emitEcoreUtilType('EObjectValidator')/].getObjectLabel(([emitEcoreType('EObject')/]) result, context);
			}
			else {
				objectLabel = String.valueOf(result);
			}
			message = [emitType('org.eclipse.osgi.util.NLS')/].bind([emitDomainMessagesType('EvaluatorMessages')/].ValidationConstraintIsNotSatisfied_ERROR_, "[genPackage.getOperationID(type, rule, false)/]", objectLabel);
		}
	    diagnostics.add(new [emitEmfCommonUtilType('BasicDiagnostic')/](severity, [emitType(genPackage.getQualifiedValidatorClassName())/].DIAGNOSTIC_SOURCE, [emitType(genPackage.getQualifiedValidatorClassName())/].[genPackage.getOperationID(type, rule, true)/], message, new Object ['[]'/] { result }));
[else]
	    diagnostics.add(new [emitEmfCommonUtilType('BasicDiagnostic')/](severity, [emitType(genPackage.getQualifiedValidatorClassName())/].DIAGNOSTIC_SOURCE, [emitType(genPackage.getQualifiedValidatorClassName())/].[genPackage.getOperationID(type, rule, true)/], [emitDomainMessagesType('EvaluatorMessages')/].ValidationConstraintIsNotSatisfied_ERROR_, new Object ['[]'/] { result }));
[/if]
	}
	return false;
} catch ([emitDomainEvaluationType('InvalidValueException')/] e) {
	throw new [emitEmfCommonUtilType('WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/let][/let][/let][/file][/for][/let][/let][/template]

[template public generateOperation(genPackage : GenPackage, type : Type, operation : Operation)]
[let packagePathPrefix : String = genPackage.getQualifiedPackageName()]
[let rule : Constraint = operation.ownedRule->any(stereotype = 'body')]
[file (operation.getFragmentURI(), false, 'UTF-8')]
[let className : String = packagePathPrefix + '.operations.' + type.name + 'Operations']
[let constraintName : String = '_' + operation.name + '_' + rule.stereotype + '_' + rule.name]
/** 
 * [rule.specification.toString()/]
 */
[let returnCast : String = genPackage.getOperationReturnType(operation)]
[let specification : ValueSpecification = rule.specification]
[let pkg : Package = type._'package']
[generateOperation(genPackage, className, constraintName, operation, returnCast, specification, pkg)/][/let][/let][/let][/let][/let][/file][/let][/let][/template]

[template public generateOperation(genPackage : GenPackage, className : String, constraintName : String, operation : Operation, returnCast : String, specification : ValueSpecification, pkg : Package)]
throw new UnsupportedOperationException();
[/template]

[template public generateOperation(genPackage : GenPackage, className : String, constraintName : String, operation : Operation, returnCast : String, specification : OpaqueExpression, pkg : Package)]
[let expressionInOcl : ExpressionInOcl = operation.getExpressionInOcl(specification)]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
try {
	final [emitDomainEvaluationType('DomainEvaluator')/] evaluator = [emitType('org.eclipse.ocl.examples.library.ecore.EcoreExecutorManager')/].INSTANCE;
[let constants : String = genPackage.gatherSpecificationConstants(expressionInOcl)]
	[genPackage.emitConstants(constants)/][/let]
final [emitDomainElementsType('DomainType')/] returnType = [expressionInOcl.symbolName(expressionInOcl.type)/];
	final [emitDomainValuesType('Value')/] result = [emitType(className)/].[constraintName/].INSTANCE.evaluate(evaluator, returnType, self);
	return [returnCast/] valueFactory.getEcoreValueOf(result);
} catch ([emitDomainEvaluationType('InvalidValueException')/] e) {
	throw new [emitType('org.eclipse.emf.common.util.WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/template]

[template public generateProperty(genPackage : GenPackage, type : Type, property : Property)]
[let packagePathPrefix : String = genPackage.getQualifiedPackageName()]
[let derivationRules : OrderedSet(Constraint) = property.ownedRule->select(stereotype = 'derivation')]
[let initialRules : OrderedSet(Constraint) = property.ownedRule->select(stereotype = 'initial')]
[let rule : Constraint = if derivationRules->notEmpty() then derivationRules->any(true) else initialRules->any(true) endif]
[file (property.getFragmentURI(), false, 'UTF-8')]
[let className : String = packagePathPrefix + '.operations.' + type.name + 'Operations']
[let constraintName : String = '_' + property.name + '_' + rule.stereotype + '_' + rule.name]
/** 
 * [rule.specification.toString()/]
 */
[generateProperty(genPackage, className, constraintName, property, genPackage.getPropertyType(property), rule.specification, type._'package')/][/let][/let][/file][/let][/let][/let][/let][/template]

[template public generateProperty(genPackage : GenPackage, className : String, constraintName : String, property : Property, returnCast : String, specification : ValueSpecification, pkg : Package)]
throw new UnsupportedOperationException();
[/template]

[template public generateProperty(genPackage : GenPackage, className : String, constraintName : String, property : Property, returnCast : String, specification : OpaqueExpression, pkg : Package)]
[let expressionInOcl : ExpressionInOcl = property.getExpressionInOcl(specification)]
[let arity : Integer = expressionInOcl.parameterVariable->size()]
try {
	final [emitDomainEvaluationType('DomainEvaluator')/] evaluator = [emitType('org.eclipse.ocl.examples.library.ecore.EcoreExecutorManager')/].INSTANCE;
[let constants : String = genPackage.gatherSpecificationConstants(expressionInOcl)]
	[genPackage.emitConstants(constants)/][/let]
final [emitDomainElementsType('DomainType')/] returnType = [expressionInOcl.symbolName(expressionInOcl.type)/];
	final [emitDomainValuesType('Value')/] result = [emitType(className)/].[constraintName/].INSTANCE.evaluate(evaluator, returnType, self, [emitType(genPackage.getQualifiedPackageName() + '.' + genPackage.getTablesClassName())/].Properties._[property.owningType.name/]__[property.name/]);
	return [returnCast/] valueFactory.getEcoreValueOf(result);
} catch ([emitDomainEvaluationType('InvalidValueException')/] e) {
	throw new [emitType('org.eclipse.emf.common.util.WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/template]


[template public gatherSpecificationConstants(genPackage : GenPackage, expressionInOcl : ExpressionInOcl)]
final [emitDomainValuesType('ValueFactory')/] valueFactory = evaluator.getValueFactory();
final [emitDomainValuesType('Value')/] [defineSymbolName(expressionInOcl.contextVariable, 'self')/] = valueFactory.valueOf(this);
[genPackage.gatherConstant(expressionInOcl, expressionInOcl.type)/]
[/template]

