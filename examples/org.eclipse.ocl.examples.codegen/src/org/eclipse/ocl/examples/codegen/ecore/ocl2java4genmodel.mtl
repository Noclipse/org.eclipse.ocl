[**
 * <copyright>
 *
 * Copyright (c) 2011 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *
 * </copyright>
 *
 * $Id$
 **/]
[comment encoding = UTF-8 /]
[module org::eclipse::ocl::examples::codegen::ecore::ocl2java4genmodel('http://www.eclipse.org/ocl/3.1.0/Pivot','http://www.eclipse.org/emf/2002/GenModel')/]

[import org::eclipse::ocl::examples::codegen::common::constantTemplates/]
[import org::eclipse::ocl::examples::codegen::common::elementQueries/]
[import org::eclipse::ocl::examples::codegen::common::emitQueries/]
[import org::eclipse::ocl::examples::codegen::common::expressionTemplates/]
[import org::eclipse::ocl::examples::codegen::common::genPackageQueries/]
[import org::eclipse::ocl::examples::codegen::common::nameQueries/]
[import org::eclipse::ocl::examples::codegen::common::pivotQueries/]
[import org::eclipse::ocl::examples::codegen::common::symbolTemplates/]

[template public generateModel(genModel : GenModel)]
[comment @main /]
[for (genPackage : GenPackage | genModel.genPackages)]
[let pPackage : Package = genPackage.getPivotPackage()]
[pPackage.generatePackage(genPackage)/]
[/let]
[/for]
[/template]

[template public generatePackage(pPackage : Package, genPackage : GenPackage)]
[let packagePathPrefix : String = if genPackage.basePackage->notEmpty() then genPackage.basePackage.replaceAll('\\.', '/') + '/' else '' endif]
[let packagePrefix : String = packagePathPrefix.replaceAll('/', '.')]
[for (pType : Type | pPackage.ownedType)]
[pType.generateType(genPackage)/]
[for (pOperation : Operation | pType.ownedOperation)]
[pType.generateOperation(genPackage, pOperation)/]
[/for]
[for (pProperty : Property | pType.ownedAttribute)]
[pType.generateProperty(genPackage, pProperty)/]
[/for]
[/for]
[/let]
[/let]
[/template]

[template public generateType(pType : Type, genPackage : GenPackage)]
[let pkg : Package = pType._'package']
[for (rule : Constraint | pType.ownedRule->select(stereotype = 'invariant'))]
[file (pType.getFragmentURI() + '==' + rule.name, false, 'UTF-8')]
[let className : String = pType.getQualifiedBodiesClassName(genPackage)]
[let constraintName : String = '_' + rule.stereotype + '_' + rule.name]
[let expInOcl : ExpressionInOcl = rule.specification.getExpressionInOcl(pType)]
[let constants : String = expInOcl.gatherSpecificationConstants(genPackage, pType)]
/*
[expInOcl.prettyPrint().trim()/]
*/
[let arity : Integer = expInOcl.parameterVariable->size()]
try {
	final [emitDomainEvaluationType('DomainEvaluator')/] evaluator = new [emitLibraryEcoreType('EcoreExecutorManager')/](this, [emitType(pType.getQualifiedTablesClassName(genPackage))/].LIBRARY);
	[expInOcl.emitConstants(constants)/]
	final [emitDomainElementsType('DomainType')/] returnType = [expInOcl.type.symbolName(expInOcl)/];
	final [emitDomainValuesType('Value')/] result = [emitType(className)/].[constraintName/].INSTANCE.evaluate(evaluator, returnType, self);
	final boolean resultIsNull = result.isNull();
	if (!resultIsNull && result.asBoolean()) {	// true => true, false/null => dropthrough, invalid => exception
		return true;
	}
	if (diagnostics != null) {
		int severity = resultIsNull ? [emitEmfCommonUtilType('Diagnostic')/].ERROR : [emitEmfCommonUtilType('Diagnostic')/].WARNING;
[if (expInOcl.messageExpression->notEmpty())]
		final [emitDomainValuesType('Value')/] messageValue = [emitType(className)/].[constraintName/].Message.INSTANCE.evaluate(evaluator, returnType, self);
		String message;
		if (messageValue != null) {
			message = messageValue.asString();
		}
		else {
			Object objectLabel;
			if (this instanceof [emitEcoreType('EDataType')/]) {
				objectLabel = [emitEcoreUtilType('EObjectValidator')/].getValueLabel(([emitEcoreType('EDataType')/]) this, result, context);
			}
			else if (result instanceof [emitEcoreType('EObject')/]) {
				objectLabel = [emitEcoreUtilType('EObjectValidator')/].getObjectLabel(([emitEcoreType('EObject')/]) result, context);
			}
			else {
				objectLabel = String.valueOf(result);
			}
			message = [emitType('org.eclipse.osgi.util.NLS')/].bind([emitDomainMessagesType('EvaluatorMessages')/].ValidationConstraintIsNotSatisfied_ERROR_, "[genPackage.getOperationID(pType, rule, false)/]", objectLabel);
		}
	    diagnostics.add(new [emitEmfCommonUtilType('BasicDiagnostic')/](severity, [emitType(genPackage.getQualifiedValidatorClassName())/].DIAGNOSTIC_SOURCE, [emitType(genPackage.getQualifiedValidatorClassName())/].[genPackage.getOperationID(pType, rule, true)/], message, new Object ['[]'/] { result }));
[else]
		String message = [emitType('org.eclipse.osgi.util.NLS')/].bind([emitDomainMessagesType('EvaluatorMessages')/].ValidationConstraintIsNotSatisfied_ERROR_, "[rule.name/]", [emitType('org.eclipse.emf.ecore.util.EObjectValidator')/].getObjectLabel(this, context));
	    diagnostics.add(new [emitEmfCommonUtilType('BasicDiagnostic')/](severity, [emitType(genPackage.getQualifiedValidatorClassName())/].DIAGNOSTIC_SOURCE, [emitType(genPackage.getQualifiedValidatorClassName())/].[genPackage.getOperationID(pType, rule, true)/], message, new Object ['[]'/] { this }));
[/if]
	}
	return false;
} catch ([emitDomainEvaluationType('InvalidValueException')/] e) {
	throw new [emitEmfCommonUtilType('WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/let][/let][/let][/file][/for][/let][/template]

[template public generateOperation(pType : Type, genPackage : GenPackage, pOperation : Operation)]
[let rule : Constraint = pOperation.ownedRule->any(stereotype = 'body')]
[file (pOperation.getFragmentURI(), false, 'UTF-8')]
[let className : String = pType.getQualifiedBodiesClassName(genPackage)]
[let constraintName : String = '_' + pOperation.name + '_' + rule.stereotype + '_' + rule.name]
[let expInOcl : ExpressionInOcl = rule.specification.getExpressionInOcl(pOperation)]
[let constants : String = expInOcl.gatherSpecificationConstants(genPackage, pType)]
[let ecoreReturnType : String = genPackage.getOperationReturnType(pOperation)]
/*
[expInOcl.prettyPrint().trim()/]
*/
try {
	final [pType.emitDomainEvaluationType('DomainEvaluator')/] evaluator = new [emitLibraryEcoreType('EcoreExecutorManager')/](this, [emitType(pType.getQualifiedTablesClassName(genPackage))/].LIBRARY);
	[expInOcl.emitConstants(constants)/]
	final [pType.emitDomainElementsType('DomainType')/] returnType = [expInOcl.type.symbolName(expInOcl)/];
	final [pType.emitDomainValuesType('Value')/] result = [pType.emitType(className)/].[constraintName/].INSTANCE.evaluate(evaluator, returnType, self[for (pParameter : Parameter | pOperation.ownedParameter)], valueFactory.valueOf([pParameter.name/])[/for]);
[if (ecoreReturnType.index('<') > 0)]
	@SuppressWarnings("unchecked")
	[ecoreReturnType/] ecoreResult = ([ecoreReturnType/]) valueFactory.getEcoreValueOf(result);
	return ecoreResult;
[else]
	return ([ecoreReturnType/]) valueFactory.getEcoreValueOf(result);
[/if]
} catch ([pType.emitDomainEvaluationType('InvalidValueException')/] e) {
	throw new [pType.emitType('org.eclipse.emf.common.util.WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/let][/let][/let][/file][/let][/template]

[template public generateProperty(pType : Type, genPackage : GenPackage, pProperty : Property)]
[let derivationRules : OrderedSet(Constraint) = pProperty.ownedRule->select(stereotype = 'derivation')]
[let initialRules : OrderedSet(Constraint) = pProperty.ownedRule->select(stereotype = 'initial')]
[let rule : Constraint = if derivationRules->notEmpty() then derivationRules->any(true) else initialRules->any(true) endif]
[file (pProperty.getFragmentURI(), false, 'UTF-8')]
[let className : String = pType.getQualifiedBodiesClassName(genPackage)]
[let constraintName : String = '_' + pProperty.name + '_' + rule.stereotype + '_' + rule.name]
[let expInOcl : ExpressionInOcl = rule.specification.getExpressionInOcl(pProperty)]
[let constants : String = expInOcl.gatherSpecificationConstants(genPackage, pType)]
[let ecoreReturnType : String = genPackage.getPropertyType(pProperty)]
/*
[expInOcl.prettyPrint().trim()/]
*/
try {
	final [pType.emitDomainEvaluationType('DomainEvaluator')/] evaluator = new [emitLibraryEcoreType('EcoreExecutorManager')/](this, [emitType(pType.getQualifiedTablesClassName(genPackage))/].LIBRARY);
	[expInOcl.emitConstants(constants)/]
	final [pType.emitDomainElementsType('DomainType')/] returnType = [expInOcl.type.symbolName(expInOcl)/];
	final [pType.emitDomainValuesType('Value')/] result = [pType.emitType(className)/].[constraintName/].INSTANCE.evaluate(evaluator, returnType, self, [pType.emitType(genPackage.getQualifiedPackageName() + '.' + genPackage.getTablesClassName())/].Properties._[pProperty.owningType.name/]__[pProperty.name/]);
[if (ecoreReturnType.index('<') > 0)]
	@SuppressWarnings("unchecked")
	[ecoreReturnType/] ecoreResult = ([ecoreReturnType/]) valueFactory.getEcoreValueOf(result);
	return ecoreResult;
[else]
	return ([ecoreReturnType/]) valueFactory.getEcoreValueOf(result);
[/if]
} catch ([pType.emitDomainEvaluationType('InvalidValueException')/] e) {
	throw new [pType.emitType('org.eclipse.emf.common.util.WrappedException')/]("Failed to evaluate [className/]", e);
}[/let][/let][/let][/let][/let][/file][/let][/let][/let][/template]


[template public gatherSpecificationConstants(expInOcl : ExpressionInOcl, genPackage : GenPackage, pType : Type)]
final [pType.emitDomainValuesType('ValueFactory')/] valueFactory = evaluator.getValueFactory();
final [pType.emitDomainValuesType('Value')/] [defineSymbolName(expInOcl.contextVariable, 'self')/] = valueFactory.valueOf(this);
[expInOcl.type.gatherConstants(expInOcl, genPackage, expInOcl)/]
[/template]

