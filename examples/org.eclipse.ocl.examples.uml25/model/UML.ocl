import uml : 'platform:/resource/org.eclipse.ocl.examples.uml25/model/UML.xmi#_0'
import classification : 'platform:/resource/org.eclipse.ocl.examples.uml25/model/UML.xmi#Classification'
import commonStructure : 'platform:/resource/org.eclipse.ocl.examples.uml25/model/UML.xmi#CommonStructure'
import interactions : 'platform:/resource/org.eclipse.ocl.examples.uml25/model/UML.xmi#Interactions'
import simpleClassifiers : 'platform:/resource/org.eclipse.ocl.examples.uml25/model/UML.xmi#SimpleClassifiers'

package uml::Activities

	context uml::Activities::Activity

	inv maximum_one_parameter_node:
		ownedParameter->forAll(p | p.direction <> UML::Classification::ParameterDirectionKind::inout implies
		  node->select(
		    (
		      oclIsKindOf(uml::Activities::ActivityParameterNode) and
		      oclAsType(uml::Activities::ActivityParameterNode).parameter = p
		    ))
		  ->size() = 1)

	inv maximum_two_parameter_nodes:
		ownedParameter->forAll(p | p.direction = UML::Classification::ParameterDirectionKind::inout implies
		  let
		    associatedNodes : Set(UML::Activities::ActivityNode) = node->select(
		      oclIsKindOf(uml::Activities::ActivityParameterNode) and
		      oclAsType(uml::Activities::ActivityParameterNode).parameter = p)
		  in
		    associatedNodes->size() = 2 and
		    associatedNodes->select(incoming->notEmpty())
		    ->size() <= 1 and
		    associatedNodes->select(outgoing->notEmpty())
		    ->size() <= 1)

	context uml::Activities::ActivityEdge

	inv source_and_target:
		activity <> null implies
		source.containingActivity() = activity and
		target.containingActivity() = activity

	context uml::Activities::ActivityGroup

	inv nodes_and_edges:
		containedNode->forAll(activity = self.containingActivity()) and
		containedEdge->forAll(activity = self.containingActivity())

	inv not_contained:
		subgroup->closure(subgroup)
		.containedNode->excludesAll(containedNode) and
		superGroup->closure(superGroup)
		.containedNode->excludesAll(containedNode) and
		subgroup->closure(subgroup)
		.containedEdge->excludesAll(containedEdge) and
		superGroup->closure(superGroup)
		.containedEdge->excludesAll(containedEdge)

	context uml::Activities::ActivityParameterNode

	inv no_outgoing_edges:
		incoming->notEmpty() and
		outgoing->isEmpty() implies parameter.direction = UML::Classification::ParameterDirectionKind::out or parameter.direction = UML::Classification::ParameterDirectionKind::inout or parameter.direction = UML::Classification::ParameterDirectionKind::return

	inv has_parameters:
		activity.ownedParameter->includes(parameter)

	inv same_type:
		type = parameter.type

	inv no_incoming_edges:
		outgoing->notEmpty() and
		incoming->isEmpty() implies parameter.direction = UML::Classification::ParameterDirectionKind::_'in' or parameter.direction = UML::Classification::ParameterDirectionKind::inout

	inv no_edges:
		incoming->isEmpty() or outgoing->isEmpty()

	context uml::Activities::ActivityPartition

	inv represents_classifier:
		not isExternal and
		represents.oclIsKindOf(uml::Classification::Classifier) and
		superPartition->notEmpty() implies
		let
		  representedClassifier : uml::Classification::Classifier = represents.oclAsType(uml::Classification::Classifier)
		in
		  superPartition.represents.oclIsKindOf(uml::Classification::Classifier) and
		  let
		    representedSuperClassifier : uml::Classification::Classifier = superPartition.represents.oclAsType(uml::Classification::Classifier)
		  in
		    (
		      representedSuperClassifier.oclIsKindOf(uml::SimpleClassifiers::BehavioredClassifier) and
		      representedClassifier.oclIsKindOf(uml::CommonBehavior::Behavior) and
		      representedSuperClassifier.oclAsType(uml::SimpleClassifiers::BehavioredClassifier)
		      .ownedBehavior->includes(
		        representedClassifier.oclAsType(uml::CommonBehavior::Behavior)) or
		      representedSuperClassifier.oclIsKindOf(uml::StructuredClassifiers::Class) and
		      representedSuperClassifier.oclAsType(uml::StructuredClassifiers::Class)
		      .nestedClassifier->includes(representedClassifier) or
		      uml::StructuredClassifiers::Association.allInstances()
		      ->exists(a |
		        a.memberEnd->exists(end1 | end1.isComposite and end1.type = representedClassifier and
		          a.memberEnd->exists(end2 | end1 <> end2 and end2.type = representedSuperClassifier)))
		    )

	inv represents_property_and_is_contained:
		represents.oclIsKindOf(uml::Classification::Property) and
		superPartition->notEmpty() implies
		superPartition.represents.oclIsKindOf(uml::Classification::Classifier) and represents.owner = superPartition.represents or
		superPartition.represents.oclIsKindOf(uml::Classification::Property) and represents.owner =
		superPartition.represents.oclAsType(uml::Classification::Property).type

	inv represents_property:
		represents.oclIsKindOf(uml::Classification::Property) and
		superPartition->notEmpty() and
		superPartition.represents.oclIsKindOf(uml::Classification::Classifier) implies
		let
		  representedClassifier : uml::Classification::Classifier = superPartition.represents.oclAsType(uml::Classification::Classifier)
		in
		  superPartition.subpartition->reject(isExternal)
		  ->forAll(p |
		    p.represents.oclIsKindOf(uml::Classification::Property) and p.owner = representedClassifier)

	inv dimension_not_contained:
		isDimension implies superPartition->isEmpty()

	context uml::Activities::ControlFlow

	inv object_nodes:
		(
		  source.oclIsKindOf(uml::Activities::ObjectNode) implies
		  source.oclAsType(uml::Activities::ObjectNode).isControlType
		) and
		(
		  target.oclIsKindOf(uml::Activities::ObjectNode) implies
		  target.oclAsType(uml::Activities::ObjectNode).isControlType
		)

	context uml::Activities::DecisionNode

	inv zero_input_parameters:
		decisionInput <> null and decisionInputFlow = null and
		incoming->exists(
		  oclIsKindOf(uml::Activities::ControlFlow)) implies
		decisionInput.inputParameters()
		->isEmpty()

	inv edges:
		let
		  allEdges : Set(UML::Activities::ActivityEdge) = incoming->union(outgoing)
		in
		  let
		    allRelevantEdges : Set(UML::Activities::ActivityEdge) = if
		      decisionInputFlow->notEmpty()
		    then allEdges->excluding(decisionInputFlow)
		    else allEdges
		    endif
		  in
		    allRelevantEdges->forAll(
		      oclIsKindOf(uml::Activities::ControlFlow)) or
		    allRelevantEdges->forAll(
		      oclIsKindOf(uml::Activities::ObjectFlow))

	inv decision_input_flow_incoming:
		incoming->includes(decisionInputFlow)

	inv two_input_parameters:
		decisionInput <> null and decisionInputFlow <> null and
		incoming->forAll(
		  oclIsKindOf(uml::Activities::ObjectFlow)) implies
		decisionInput.inputParameters()
		->size() = 2

	inv incoming_outgoing_edges:
		(incoming->size() = 1 or incoming->size() = 2
		) and
		outgoing->size() > 0

	inv incoming_control_one_input_parameter:
		decisionInput <> null and decisionInputFlow <> null and
		incoming->exists(
		  oclIsKindOf(uml::Activities::ControlFlow)) implies
		decisionInput.inputParameters()
		->size() = 1

	inv parameters:
		decisionInput <> null implies
		decisionInput.ownedParameter->forAll(par | par.direction <> UML::Classification::ParameterDirectionKind::out and par.direction <> UML::Classification::ParameterDirectionKind::inout) and
		decisionInput.ownedParameter->one(par | par.direction <> UML::Classification::ParameterDirectionKind::return)

	inv incoming_object_one_input_parameter:
		decisionInput <> null and decisionInputFlow = null and
		incoming->forAll(
		  oclIsKindOf(uml::Activities::ObjectFlow)) implies
		decisionInput.inputParameters()
		->size() = 1

	context uml::Activities::ExceptionHandler

	inv handler_body_edges:
		handlerBody.incoming->isEmpty() and
		handlerBody.outgoing->isEmpty() and
		exceptionInput.incoming->isEmpty()

	inv output_pins:
		protectedNode.oclIsKindOf(uml::Actions::Action) and
		protectedNode.oclAsType(uml::Actions::Action)
		.output->notEmpty() implies
		handlerBody.oclIsKindOf(uml::Actions::Action) and
		let
		  protectedNodeOutput : OrderedSet(UML::Actions::OutputPin) = protectedNode.oclAsType(uml::Actions::Action).output
		in
		  let
		    handlerBodyOutput : OrderedSet(UML::Actions::OutputPin) = handlerBody.oclAsType(uml::Actions::Action).output
		  in
		    protectedNodeOutput->size() =
		    handlerBodyOutput->size() and
		    Sequence{1..protectedNodeOutput->size()
		    }
		    ->forAll(i |
		      handlerBodyOutput->at(i)
		      .type.conformsTo(protectedNodeOutput->at(i).type) and
		      handlerBodyOutput->at(i).isOrdered =
		      protectedNodeOutput->at(i).isOrdered and
		      handlerBodyOutput->at(i)
		      .compatibleWith(protectedNodeOutput->at(i)))

	inv one_input:
		handlerBody.oclIsKindOf(uml::Actions::Action) and
		let
		  inputs : OrderedSet(UML::Actions::InputPin) = handlerBody.oclAsType(uml::Actions::Action).input
		in inputs->size() = 1 and inputs->first() = exceptionInput

	inv edge_source_target:
		let
		  nodes : Set(UML::Activities::ActivityNode) = handlerBody.oclAsType(uml::Actions::Action)
		  .allOwnedNodes()
		in
		  nodes.outgoing->forAll(nodes->includes(target)) and
		  nodes.incoming->forAll(nodes->includes(source))

	inv handler_body_owner:
		handlerBody.owner = protectedNode.owner

	inv exception_input_type:
		exceptionInput.type = null or
		exceptionType->forAll(
		  conformsTo(
		    exceptionInput.type.oclAsType(uml::Classification::Classifier)))

	context uml::Activities::FinalNode

	inv no_outgoing_edges:
		outgoing->isEmpty()

	context uml::Activities::ForkNode

	inv edges:
		let
		  allEdges : Set(UML::Activities::ActivityEdge) = incoming->union(outgoing)
		in
		  allEdges->forAll(
		    oclIsKindOf(uml::Activities::ControlFlow)) or
		  allEdges->forAll(
		    oclIsKindOf(uml::Activities::ObjectFlow))

	inv one_incoming_edge:
		incoming->size() = 1

	context uml::Activities::InitialNode

	inv no_incoming_edges:
		incoming->isEmpty()

	inv control_edges:
		outgoing->forAll(
		  oclIsKindOf(uml::Activities::ControlFlow))

	context uml::Activities::InterruptibleActivityRegion

	inv interrupting_edges:
		interruptingEdge->forAll(edge |
		  node->includes(edge.source) and
		  node->excludes(edge.target) and
		  edge.target.containingActivity() = inActivity)

	context uml::Activities::JoinNode

	inv one_outgoing_edge:
		outgoing->size() = 1

	inv incoming_object_flow:
		if
		  incoming->exists(
		    oclIsKindOf(uml::Activities::ObjectFlow))
		then
		  outgoing->forAll(
		    oclIsKindOf(uml::Activities::ObjectFlow))
		else
		  outgoing->forAll(
		    oclIsKindOf(uml::Activities::ControlFlow))
		endif

	context uml::Activities::MergeNode

	inv one_outgoing_edge:
		outgoing->size() = 1

	inv edges:
		let
		  allEdges : Set(UML::Activities::ActivityEdge) = incoming->union(outgoing)
		in
		  allEdges->forAll(
		    oclIsKindOf(uml::Activities::ControlFlow)) or
		  allEdges->forAll(
		    oclIsKindOf(uml::Activities::ObjectFlow))

	context uml::Activities::ObjectFlow

	inv input_and_output_parameter:
		selection <> null implies
		selection.inputParameters()
		->size() = 1 and
		selection.inputParameters()
		->forAll(not isUnique and is(0, *)) and
		selection.outputParameters()
		->size() = 1

	inv no_executable_nodes:
		not (
		  source.oclIsKindOf(uml::Activities::ExecutableNode) or
		  target.oclIsKindOf(uml::Activities::ExecutableNode)
		)

	inv transformation_behavior:
		transformation <> null implies
		transformation.inputParameters()
		->size() = 1 and
		transformation.outputParameters()
		->size() = 1

	inv selection_behavior:
		selection <> null implies
		source.oclIsKindOf(uml::Activities::ObjectNode)

	inv compatible_types:
		null

	inv same_upper_bounds:
		null

	inv target:
		null

	inv is_multicast_or_is_multireceive:
		not (isMulticast and isMultireceive)

	context uml::Activities::ObjectNode

	inv input_output_parameter:
		selection <> null implies
		selection.inputParameters()
		->size() = 1 and
		selection.inputParameters()
		->forAll(p | not p.isUnique and
		  p.is(0, *) and
		  self.type.conformsTo(p.type)) and
		selection.outputParameters()
		->size() = 1 and
		selection.inputParameters()
		->forAll(p | self.type.conformsTo(p.type))

	inv selection_behavior:
		selection <> null = ordering = UML::Activities::ObjectNodeOrderingKind::ordered

	inv object_flow_edges:
		not isControlType implies
		incoming->union(outgoing)
		->forAll(oclIsKindOf(uml::Activities::ObjectFlow))

endpackage

package uml::Values

	context uml::Values::Duration

	inv no_expr_requires_observation:
		expr = null implies
		observation->size() = 1 and
		observation->forAll(
		  oclIsKindOf(uml::Values::DurationObservation))

	context uml::Values::DurationConstraint

	inv first_event_multiplicity:
		if constrainedElement->size() = 2
		then firstEvent->size() = 2
		else firstEvent->size() = 0
		endif

	inv has_one_or_two_constrainedElements:
		constrainedElement->size() = 1 or constrainedElement->size() = 2

	context uml::Values::DurationObservation

	inv first_event_multiplicity:
		if event->size() = 2
		then firstEvent->size() = 2
		else firstEvent->size() = 0
		endif

	context uml::Values::OpaqueExpression

	inv language_body_size:
		language->notEmpty() implies _'body'->size() = language->size()

	inv one_return_result_parameter:
		behavior <> null implies
		behavior.ownedParameter->select(direction = UML::Classification::ParameterDirectionKind::return)
		->size() = 1

	inv only_return_result_parameters:
		behavior <> null implies
		behavior.ownedParameter->select(direction <> UML::Classification::ParameterDirectionKind::return)
		->isEmpty()

	context OpaqueExpression::isNonNegative() : Boolean

	pre _'pre':
		self.isIntegral()

	context OpaqueExpression::isPositive() : Boolean

	pre _'pre':
		self.isIntegral()

	context OpaqueExpression::value() : Integer

	pre _'pre':
		self.isIntegral()

	context uml::Values::StringExpression

	inv operands:
		operand->forAll(
		  oclIsKindOf(uml::Values::LiteralString))

	inv subexpressions:
		if subExpression->notEmpty()
		then operand->isEmpty()
		else operand->notEmpty()
		endif

	context uml::Values::TimeConstraint

	inv has_one_constrainedElement:
		constrainedElement->size() = 1

	context uml::Values::TimeExpression

	inv no_expr_requires_observation:
		expr = null implies
		observation->size() = 1 and
		observation->forAll(
		  oclIsKindOf(uml::Values::TimeObservation))

endpackage

package uml::UseCases

	context uml::UseCases::Actor

	inv associations:
		uml::StructuredClassifiers::Association.allInstances()
		->forAll(a |
		  a.memberEnd->collect(type)
		  ->includes(self) implies
		  a.memberEnd->size() = 2 and
		  let
		    actorEnd : uml::Classification::Property = a.memberEnd->any(type = self)
		  in
		    (
		      actorEnd.opposite.class.oclIsKindOf(uml::UseCases::UseCase) or
		      actorEnd.opposite.class.oclIsKindOf(uml::StructuredClassifiers::Class) and
		      not actorEnd.opposite.class.oclIsKindOf(uml::CommonBehavior::Behavior)
		    ))

	inv must_have_name:
		name->notEmpty()

	context uml::UseCases::Extend

	inv extension_points:
		extensionLocation->forAll(xp | extendedCase.extensionPoint->includes(xp))

	context uml::UseCases::ExtensionPoint

	inv must_have_name:
		name->notEmpty()

	context uml::UseCases::UseCase

	inv binary_associations:
		uml::StructuredClassifiers::Association.allInstances()
		->forAll(a |
		  a.memberEnd.type->includes(self) implies
		  a.memberEnd->size() = 2)

	inv no_association_to_use_case:
		uml::StructuredClassifiers::Association.allInstances()
		->forAll(a |
		  a.memberEnd.type->includes(self) implies
		  let
		    usecases : Set(UML::UseCases::UseCase) = a.memberEnd.type->select(
		      oclIsKindOf(uml::UseCases::UseCase))
		    ->collect(oclAsType(uml::UseCases::UseCase))
		    ->asSet()
		  in
		    usecases->size() > 1 implies
		    usecases->collect(subject)
		    ->size() > 1)

	inv cannot_include_self:
		not allIncludedUseCases()->includes(self)

	inv must_have_name:
		name->notEmpty()

endpackage

package uml::StructuredClassifiers

	context uml::StructuredClassifiers::Association

	inv specialized_end_number:
		parents()
		->select(
		  oclIsKindOf(uml::StructuredClassifiers::Association))
		.oclAsType(uml::StructuredClassifiers::Association)
		->forAll(p | p.memberEnd->size() = self.memberEnd->size())

	inv specialized_end_types:
		Sequence{1..memberEnd->size()
		}
		->forAll(i |
		  general->select(
		    oclIsKindOf(uml::StructuredClassifiers::Association))
		  .oclAsType(uml::StructuredClassifiers::Association)
		  ->forAll(ga |
		    self.memberEnd->at(i)
		    .type.conformsTo(ga.memberEnd->at(i).type)))

	inv binary_associations:
		memberEnd->exists(aggregation <> UML::Classification::AggregationKind::none) implies
		memberEnd->size() = 2 and
		memberEnd->exists(aggregation = UML::Classification::AggregationKind::none)

	inv association_ends:
		memberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd)

	inv ends_must_be_typed:
		memberEnd->forAll(type->notEmpty())

	context uml::StructuredClassifiers::AssociationClass

	inv cannot_be_defined:
		self.endType()
		->excludes(self) and
		self.endType()
		->collect(et |
		  et.oclAsType(uml::Classification::Classifier)
		  .allParents())
		->flatten()
		->excludes(self)

	inv disjoint_attributes_ends:
		ownedAttribute->intersection(ownedEnd)->isEmpty()

	context uml::StructuredClassifiers::Class

	inv passive_class:
		not isActive implies ownedReception->isEmpty() and classifierBehavior = null

	context uml::StructuredClassifiers::CollaborationUse

	inv client_elements:
		roleBinding->collect(client)
		->forAll(ne1, ne2 |
		  ne1.oclIsKindOf(uml::StructuredClassifiers::ConnectableElement) and
		  ne2.oclIsKindOf(uml::StructuredClassifiers::ConnectableElement) and
		  let
		    ce1 : uml::StructuredClassifiers::ConnectableElement = ne1.oclAsType(uml::StructuredClassifiers::ConnectableElement)
		  in
		    let
		      ce2 : uml::StructuredClassifiers::ConnectableElement = ne2.oclAsType(uml::StructuredClassifiers::ConnectableElement)
		    in ce1.structuredClassifier = ce2.structuredClassifier) and
		roleBinding->collect(supplier)
		->forAll(ne1, ne2 |
		  ne1.oclIsKindOf(uml::StructuredClassifiers::ConnectableElement) and
		  ne2.oclIsKindOf(uml::StructuredClassifiers::ConnectableElement) and
		  let
		    ce1 : uml::StructuredClassifiers::ConnectableElement = ne1.oclAsType(uml::StructuredClassifiers::ConnectableElement)
		  in
		    let
		      ce2 : uml::StructuredClassifiers::ConnectableElement = ne2.oclAsType(uml::StructuredClassifiers::ConnectableElement)
		    in ce1.collaboration = ce2.collaboration)

	inv every_role:
		type.collaborationRole->forAll(role |
		  roleBinding->exists(rb | rb.supplier->includes(role)))

	inv connectors:
		type.ownedConnector->forAll(connector |
		  let
		    rolesConnectedInCollab : Set(UML::StructuredClassifiers::ConnectableElement) = connector.end.role->asSet()
		  in
		    let
		      relevantBindings : Set(UML::CommonStructure::Dependency) = roleBinding->select(rb |
		        rb.supplier->intersection(rolesConnectedInCollab)
		        ->notEmpty())
		    in
		      let
		        boundRoles : Set(UML::StructuredClassifiers::ConnectableElement) = relevantBindings->collect(
		          client.oclAsType(uml::StructuredClassifiers::ConnectableElement))
		        ->asSet()
		      in
		        let
		          contextClassifier : uml::StructuredClassifiers::StructuredClassifier = boundRoles->any(true)
		          .structuredClassifier->any(true)
		        in
		          contextClassifier.ownedConnector->exists(correspondingConnector |
		            correspondingConnector.end.role->forAll(role |
		              boundRoles->includes(role)) and
		            connector.type->notEmpty() and
		            correspondingConnector.type->notEmpty() implies
		            connector.type->forAll(
		              conformsTo(correspondingConnector.type))))

	context uml::StructuredClassifiers::Component

	inv no_nested_classifiers:
		nestedClassifier->isEmpty()

	inv no_packaged_elements:
		nestingClass <> null implies packagedElement->isEmpty()

	context uml::StructuredClassifiers::Connector

	inv types:
		type <> null implies
		let noOfEnds : Integer = end->size()
		in
		  type.memberEnd->size() = noOfEnds and
		  Sequence{1..noOfEnds
		  }
		  ->forAll(i |
		    end->at(i)
		    .role.type.conformsTo(type.memberEnd->at(i).type))

	inv roles:
		structuredClassifier <> null and
		end->forAll(e |
		  (
		    structuredClassifier.allRoles()
		    ->includes(e.role) or
		    e.role.oclIsKindOf(uml::StructuredClassifiers::Port) and
		    structuredClassifier.allRoles()
		    ->includes(e.partWithPort)
		  ))

	context uml::StructuredClassifiers::ConnectorEnd

	inv role_and_part_with_port:
		partWithPort->notEmpty() implies
		role.oclIsKindOf(uml::StructuredClassifiers::Port) and
		partWithPort.type.oclAsType(uml::CommonStructure::Namespace)
		.member->includes(role)

	inv part_with_port_empty:
		role.oclIsKindOf(uml::StructuredClassifiers::Port) and role.owner = connector.owner implies
		partWithPort->isEmpty()

	inv multiplicity:
		self.compatibleWith(definingEnd)

	inv self_part_with_port:
		partWithPort->notEmpty() implies
		not partWithPort.oclIsKindOf(uml::StructuredClassifiers::Port)

	context uml::StructuredClassifiers::Port

	inv port_aggregation:
		aggregation = UML::Classification::AggregationKind::composite

	inv default_value:
		type.oclIsKindOf(uml::SimpleClassifiers::Interface) implies
		defaultValue->isEmpty()

	inv encapsulated_owner:
		owner = encapsulatedClassifier

endpackage

package uml::StateMachines

	context uml::StateMachines::ConnectionPointReference

	inv exit_pseudostates:
		exit->forAll(kind = UML::StateMachines::PseudostateKind::exitPoint)

	inv entry_pseudostates:
		entry->forAll(kind = UML::StateMachines::PseudostateKind::entryPoint)

	context uml::StateMachines::FinalState

	inv no_exit_behavior:
		exit->isEmpty()

	inv no_outgoing_transitions:
		outgoing->size() = 0

	inv no_regions:
		region->size() = 0

	inv cannot_reference_submachine:
		submachine->isEmpty()

	inv no_entry_behavior:
		entry->isEmpty()

	inv no_state_behavior:
		doActivity->isEmpty()

	context uml::StateMachines::ProtocolStateMachine

	inv classifier_context:
		_'context' <> null and specification = null

	inv deep_or_shallow_history:
		region->forAll(r |
		  r.subvertex->forAll(v |
		    v.oclIsKindOf(uml::StateMachines::Pseudostate) implies
		    v.oclAsType(uml::StateMachines::Pseudostate).kind <> UML::StateMachines::PseudostateKind::deepHistory and
		    v.oclAsType(uml::StateMachines::Pseudostate).kind <> UML::StateMachines::PseudostateKind::shallowHistory))

	inv entry_exit_do:
		region->forAll(r |
		  r.subvertex->forAll(v |
		    v.oclIsKindOf(uml::StateMachines::State) implies
		    v.oclAsType(uml::StateMachines::State)
		    .entry->isEmpty() and
		    v.oclAsType(uml::StateMachines::State)
		    .exit->isEmpty() and
		    v.oclAsType(uml::StateMachines::State)
		    .doActivity->isEmpty()))

	inv protocol_transitions:
		region->forAll(r |
		  r.transition->forAll(t |
		    t.oclIsTypeOf(uml::StateMachines::ProtocolTransition)))

	context uml::StateMachines::ProtocolTransition

	inv refers_to_operation:
		if referred()->notEmpty() and containingStateMachine()._'context'->notEmpty()
		then
		  containingStateMachine()
		  ._'context'.oclAsType(uml::SimpleClassifiers::BehavioredClassifier)
		  .allFeatures()
		  ->includesAll(referred())
		else true
		endif

	inv associated_actions:
		effect = null

	inv belongs_to_psm:
		container.belongsToPSM()

	context uml::StateMachines::Pseudostate

	inv transitions_outgoing:
		kind = UML::StateMachines::PseudostateKind::fork implies
		outgoing->forAll(t1, t2 |
		  let
		    contState : uml::StateMachines::State = containingStateMachine()
		    .LCAState(t1.target, t2.target)
		  in contState <> null and
		    contState.region->exists(r1, r2 | r1 <> r2 and
		      t1.target.isContainedInRegion(r1) and
		      t2.target.isContainedInRegion(r2)))

	inv choice_vertex:
		kind = UML::StateMachines::PseudostateKind::choice implies
		incoming->size() >= 1 and
		outgoing->size() >= 1

	inv outgoing_from_initial:
		kind = UML::StateMachines::PseudostateKind::initial implies outgoing.guard = null and
		outgoing.trigger->isEmpty()

	inv join_vertex:
		kind = UML::StateMachines::PseudostateKind::join implies
		outgoing->size() = 1 and
		incoming->size() >= 2

	inv junction_vertex:
		kind = UML::StateMachines::PseudostateKind::junction implies
		incoming->size() >= 1 and
		outgoing->size() >= 1

	inv history_vertices:
		kind = UML::StateMachines::PseudostateKind::deepHistory or kind = UML::StateMachines::PseudostateKind::shallowHistory implies
		outgoing->size() <= 1

	inv initial_vertex:
		kind = UML::StateMachines::PseudostateKind::initial implies outgoing->size() <= 1

	inv fork_vertex:
		kind = UML::StateMachines::PseudostateKind::fork implies
		incoming->size() = 1 and
		outgoing->size() >= 2

	inv transitions_incoming:
		kind = UML::StateMachines::PseudostateKind::join implies
		incoming->forAll(t1, t2 |
		  let
		    contState : uml::StateMachines::State = containingStateMachine()
		    .LCAState(t1.source, t2.source)
		  in contState <> null and
		    contState.region->exists(r1, r2 | r1 <> r2 and
		      t1.source.isContainedInRegion(r1) and
		      t2.source.isContainedInRegion(r2)))

	context uml::StateMachines::Region

	inv deep_history_vertex:
		self.subvertex->select(
		  oclIsKindOf(uml::StateMachines::Pseudostate))
		->collect(
		  oclAsType(uml::StateMachines::Pseudostate))
		->select((kind = UML::StateMachines::PseudostateKind::deepHistory))
		->size() <= 1

	inv shallow_history_vertex:
		subvertex->select(
		  oclIsKindOf(uml::StateMachines::Pseudostate))
		->collect(
		  oclAsType(uml::StateMachines::Pseudostate))
		->select((kind = UML::StateMachines::PseudostateKind::shallowHistory))
		->size() <= 1

	inv owned:
		(stateMachine <> null implies state = null
		) and
		(state <> null implies stateMachine = null
		)

	inv initial_vertex:
		self.subvertex->select(
		  oclIsKindOf(uml::StateMachines::Pseudostate))
		->collect(
		  oclAsType(uml::StateMachines::Pseudostate))
		->select((kind = UML::StateMachines::PseudostateKind::initial))
		->size() <= 1

	context Region::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) : Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

	context uml::StateMachines::State

	inv entry_or_exit:
		connectionPoint->forAll(kind = UML::StateMachines::PseudostateKind::entryPoint or kind = UML::StateMachines::PseudostateKind::exitPoint)

	inv submachine_states:
		isSubmachineState implies connection->notEmpty()

	inv composite_states:
		connectionPoint->notEmpty() implies isComposite

	inv destinations_or_sources_of_transitions:
		self.isSubmachineState implies
		self.connection->forAll(cp |
		  cp.entry->forAll(ps | ps.stateMachine = self.submachine) and
		  cp.exit->forAll(ps | ps.stateMachine = self.submachine))

	inv submachine_or_regions:
		isComposite implies not isSubmachineState

	context State::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) : Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

	context uml::StateMachines::StateMachine

	inv connection_points:
		connectionPoint->forAll(kind = UML::StateMachines::PseudostateKind::entryPoint or kind = UML::StateMachines::PseudostateKind::exitPoint)

	inv classifier_context:
		_'context' <> null implies
		not _'context'.oclIsKindOf(uml::SimpleClassifiers::Interface)

	inv method:
		specification <> null implies connectionPoint->isEmpty()

	inv context_classifier:
		specification <> null implies _'context' <> null and
		specification.featuringClassifier->exists(c | c = _'context')

	context uml::StateMachines::Transition

	inv state_is_external:
		kind = UML::StateMachines::TransitionKind::external implies
		not (
		  source.oclIsKindOf(uml::StateMachines::Pseudostate) and
		  source.oclAsType(uml::StateMachines::Pseudostate).kind = UML::StateMachines::PseudostateKind::entryPoint
		)

	inv join_segment_guards:
		target.oclIsKindOf(uml::StateMachines::Pseudostate) and
		target.oclAsType(uml::StateMachines::Pseudostate).kind = UML::StateMachines::PseudostateKind::join implies guard = null and
		trigger->isEmpty()

	inv state_is_internal:
		kind = UML::StateMachines::TransitionKind::internal implies
		source.oclIsKindOf(uml::StateMachines::State) and source = target

	inv outgoing_pseudostates:
		source.oclIsKindOf(uml::StateMachines::Pseudostate) and
		source.oclAsType(uml::StateMachines::Pseudostate).kind <> UML::StateMachines::PseudostateKind::initial implies
		trigger->isEmpty()

	inv join_segment_state:
		target.oclIsKindOf(uml::StateMachines::Pseudostate) and
		target.oclAsType(uml::StateMachines::Pseudostate).kind = UML::StateMachines::PseudostateKind::join implies
		source.oclIsKindOf(uml::StateMachines::State)

	inv fork_segment_state:
		source.oclIsKindOf(uml::StateMachines::Pseudostate) and
		source.oclAsType(uml::StateMachines::Pseudostate).kind = UML::StateMachines::PseudostateKind::fork implies
		target.oclIsKindOf(uml::StateMachines::State)

	inv state_is_local:
		kind = UML::StateMachines::TransitionKind::local implies
		source.oclIsKindOf(uml::StateMachines::State) and
		source.oclAsType(uml::StateMachines::State).isComposite or
		source.oclIsKindOf(uml::StateMachines::Pseudostate) and
		source.oclAsType(uml::StateMachines::Pseudostate).kind = UML::StateMachines::PseudostateKind::entryPoint

	inv initial_transition:
		source.oclIsKindOf(uml::StateMachines::Pseudostate) and
		container.stateMachine->notEmpty() implies
		trigger->isEmpty()

	inv fork_segment_guards:
		source.oclIsKindOf(uml::StateMachines::Pseudostate) and
		source.oclAsType(uml::StateMachines::Pseudostate).kind = UML::StateMachines::PseudostateKind::fork implies guard = null and
		trigger->isEmpty()

	context Transition::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) : Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

endpackage

package uml::SimpleClassifiers

	context uml::SimpleClassifiers::BehavioredClassifier

	inv class_behavior:
		classifierBehavior->notEmpty() implies
		classifierBehavior.specification->isEmpty()

	context uml::SimpleClassifiers::Enumeration

	inv immutable:
		ownedAttribute->forAll(isReadOnly)

	context uml::SimpleClassifiers::Interface

	inv visibility:
		feature->forAll(visibility = UML::CommonStructure::VisibilityKind::public)

	context uml::SimpleClassifiers::Reception

	inv same_name_as_signal:
		name = signal.name

	inv same_structure_as_signal:
		signal.ownedAttribute->size() =
		ownedParameter->size() and
		Sequence{1..signal.ownedAttribute->size()
		}
		->forAll(i |
		  ownedParameter->at(i).direction = UML::Classification::ParameterDirectionKind::_'in' and
		  ownedParameter->at(i).name =
		  signal.ownedAttribute->at(i).name and
		  ownedParameter->at(i).type =
		  signal.ownedAttribute->at(i).type and
		  ownedParameter->at(i)
		  .lowerBound() =
		  signal.ownedAttribute->at(i)
		  .lowerBound() and
		  ownedParameter->at(i)
		  .upperBound() =
		  signal.ownedAttribute->at(i)
		  .upperBound())

endpackage

package uml::Packages

	context uml::Packages::Extension

	inv non_owned_end:
		metaclassEnd()
		->notEmpty() and
		metaclassEnd()
		.type.oclIsKindOf(uml::StructuredClassifiers::Class)

	inv is_binary:
		memberEnd->size() = 2

	context uml::Packages::ExtensionEnd

	inv multiplicity:
		(lowerBound() = 0 or lowerBound() = 1
		) and
		upperBound() = 1

	inv aggregation:
		self.aggregation = UML::Classification::AggregationKind::composite

	context uml::Packages::Package

	inv elements_public_or_private:
		packagedElement->forAll(e | e.visibility <> null implies e.visibility = UML::CommonStructure::VisibilityKind::public or e.visibility = UML::CommonStructure::VisibilityKind::private)

	context Package::makesVisible(el : uml::CommonStructure::NamedElement) : Boolean

	pre _'pre':
		member->includes(el)

	context uml::Packages::Profile

	inv metaclass_reference_not_specialized:
		metaclassReference.importedElement->select(c |
		  c.oclIsKindOf(uml::Classification::Classifier) and
		  c.oclAsType(uml::Classification::Classifier)
		  .allParents()
		  ->collect(namespace)
		  ->includes(self))
		->isEmpty() and
		packagedElement->select(
		  oclIsKindOf(uml::Classification::Classifier))
		->collect(
		  oclAsType(uml::Classification::Classifier)
		  .allParents())
		->intersection(
		  metaclassReference.importedElement->select(
		    oclIsKindOf(uml::Classification::Classifier))
		  ->collect(
		    oclAsType(uml::Classification::Classifier)))
		->isEmpty()

	inv references_same_metamodel:
		metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()
		->union(metaclassReference.importedElement.allOwningPackages())
		->notEmpty()

	context uml::Packages::Stereotype

	inv binaryAssociationsOnly:
		ownedAttribute.association->forAll(memberEnd->size() = 2)

	inv generalize:
		allParents()
		->forAll(oclIsKindOf(uml::Packages::Stereotype)) and
		uml::Classification::Classifier.allInstances()
		->forAll(c |
		  (
		    c.allParents()
		    ->exists(oclIsKindOf(uml::Packages::Stereotype)) implies
		    c.oclIsKindOf(uml::Packages::Stereotype)
		  ))

	inv name_not_clash:
		null

	inv associationEndOwnership:
		ownedAttribute->select(
		  association->notEmpty() and
		  not association.oclIsKindOf(uml::Packages::Extension) and
		  not type.oclIsKindOf(uml::Packages::Stereotype))
		->forAll(opposite.owner = association)

	inv base_property_upper_bound:
		null

	inv base_property_multiplicity_single_extension:
		null

	inv base_property_multiplicity_multiple_extension:
		null

endpackage

package uml::Interactions

	context uml::Interactions::ActionExecutionSpecification

	inv action_referenced:
		(
		  enclosingInteraction->notEmpty() or
		  enclosingOperand.combinedFragment->notEmpty()
		) and
		let
		  parentInteraction : Set(UML::Interactions::Interaction) = enclosingInteraction.oclAsType(uml::Interactions::Interaction)
		  ->asSet()
		  ->union(
		    enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)
		    ->collect(enclosingInteraction)
		    .oclAsType(uml::Interactions::Interaction)
		    ->asSet())
		in
		  parentInteraction->size() = 1 and
		  self.action.interaction->asSet() = parentInteraction

	context uml::Interactions::CombinedFragment

	inv break:
		interactionOperator = UML::Interactions::InteractionOperatorKind::break implies
		enclosingInteraction.oclAsType(uml::Interactions::InteractionFragment)
		->asSet()
		->union(
		  enclosingOperand.oclAsType(uml::Interactions::InteractionFragment)
		  ->asSet())
		.covered->asSet() =
		self.covered->asSet()

	inv consider_and_ignore:
		interactionOperator = UML::Interactions::InteractionOperatorKind::consider or interactionOperator = UML::Interactions::InteractionOperatorKind::ignore implies
		oclIsKindOf(uml::Interactions::ConsiderIgnoreFragment)

	inv opt_loop_break_neg:
		interactionOperator = UML::Interactions::InteractionOperatorKind::opt or interactionOperator = UML::Interactions::InteractionOperatorKind::loop or interactionOperator = UML::Interactions::InteractionOperatorKind::break or interactionOperator = UML::Interactions::InteractionOperatorKind::assert or interactionOperator = UML::Interactions::InteractionOperatorKind::neg implies
		operand->size() = 1

	context uml::Interactions::ConsiderIgnoreFragment

	inv consider_or_ignore:
		interactionOperator = UML::Interactions::InteractionOperatorKind::consider or interactionOperator = UML::Interactions::InteractionOperatorKind::ignore

	inv type:
		message->forAll(m |
		  m.oclIsKindOf(uml::Classification::Operation) or
		  m.oclIsKindOf(uml::SimpleClassifiers::Signal))

	context uml::Interactions::Continuation

	inv first_or_last_interaction_fragment:
		enclosingOperand->notEmpty() and
		let peerFragments : OrderedSet(UML::Interactions::InteractionFragment) = enclosingOperand.fragment
		in
		  peerFragments->notEmpty() and
		  (peerFragments->first() = self or peerFragments->last() = self
		  )

	inv same_name:
		enclosingOperand.combinedFragment->notEmpty() and
		let
		  parentInteraction : Set(UML::Interactions::Interaction) = enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)
		  ->collect(enclosingInteraction)
		  .oclAsType(uml::Interactions::Interaction)
		  ->asSet()
		in
		  parentInteraction->size() = 1 and
		  let
		    peerInteractions : Set(UML::Interactions::Interaction) = parentInteraction->union(
		      parentInteraction->collect(_'context')
		      ->collect(behavior)
		      ->select(
		        oclIsKindOf(uml::Interactions::Interaction))
		      .oclAsType(uml::Interactions::Interaction)
		      ->asSet())
		    ->asSet()
		  in
		    peerInteractions->notEmpty() and
		    let
		      combinedFragments1 : Set(UML::Interactions::CombinedFragment) = peerInteractions.fragment->select(
		        oclIsKindOf(uml::Interactions::CombinedFragment))
		      .oclAsType(uml::Interactions::CombinedFragment)
		      ->asSet()
		    in
		      combinedFragments1->notEmpty() and
		      combinedFragments1->closure(
		        operand.fragment->select(
		          oclIsKindOf(uml::Interactions::CombinedFragment))
		        .oclAsType(uml::Interactions::CombinedFragment))
		      ->asSet()
		      .operand.fragment->select(
		        oclIsKindOf(uml::Interactions::Continuation))
		      .oclAsType(uml::Interactions::Continuation)
		      ->asSet()
		      ->forAll(c |
		        (c.name = self.name implies
		          c.covered->asSet()
		          ->forAll(cl |
		            self.covered->asSet()
		            ->select(
		              (represents = cl.represents and selector = cl.selector
		              ))
		            ->asSet()
		            ->size() = 1) and
		          self.covered->asSet()
		          ->forAll(cl |
		            c.covered->asSet()
		            ->select(
		              (represents = cl.represents and selector = cl.selector
		              ))
		            ->asSet()
		            ->size() = 1)
		        ))

	inv global:
		enclosingOperand->notEmpty() and
		let operandLifelines : Set(UML::Interactions::Lifeline) = enclosingOperand.covered
		in
		  operandLifelines->notEmpty() and
		  operandLifelines->forAll(ol | self.covered->includes(ol))

	context uml::Interactions::DestructionOccurrenceSpecification

	inv no_occurrence_specifications_below:
		let o : uml::Interactions::InteractionOperand = enclosingOperand
		in
		  o->notEmpty() and
		  let
		    peerEvents : OrderedSet(UML::Interactions::OccurrenceSpecification) = covered.events->select(enclosingOperand = o)
		  in peerEvents->last() = self

	context uml::Interactions::ExecutionSpecification

	inv same_lifeline:
		start.covered = finish.covered

	context uml::Interactions::Gate

	inv actual_gate_matched:
		interactionUse->notEmpty() implies
		interactionUse.refersTo.formalGate->select(matches(self))
		->size() = 1

	inv inside_cf_matched:
		isInsideCF() implies
		combinedFragment.cfragmentGate->select(
		  (isOutsideCF() and matches(self)
		  ))
		->size() = 1

	inv outside_cf_matched:
		isOutsideCF() implies
		if
		  self.combinedFragment.interactionOperator->asOrderedSet()
		  ->first() = UML::Interactions::InteractionOperatorKind::alt
		then
		  self.combinedFragment.operand->forAll(op |
		    self.combinedFragment.cfragmentGate->select(
		      (
		        isInsideCF() and
		        oppositeEnd()
		        .enclosingFragment()
		        ->includes(self.combinedFragment) and
		        matches(self)
		      ))
		    ->size() = 1)
		else
		  self.combinedFragment.cfragmentGate->select(
		    (isInsideCF() and matches(self)
		    ))
		  ->size() = 1
		endif

	inv formal_gate_distinguishable:
		isFormal() implies
		interaction.formalGate->select(getName() = self.getName())
		->size() = 1

	inv actual_gate_distinguishable:
		isActual() implies
		interactionUse.actualGate->select(getName() = self.getName())
		->size() = 1

	inv outside_cf_gate_distinguishable:
		isOutsideCF() implies
		combinedFragment.cfragmentGate->select(getName() = self.getName())
		->size() = 1

	inv inside_cf_gate_distinguishable:
		isInsideCF() implies
		let selfOperand : uml::Interactions::InteractionOperand = self.getOperand()
		in
		  combinedFragment.cfragmentGate->select(
		    (isInsideCF() and getName() = self.getName()
		    ))
		  ->select(getOperand() = selfOperand)
		  ->size() = 1

	context uml::Interactions::GeneralOrdering

	inv irreflexive_transitive_closure:
		after->closure(toAfter.after)->excludes(before)

	context uml::Interactions::Interaction

	inv not_contained:
		enclosingInteraction->isEmpty()

	context uml::Interactions::InteractionConstraint

	inv minint_maxint:
		maxint->notEmpty() or
		minint->notEmpty() implies interactionOperand.combinedFragment.interactionOperator = UML::Interactions::InteractionOperatorKind::loop

	inv minint_non_negative:
		minint->notEmpty() implies minint->asSequence()->first().integerValue() >= 0

	inv maxint_positive:
		maxint->notEmpty() implies maxint->asSequence()->first().integerValue() > 0

	inv dynamic_variables:
		null

	inv global_data:
		null

	inv maxint_greater_equal_minint:
		maxint->notEmpty() implies
		minint->notEmpty() and
		maxint->asSequence()
		->first()
		.integerValue() >=
		minint->asSequence()
		->first()
		.integerValue()

	context uml::Interactions::InteractionOperand

	inv guard_contain_references:
		null

	inv guard_directly_prior:
		null

	context uml::Interactions::InteractionUse

	inv gates_match:
		actualGate->notEmpty() implies
		refersTo.formalGate->forAll(fg |
		  self.actualGate->select(matches(fg))
		  ->size() = 1) and
		self.actualGate->forAll(ag |
		  refersTo.formalGate->select(matches(ag))
		  ->size() = 1)

	inv arguments_are_constants:
		null

	inv returnValueRecipient_coverage:
		returnValueRecipient->asSet()
		->notEmpty() implies
		let
		  covCE : Set(UML::StructuredClassifiers::ConnectableElement) = covered.represents->asSet()
		in
		  covCE->notEmpty() and
		  let
		    classes : Set(UML::Classification::Classifier) = covCE.type.oclIsKindOf(uml::Classification::Classifier)
		    .oclAsType(uml::Classification::Classifier)
		    ->asSet()
		  in
		    let
		      allProps : Set(UML::Classification::Property) = classes.attribute->union(
		        classes.allParents().attribute)
		      ->asSet()
		    in allProps->includes(returnValueRecipient)

	inv arguments_correspond_to_parameters:
		null

	inv returnValue_type_recipient_correspondence:
		returnValue.type->asSequence()
		->notEmpty() implies
		returnValue.type->asSequence()
		->first() =
		returnValueRecipient.type->asSequence()
		->first()

	inv all_lifelines:
		let
		  parentInteraction : Set(UML::Interactions::Interaction) = enclosingInteraction->asSet()
		  ->union(
		    enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)
		    ->collect(enclosingInteraction)
		    .oclAsType(uml::Interactions::Interaction)
		    ->asSet())
		in
		  parentInteraction->size() = 1 and
		  let refInteraction : uml::Interactions::Interaction = refersTo
		  in
		    parentInteraction.covered->forAll(intLifeline |
		      refInteraction.covered->forAll(refLifeline |
		        (refLifeline.represents = intLifeline.represents and
		          (
		            refLifeline.selector.oclIsKindOf(uml::Values::LiteralString) implies
		            intLifeline.selector.oclIsKindOf(uml::Values::LiteralString) and
		            refLifeline.selector.oclAsType(uml::Values::LiteralString).value =
		            intLifeline.selector.oclAsType(uml::Values::LiteralString).value
		          ) and
		          (
		            refLifeline.selector.oclIsKindOf(uml::Values::LiteralInteger) implies
		            intLifeline.selector.oclIsKindOf(uml::Values::LiteralInteger) and
		            refLifeline.selector.oclAsType(uml::Values::LiteralInteger).value =
		            intLifeline.selector.oclAsType(uml::Values::LiteralInteger).value
		          ) implies
		          self.covered->asSet()
		          ->includes(intLifeline)
		        )))

	context uml::Interactions::Lifeline

	inv selector_specified:
		self.selector->notEmpty() =
		(
		  self.represents.oclIsKindOf(uml::CommonStructure::MultiplicityElement) and
		  self.represents.oclAsType(uml::CommonStructure::MultiplicityElement)
		  .isMultivalued()
		)

	inv interaction_uses_share_lifeline:
		let intUses : Set(UML::Interactions::InteractionUse) = interaction.interactionUse
		in
		  intUses->forAll(iuse |
		    let
		      usingInteraction : Set(UML::Interactions::Interaction) = iuse.enclosingInteraction->asSet()
		      ->union(
		        iuse.enclosingOperand.combinedFragment->asSet()
		        ->closure(enclosingOperand.combinedFragment)
		        .enclosingInteraction->asSet())
		    in
		      let
		        peerUses : Set(UML::Interactions::InteractionUse) = usingInteraction.fragment->select(
		          oclIsKindOf(uml::Interactions::InteractionUse))
		        .oclAsType(uml::Interactions::InteractionUse)
		        ->asSet()
		        ->union(
		          usingInteraction.fragment->select(
		            oclIsKindOf(uml::Interactions::CombinedFragment))
		          .oclAsType(uml::Interactions::CombinedFragment)
		          ->asSet()
		          ->closure(
		            operand.fragment->select(
		              oclIsKindOf(uml::Interactions::CombinedFragment))
		            .oclAsType(uml::Interactions::CombinedFragment))
		          .operand.fragment->select(
		            oclIsKindOf(uml::Interactions::InteractionUse))
		          .oclAsType(uml::Interactions::InteractionUse)
		          ->asSet())
		        ->excluding(iuse)
		      in
		        peerUses->forAll(peerUse |
		          peerUse.refersTo.lifeline->forAll(l | l.represents = self.represents and
		            (
		              self.selector.oclIsKindOf(uml::Values::LiteralString) implies
		              l.selector.oclIsKindOf(uml::Values::LiteralString) and
		              self.selector.oclAsType(uml::Values::LiteralString).value =
		              l.selector.oclAsType(uml::Values::LiteralString).value
		            ) and
		            (
		              self.selector.oclIsKindOf(uml::Values::LiteralInteger) implies
		              l.selector.oclIsKindOf(uml::Values::LiteralInteger) and
		              self.selector.oclAsType(uml::Values::LiteralInteger).value =
		              l.selector.oclAsType(uml::Values::LiteralInteger).value
		            ) implies
		            usingInteraction.lifeline->exists(represents = self.represents and
		              (
		                self.selector.oclIsKindOf(uml::Values::LiteralString) implies
		                l.selector.oclIsKindOf(uml::Values::LiteralString) and
		                self.selector.oclAsType(uml::Values::LiteralString).value =
		                l.selector.oclAsType(uml::Values::LiteralString).value
		              ) and
		              (
		                self.selector.oclIsKindOf(uml::Values::LiteralInteger) implies
		                l.selector.oclIsKindOf(uml::Values::LiteralInteger) and
		                self.selector.oclAsType(uml::Values::LiteralInteger).value =
		                l.selector.oclAsType(uml::Values::LiteralInteger).value
		              )))))

	inv same_classifier:
		represents.namespace->closure(namespace)
		->includes(interaction._'context')

	inv selector_int_or_string:
		self.selector->notEmpty() implies
		self.selector.oclIsKindOf(uml::Values::LiteralInteger) or
		self.selector.oclIsKindOf(uml::Values::LiteralString)

	context uml::Interactions::Message

	inv sending_receiving_message_event:
		receiveEvent.oclIsKindOf(uml::Interactions::MessageOccurrenceSpecification) implies
		let
		  f : uml::Interactions::Lifeline = sendEvent->select(
		    oclIsKindOf(uml::Interactions::MessageOccurrenceSpecification))
		  .oclAsType(uml::Interactions::MessageOccurrenceSpecification)
		  ->asOrderedSet()
		  ->first().covered
		in f =
		  receiveEvent->select(
		    oclIsKindOf(uml::Interactions::MessageOccurrenceSpecification))
		  .oclAsType(uml::Interactions::MessageOccurrenceSpecification)
		  ->asOrderedSet()
		  ->first().covered implies
		  f.events->indexOf(
		    sendEvent.oclAsType(uml::Interactions::MessageOccurrenceSpecification)
		    ->asOrderedSet()
		    ->first()) <
		  f.events->indexOf(
		    receiveEvent.oclAsType(uml::Interactions::MessageOccurrenceSpecification)
		    ->asOrderedSet()
		    ->first())

	inv arguments:
		null

	inv cannot_cross_boundaries:
		sendEvent->notEmpty() and
		receiveEvent->notEmpty() implies
		let
		  sendEnclosingFrag : Set(UML::Interactions::InteractionFragment) = sendEvent->asOrderedSet()
		  ->first()
		  .enclosingFragment()
		in
		  let
		    receiveEnclosingFrag : Set(UML::Interactions::InteractionFragment) = receiveEvent->asOrderedSet()
		    ->first()
		    .enclosingFragment()
		  in sendEnclosingFrag = receiveEnclosingFrag

	inv signature_is_signal:
		messageSort = UML::Interactions::MessageSort::asynchSignal and
		signature.oclIsKindOf(uml::SimpleClassifiers::Signal) implies
		let
		  signalAttributes : OrderedSet(UML::Classification::Property) = signature.oclAsType(uml::SimpleClassifiers::Signal)
		  .inheritedMember()
		  ->select(n |
		    n.oclIsTypeOf(uml::Classification::Property))
		  ->collect(
		    oclAsType(uml::Classification::Property))
		  ->asOrderedSet()
		in
		  signalAttributes->size() =
		  self.argument->size() and
		  self.argument->forAll(o |
		    (
		      not (
		        o.oclIsKindOf(uml::Values::Expression) and
		        o.oclAsType(uml::Values::Expression)
		        .symbol->size() = 0 and
		        o.oclAsType(uml::Values::Expression)
		        .operand->isEmpty()
		      ) implies
		      let
		        p : uml::Classification::Property = signalAttributes->at(
		          self.argument->indexOf(o))
		      in
		        o.type.oclAsType(uml::Classification::Classifier)
		        .conformsTo(
		          p.type.oclAsType(uml::Classification::Classifier))
		    ))

	inv occurrence_specifications:
		null

	inv signature_refer_to:
		signature->notEmpty() implies
		(
		  signature.oclIsKindOf(uml::Classification::Operation) and
		  (messageSort = UML::Interactions::MessageSort::asynchCall or messageSort = UML::Interactions::MessageSort::synchCall or messageSort = UML::Interactions::MessageSort::reply
		  ) or
		  signature.oclIsKindOf(uml::SimpleClassifiers::Signal) and messageSort = UML::Interactions::MessageSort::asynchSignal
		) and name = signature.name

	inv signature_is_operation_request:
		(messageSort = UML::Interactions::MessageSort::asynchCall or messageSort = UML::Interactions::MessageSort::synchCall
		) and
		signature.oclIsKindOf(uml::Classification::Operation) implies
		let
		  requestParms : OrderedSet(UML::Classification::Parameter) = signature.oclAsType(uml::Classification::Operation)
		  .ownedParameter->select(direction = UML::Classification::ParameterDirectionKind::inout or direction = UML::Classification::ParameterDirectionKind::_'in')
		in
		  requestParms->size() =
		  self.argument->size() and
		  self.argument->forAll(o |
		    (
		      not (
		        o.oclIsKindOf(uml::Values::Expression) and
		        o.oclAsType(uml::Values::Expression)
		        .symbol->size() = 0 and
		        o.oclAsType(uml::Values::Expression)
		        .operand->isEmpty()
		      ) implies
		      let
		        p : uml::Classification::Parameter = requestParms->at(
		          self.argument->indexOf(o))
		      in
		        o.type.oclAsType(uml::Classification::Classifier)
		        .conformsTo(
		          p.type.oclAsType(uml::Classification::Classifier))
		    ))

	inv signature_is_operation_reply:
		messageSort = UML::Interactions::MessageSort::reply and
		signature.oclIsKindOf(uml::Classification::Operation) implies
		let
		  replyParms : OrderedSet(UML::Classification::Parameter) = signature.oclAsType(uml::Classification::Operation)
		  .ownedParameter->select(direction = UML::Classification::ParameterDirectionKind::inout or direction = UML::Classification::ParameterDirectionKind::out or direction = UML::Classification::ParameterDirectionKind::return)
		in
		  replyParms->size() =
		  self.argument->size() and
		  self.argument->forAll(o |
		    o.oclIsKindOf(uml::Values::Expression) and
		    let
		      e : uml::Values::Expression = o.oclAsType(uml::Values::Expression)
		    in
		      (
		        e.operand->notEmpty() implies
		        let
		          p : uml::Classification::Parameter = replyParms->at(
		            self.argument->indexOf(o))
		        in
		          e.operand->asSequence()
		          ->first()
		          .type.oclAsType(uml::Classification::Classifier)
		          .conformsTo(
		            p.type.oclAsType(uml::Classification::Classifier))
		      ))

	context MessageEnd::oppositeEnd() : Set(uml::Interactions::MessageEnd)

	pre _'pre':
		message->notEmpty()

	context MessageEnd::isSend() : Boolean

	pre _'pre':
		message->notEmpty()

	context MessageEnd::isReceive() : Boolean

	pre _'pre':
		message->notEmpty()

	context uml::Interactions::PartDecomposition

	inv commutativity_of_decomposition:
		null

	inv assume:
		null

	inv parts_of_internal_structures:
		null

endpackage

package uml::InformationFlows

	context uml::InformationFlows::InformationFlow

	inv must_conform:
		null

	inv sources_and_targets_kind:
		self.informationSource->forAll(sis |
		  (
		    oclIsKindOf(uml::UseCases::Actor) or
		    oclIsKindOf(uml::Deployments::Node) or
		    oclIsKindOf(uml::UseCases::UseCase) or
		    oclIsKindOf(uml::Deployments::Artifact) or
		    oclIsKindOf(uml::StructuredClassifiers::Class) or
		    oclIsKindOf(uml::StructuredClassifiers::Component) or
		    oclIsKindOf(uml::StructuredClassifiers::Port) or
		    oclIsKindOf(uml::Classification::Property) or
		    oclIsKindOf(uml::SimpleClassifiers::Interface) or
		    oclIsKindOf(uml::Packages::Package) or
		    oclIsKindOf(uml::Activities::ActivityNode) or
		    oclIsKindOf(uml::Activities::ActivityPartition) or
		    oclIsKindOf(uml::Classification::InstanceSpecification) and
		    not sis.oclAsType(uml::Classification::InstanceSpecification)
		    .classifier->exists(
		      oclIsKindOf(uml::CommonStructure::Relationship))
		  )) and
		self.informationTarget->forAll(sit |
		  (
		    oclIsKindOf(uml::UseCases::Actor) or
		    oclIsKindOf(uml::Deployments::Node) or
		    oclIsKindOf(uml::UseCases::UseCase) or
		    oclIsKindOf(uml::Deployments::Artifact) or
		    oclIsKindOf(uml::StructuredClassifiers::Class) or
		    oclIsKindOf(uml::StructuredClassifiers::Component) or
		    oclIsKindOf(uml::StructuredClassifiers::Port) or
		    oclIsKindOf(uml::Classification::Property) or
		    oclIsKindOf(uml::SimpleClassifiers::Interface) or
		    oclIsKindOf(uml::Packages::Package) or
		    oclIsKindOf(uml::Activities::ActivityNode) or
		    oclIsKindOf(uml::Activities::ActivityPartition) or
		    oclIsKindOf(uml::Classification::InstanceSpecification) and
		    not sit.oclAsType(uml::Classification::InstanceSpecification)
		    .classifier->exists(
		      oclIsKindOf(uml::CommonStructure::Relationship))
		  ))

	inv convey_classifiers:
		self.conveyed->forAll(
		  oclIsKindOf(uml::StructuredClassifiers::Class) or
		  oclIsKindOf(uml::SimpleClassifiers::Interface) or
		  oclIsKindOf(uml::InformationFlows::InformationItem) or
		  oclIsKindOf(uml::SimpleClassifiers::Signal) or
		  oclIsKindOf(uml::StructuredClassifiers::Component))

	context uml::InformationFlows::InformationItem

	inv sources_and_targets:
		self.represented->select(
		  oclIsKindOf(uml::InformationFlows::InformationItem))
		->forAll(p |
		  p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and
		  p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q))) and
		self.represented->forAll(
		  (
		    oclIsKindOf(uml::StructuredClassifiers::Class) or
		    oclIsKindOf(uml::SimpleClassifiers::Interface) or
		    oclIsKindOf(uml::InformationFlows::InformationItem) or
		    oclIsKindOf(uml::SimpleClassifiers::Signal) or
		    oclIsKindOf(uml::StructuredClassifiers::Component)
		  ))

	inv has_no:
		self.generalization->isEmpty() and self.feature->isEmpty()

	inv not_instantiable:
		isAbstract

endpackage

package uml::Deployments

	context uml::Deployments::CommunicationPath

	inv association_ends:
		endType->forAll(
		  oclIsKindOf(uml::Deployments::DeploymentTarget))

	context uml::Deployments::DeploymentSpecification

	inv deployment_target:
		deployment->forAll(
		  location.oclIsKindOf(uml::Deployments::ExecutionEnvironment))

	inv deployed_elements:
		deployment->forAll(
		  location.deployedElement->forAll(
		    oclIsKindOf(uml::StructuredClassifiers::Component)))

	context uml::Deployments::Node

	inv internal_structure:
		part->forAll(oclIsKindOf(uml::Deployments::Node))

endpackage

package uml::CommonStructure

	context uml::CommonStructure::Constraint

	inv boolean_value:
		null

	inv no_side_effects:
		null

	inv not_apply_to_self:
		not constrainedElement->includes(self)

	context uml::CommonStructure::Element

	inv has_owner:
		mustBeOwned() implies owner->notEmpty()

	inv not_own_self:
		not allOwnedElements()->includes(self)

	context uml::CommonStructure::ElementImport

	inv imported_element_is_public:
		importedElement.visibility <> null implies importedElement.visibility = UML::CommonStructure::VisibilityKind::public

	inv visibility_public_or_private:
		visibility = UML::CommonStructure::VisibilityKind::public or visibility = UML::CommonStructure::VisibilityKind::private

	context uml::CommonStructure::MultiplicityElement

	inv upper_ge_lower:
		upperBound() >= lowerBound()

	inv lower_ge_0:
		lowerBound() >= 0

	inv value_specification_no_side_effects:
		null

	inv value_specification_constant:
		null

	inv lower_is_integer:
		lowerValue <> null implies lowerValue.integerValue() <> null

	inv upper_is_unlimitedNatural:
		upperValue <> null implies upperValue.unlimitedValue() <> null

	context MultiplicityElement::includesMultiplicity(M : uml::CommonStructure::MultiplicityElement) : Boolean

	pre _'pre':
		self.upperBound()
		->notEmpty() and
		self.lowerBound()
		->notEmpty() and
		M.upperBound()
		->notEmpty() and
		M.lowerBound()
		->notEmpty()

	context MultiplicityElement::isMultivalued() : Boolean

	pre _'pre':
		upperBound()->notEmpty()

	context uml::CommonStructure::NamedElement

	inv visibility_needs_ownership:
		namespace = null and owner <> null implies visibility = null

	inv has_qualified_name:
		name <> null and
		allNamespaces()
		->select(ns | ns.name = null)
		->isEmpty() implies qualifiedName =
		allNamespaces()
		->iterate(ns; agg : String = name |
		  ns.name.concat(self.separator())
		  .concat(agg))

	inv has_no_qualified_name:
		name = null or
		allNamespaces()
		->select(ns | ns.name = null)
		->notEmpty() implies qualifiedName = null

	context uml::CommonStructure::Namespace

	inv members_distinguishable:
		membersAreDistinguishable()

	inv cannot_import_self:
		packageImport.importedPackage.oclAsType(uml::CommonStructure::Namespace)
		->excludes(self)

	inv cannot_import_ownedMembers:
		elementImport.importedElement.oclAsType(uml::CommonStructure::Element)
		->excludesAll(ownedMember)

	context uml::CommonStructure::PackageableElement

	inv namespace_needs_visibility:
		visibility = null implies namespace = null

	context uml::CommonStructure::PackageImport

	inv public_or_private:
		visibility = UML::CommonStructure::VisibilityKind::public or visibility = UML::CommonStructure::VisibilityKind::private

	context uml::CommonStructure::TemplateBinding

	inv parameter_substitution_formal:
		parameterSubstitution->forAll(b |
		  signature.parameter->includes(b.formal))

	inv one_parameter_substitution:
		signature.parameter->forAll(p |
		  parameterSubstitution->select(b | (b.formal = p))
		  ->size() <= 1)

	context uml::CommonStructure::TemplateParameter

	inv must_be_compatible:
		default <> null implies
		default.isCompatibleWith(parameteredElement)

	context uml::CommonStructure::TemplateParameterSubstitution

	inv must_be_compatible:
		actual->forAll(a |
		  a.isCompatibleWith(formal.parameteredElement))

	context uml::CommonStructure::TemplateSignature

	inv own_elements:
		template.ownedElement->includesAll(
		  parameter.parameteredElement->asSet() -
		  parameter.ownedParameteredElement->asSet())

	inv unique_parameters:
		parameter->forAll(p1, p2 | p1 <> p2 and
		  p1.parameteredElement.oclIsKindOf(uml::CommonStructure::NamedElement) and
		  p2.parameteredElement.oclIsKindOf(uml::CommonStructure::NamedElement) implies
		  p1.parameteredElement.oclAsType(uml::CommonStructure::NamedElement).name <>
		  p2.parameteredElement.oclAsType(uml::CommonStructure::NamedElement).name)

endpackage

package uml::CommonBehavior

	context uml::CommonBehavior::Behavior

	inv most_one_behavior:
		specification <> null implies
		_'context'.ownedBehavior->select(specification = self.specification)
		->size() = 1

	inv parameters_match:
		specification <> null implies
		ownedParameter->size() =
		specification.ownedParameter->size()

	inv feature_of_context_classifier:
		_'context'.feature->includes(specification)

	context Behavior::behavioredClassifier(from : uml::CommonStructure::Element) :
	uml::SimpleClassifiers::BehavioredClassifier

	pre spec:
		if
		  from.oclIsKindOf(uml::SimpleClassifiers::BehavioredClassifier)
		then
		  from.oclAsType(uml::SimpleClassifiers::BehavioredClassifier)
		else
		  if from.owner = null
		  then null
		  else self.behavioredClassifier(from.owner)
		  endif
		endif

	context uml::CommonBehavior::FunctionBehavior

	inv one_output_parameter:
		self.ownedParameter->select(p |
		  (p.direction = UML::Classification::ParameterDirectionKind::out or p.direction = UML::Classification::ParameterDirectionKind::inout or p.direction = UML::Classification::ParameterDirectionKind::return
		  ))
		->size() >= 1

	inv types_of_parameters:
		ownedParameter->forAll(p | p.type <> null and
		  p.type.oclIsTypeOf(uml::SimpleClassifiers::DataType) and
		  hasAllDataTypeAttributes(
		    p.type.oclAsType(uml::SimpleClassifiers::DataType)))

	context uml::CommonBehavior::TimeEvent

	inv when_non_negative:
		when.integerValue() >= 0

	context uml::CommonBehavior::Trigger

	inv trigger_with_ports:
		port->notEmpty() implies
		event.oclIsKindOf(uml::CommonBehavior::MessageEvent)

endpackage

package uml::Classification

	context uml::Classification::BehavioralFeature

	inv abstract_no_method:
		isAbstract implies method->isEmpty()

	context uml::Classification::Classifier

	inv specialize_type:
		parents()->forAll(c | self.maySpecializeType(c))

	inv maps_to_generalization_set:
		powertypeExtent->forAll(gs |
		  gs.generalization->forAll(gen |
		    not (gen.general = self
		    ) and
		    not gen.general.allParents()
		    ->includes(self) and
		    not (gen.specific = self
		    ) and
		    not self.allParents()
		    ->includes(gen.specific)))

	inv non_final_parents:
		parents()->forAll(not isFinalSpecialization)

	inv no_cycles_in_generalization:
		not allParents()->includes(self)

	context Classifier::hasVisibilityOf(n : uml::CommonStructure::NamedElement) : Boolean

	pre _'pre':
		allParents()->including(self)->collect(member)->includes(n)

	context Classifier::inheritableMembers(c : uml::Classification::Classifier) : Set(uml::CommonStructure::NamedElement)

	pre _'pre':
		c.allParents()->includes(self)

	context uml::Classification::ClassifierTemplateParameter

	inv has_constraining_classifier:
		allowSubstitutable implies constrainingClassifier->notEmpty()

	inv parametered_element_no_features:
		parameteredElement.feature->isEmpty() and
		(
		  constrainingClassifier->isEmpty() implies
		  parameteredElement.allParents()
		  ->isEmpty()
		)

	inv matching_abstract:
		not parameteredElement.isAbstract implies
		templateParameterSubstitution.actual->forAll(a |
		  not a.oclAsType(uml::Classification::Classifier).isAbstract)

	inv actual_is_classifier:
		templateParameterSubstitution.actual->forAll(a |
		  a.oclIsKindOf(uml::Classification::Classifier))

	inv constraining_classifiers_constrain_args:
		templateParameterSubstitution.actual->forAll(a |
		  let
		    arg : uml::Classification::Classifier = a.oclAsType(uml::Classification::Classifier)
		  in
		    constrainingClassifier->forAll(cc | arg = cc or
		      arg.conformsTo(cc) or allowSubstitutable and
		      arg.isSubstitutableFor(cc)))

	inv constraining_classifiers_constrain_parametered_element:
		constrainingClassifier->forAll(cc | parameteredElement = cc or
		  parameteredElement.conformsTo(cc) or allowSubstitutable and
		  parameteredElement.isSubstitutableFor(cc))

	context uml::Classification::GeneralizationSet

	inv generalization_same_classifier:
		generalization->collect(general)->asSet()->size() <= 1

	inv maps_to_generalization_set:
		powertype <> null implies
		generalization->forAll(gen |
		  not (gen.general = powertype
		  ) and
		  not gen.general.allParents()
		  ->includes(powertype) and
		  not (gen.specific = powertype
		  ) and
		  not powertype.allParents()
		  ->includes(gen.specific))

	context uml::Classification::InstanceSpecification

	inv deployment_artifact:
		deploymentForArtifact->notEmpty() implies
		classifier->exists(
		  oclIsKindOf(uml::Deployments::Artifact))

	inv structural_feature:
		classifier->forAll(c |
		  c.allSlottableFeatures()
		  ->forAll(f |
		    slot->select(s | (s.definingFeature = f))
		    ->size() <= 1))

	inv defining_feature:
		slot->forAll(s |
		  classifier->exists(c |
		    c.allSlottableFeatures()
		    ->includes(s.definingFeature)))

	inv deployment_target:
		deployment->notEmpty() implies
		classifier->exists(node |
		  node.oclIsKindOf(uml::Deployments::Node) and
		  uml::Deployments::Node.allInstances()
		  ->exists(n | n.part->exists(p | p.type = node)))

	context uml::Classification::Operation

	inv at_most_one_return:
		self.ownedParameter->select(
		  (direction = UML::Classification::ParameterDirectionKind::return
		  ))
		->size() <= 1

	inv only_body_for_query:
		bodyCondition <> null implies isQuery

	context Operation::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) : Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

	context uml::Classification::OperationTemplateParameter

	inv match_default_signature:
		default->notEmpty() implies
		default.oclIsKindOf(uml::Classification::Operation) and
		let
		  defaultOp : uml::Classification::Operation = default.oclAsType(uml::Classification::Operation)
		in
		  defaultOp.ownedParameter->size() =
		  parameteredElement.ownedParameter->size() and
		  Sequence{1..defaultOp.ownedParameter->size()
		  }
		  ->forAll(ix |
		    let
		      p1 : uml::Classification::Parameter = defaultOp.ownedParameter->at(ix)
		    in
		      let
		        p2 : uml::Classification::Parameter = parameteredElement.ownedParameter->at(ix)
		      in p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction = p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)

	context uml::Classification::Parameter

	inv in_and_out:
		(effect = UML::Classification::ParameterEffectKind::delete implies direction = UML::Classification::ParameterDirectionKind::_'in' or direction = UML::Classification::ParameterDirectionKind::inout
		) and
		(effect = UML::Classification::ParameterEffectKind::create implies direction = UML::Classification::ParameterDirectionKind::out or direction = UML::Classification::ParameterDirectionKind::inout or direction = UML::Classification::ParameterDirectionKind::return
		)

	inv not_exception:
		isException implies direction <> UML::Classification::ParameterDirectionKind::_'in' and direction <> UML::Classification::ParameterDirectionKind::inout

	inv connector_end:
		end->notEmpty() implies collaboration->notEmpty()

	inv reentrant_behaviors:
		isStream and behavior <> null implies not behavior.isReentrant

	inv stream_and_exception:
		not (isException and isStream)

	inv object_effect:
		type.oclIsKindOf(uml::SimpleClassifiers::DataType) implies effect = null

	context uml::Classification::ParameterSet

	inv same_parameterized_entity:
		parameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and p1.direction = p2.direction)

	inv input:
		(
		  parameter->exists(direction = UML::Classification::ParameterDirectionKind::_'in') implies
		  behavioralFeature.ownedParameter->select(p | p.direction = UML::Classification::ParameterDirectionKind::_'in' and
		    p.parameterSet->isEmpty())
		  ->forAll(isStream)
		) and
		(
		  parameter->exists(direction = UML::Classification::ParameterDirectionKind::out) implies
		  behavioralFeature.ownedParameter->select(p | p.direction = UML::Classification::ParameterDirectionKind::out and
		    p.parameterSet->isEmpty())
		  ->forAll(isStream)
		)

	inv two_parameter_sets:
		parameter->forAll(
		  parameterSet->forAll(s1, s2 |
		    s1->size() =
		    s2->size() implies
		    s1.parameter->exists(p | not s2.parameter->includes(p))))

	context uml::Classification::Property

	inv subsetting_context_conforms:
		subsettedProperty->notEmpty() implies
		subsettingContext()
		->notEmpty() and
		subsettingContext()
		->forAll(sc |
		  subsettedProperty->forAll(sp |
		    sp.subsettingContext()
		    ->exists(c | sc.conformsTo(c))))

	inv derived_union_is_read_only:
		isDerivedUnion implies isReadOnly

	inv multiplicity_of_composite:
		isComposite and association <> null implies opposite.upperBound() <= 1

	inv redefined_property_inherited:
		redefinedProperty->notEmpty() implies
		redefinitionContext->notEmpty() and
		redefinedProperty->forAll(rp |
		  redefinitionContext->collect(fc | fc.allParents())
		  ->asSet()
		  ->collect(c | c.allFeatures())
		  ->asSet()
		  ->includes(rp))

	inv subsetting_rules:
		subsettedProperty->forAll(sp |
		  self.type.conformsTo(sp.type) and
		  (
		    self.upperBound()
		    ->notEmpty() and
		    sp.upperBound()
		    ->notEmpty() implies
		    self.upperBound() <=
		    sp.upperBound()
		  ))

	inv binding_to_attribute:
		self.isAttribute() and
		templateParameterSubstitution->notEmpty() implies
		templateParameterSubstitution->forAll(ts |
		  ts.formal.oclIsKindOf(uml::Classification::Property) and
		  ts.formal.oclAsType(uml::Classification::Property)
		  .isAttribute())

	inv derived_union_is_derived:
		isDerivedUnion implies isDerived

	inv deployment_target:
		deployment->notEmpty() implies
		owner.oclIsKindOf(uml::Deployments::Node) and
		uml::Deployments::Node.allInstances()
		->exists(n | n.part->exists(p | p = self))

	inv subsetted_property_names:
		subsettedProperty->forAll(sp | sp.name <> name)

	inv type_of_opposite_end:
		opposite->notEmpty() and owningAssociation->isEmpty() implies classifier = opposite.type

	inv qualified_is_association_end:
		qualifier->notEmpty() implies association->notEmpty()

	context Property::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) : Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

	context uml::Classification::RedefinableElement

	inv redefinition_consistent:
		redefinedElement->forAll(re | re.isConsistentWith(self))

	inv non_leaf_redefinition:
		redefinedElement->forAll(re | not re.isLeaf)

	inv redefinition_context_valid:
		redefinedElement->forAll(re | self.isRedefinitionContextValid(re))

	context RedefinableElement::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) : Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

	context uml::Classification::RedefinableTemplateSignature

	inv redefines_parents:
		classifier.allParents()
		->forAll(c |
		  c.ownedTemplateSignature->notEmpty() implies
		  self->closure(extendedSignature)
		  ->includes(c.ownedTemplateSignature))

	context RedefinableTemplateSignature::isConsistentWith(redefiningElement : uml::Classification::RedefinableElement) :
	Boolean

	pre _'pre':
		redefiningElement.isRedefinitionContextValid(self)

endpackage

package uml::Actions

	context uml::Actions::ValueSpecificationAction

	inv multiplicity:
		result.is(1, 1)

	inv compatible_type:
		value.type.conformsTo(result.type)

	context uml::Actions::VariableAction

	inv scope_of_variable:
		variable.isAccessibleBy(self)

	context uml::Actions::WriteLinkAction

	inv allow_access:
		endData.end->exists(end | end.type = _'context' or end.visibility = UML::CommonStructure::VisibilityKind::public or end.visibility = UML::CommonStructure::VisibilityKind::protected and
		  endData.end->exists(other | other <> end and
		    _'context'.conformsTo(
		      other.type.oclAsType(uml::Classification::Classifier))))

	context uml::Actions::WriteStructuralFeatureAction

	inv multiplicity_of_result:
		result <> null implies result.is(1, 1)

	inv type_of_value:
		value <> null implies
		value.type.conformsTo(structuralFeature.type)

	inv multiplicity_of_value:
		value <> null implies value.is(1, 1)

	inv type_of_result:
		result <> null implies result.type = object.type

	context uml::Actions::WriteVariableAction

	inv value_type:
		value <> null implies value.type.conformsTo(variable.type)

	inv multiplicity:
		value <> null implies value.is(1, 1)

	context uml::Actions::AcceptCallAction

	inv result_pins:
		let
		  parameter : OrderedSet(UML::Classification::Parameter) = trigger.event->asSequence()
		  ->first()
		  .oclAsType(uml::CommonBehavior::CallEvent)
		  .operation.inputParameters()
		in
		  result->size() =
		  parameter->size() and
		  Sequence{1..result->size()
		  }
		  ->forAll(i |
		    parameter->at(i)
		    .type.conformsTo(result->at(i).type) and
		    parameter->at(i).isOrdered =
		    result->at(i).isOrdered and
		    parameter->at(i)
		    .compatibleWith(result->at(i)))

	inv trigger_call_event:
		trigger->size() = 1 and
		trigger->asSequence()
		->first()
		.event.oclIsKindOf(uml::CommonBehavior::CallEvent)

	inv unmarshall:
		isUnmarshall = true

	context uml::Actions::AcceptEventAction

	inv one_output_pin:
		not isUnmarshall and
		trigger->exists(
		  (
		    event.oclIsKindOf(uml::CommonBehavior::SignalEvent) or
		    event.oclIsKindOf(uml::CommonBehavior::TimeEvent)
		  )) implies
		output->size() = 1 and
		output->first()
		.is(1, 1)

	inv no_input_pins:
		input->size() = 0

	inv no_output_pins:
		self.oclIsTypeOf(uml::Actions::AcceptEventAction) and
		trigger->forAll(
		  (
		    event.oclIsKindOf(uml::CommonBehavior::ChangeEvent) or
		    event.oclIsKindOf(uml::CommonBehavior::CallEvent)
		  )) implies
		output->size() = 0

	inv unmarshall_signal_events:
		isUnmarshall and
		self.oclIsTypeOf(uml::Actions::AcceptEventAction) implies
		trigger->size() = 1 and
		trigger->asSequence()
		->first()
		.event.oclIsKindOf(uml::CommonBehavior::SignalEvent) and
		let
		  attribute : OrderedSet(UML::Classification::Property) = trigger->asSequence()
		  ->first()
		  .event.oclAsType(uml::CommonBehavior::SignalEvent)
		  .signal.allAttributes()
		in
		  attribute->size() > 0 and
		  result->size() =
		  attribute->size() and
		  Sequence{1..result->size()
		  }
		  ->forAll(i |
		    result->at(i).type =
		    attribute->at(i).type and
		    result->at(i).isOrdered =
		    attribute->at(i).isOrdered and
		    result->at(i)
		    .includesMultiplicity(attribute->at(i)))

	inv conforming_type:
		not isUnmarshall implies
		result->isEmpty() or
		let type : uml::CommonStructure::Type = result->first().type
		in type = null or
		  trigger->forAll(
		    event.oclIsKindOf(uml::CommonBehavior::SignalEvent)) and
		  trigger.event.oclAsType(uml::CommonBehavior::SignalEvent)
		  .signal->forAll(s | s.conformsTo(type))

	context uml::Actions::ActionInputPin

	inv input_pin:
		fromAction.input->forAll(
		  oclIsKindOf(uml::Actions::ActionInputPin))

	inv one_output_pin:
		fromAction.output->size() = 1

	inv no_control_or_object_flow:
		fromAction.incoming->union(outgoing)
		->isEmpty() and
		fromAction.input.incoming->isEmpty() and
		fromAction.output.outgoing->isEmpty()

	context uml::Actions::AddStructuralFeatureValueAction

	inv required_value:
		value <> null

	inv insertAt_pin:
		if not structuralFeature.isOrdered
		then insertAt = null
		else not isReplaceAll implies insertAt <> null and
		  insertAt->forAll(type = UnlimitedNatural and
		    is(1, 1.oclAsType(UnlimitedNatural)))
		endif

	context uml::Actions::AddVariableValueAction

	inv required_value:
		value <> null

	inv insertAt_pin:
		if not variable.isOrdered
		then insertAt = null
		else not isReplaceAll implies insertAt <> null and
		  insertAt->forAll(type = UnlimitedNatural and
		    is(1, 1.oclAsType(UnlimitedNatural)))
		endif

	context uml::Actions::BroadcastSignalAction

	inv number_of_arguments:
		argument->size() = signal.allAttributes()->size()

	inv type_ordering_multiplicity:
		let
		  attribute : OrderedSet(UML::Classification::Property) = signal.allAttributes()
		in
		  Sequence{1..argument->size()
		  }
		  ->forAll(i |
		    argument->at(i)
		    .type.conformsTo(attribute->at(i).type) and
		    argument->at(i).isOrdered =
		    attribute->at(i).isOrdered and
		    argument->at(i)
		    .compatibleWith(attribute->at(i)))

	inv no_onport:
		onPort = null

	context uml::Actions::CallAction

	inv argument_pins:
		let
		  parameter : OrderedSet(UML::Classification::Parameter) = self.inputParameters()
		in
		  argument->size() =
		  parameter->size() and
		  Sequence{1..argument->size()
		  }
		  ->forAll(i |
		    argument->at(i)
		    .type.conformsTo(parameter->at(i).type) and
		    argument->at(i).isOrdered =
		    parameter->at(i).isOrdered and
		    argument->at(i)
		    .compatibleWith(parameter->at(i)))

	inv result_pins:
		let
		  parameter : OrderedSet(UML::Classification::Parameter) = self.outputParameters()
		in
		  result->size() =
		  parameter->size() and
		  Sequence{1..result->size()
		  }
		  ->forAll(i |
		    parameter->at(i)
		    .type.conformsTo(result->at(i).type) and
		    parameter->at(i).isOrdered =
		    result->at(i).isOrdered and
		    parameter->at(i)
		    .compatibleWith(result->at(i)))

	inv synchronous_call:
		result->notEmpty() implies isSynchronous

	context uml::Actions::CallBehaviorAction

	inv no_onport:
		onPort = null

	context uml::Actions::CallOperationAction

	inv type_target_pin:
		if onPort = null
		then
		  target.type.oclAsType(uml::Classification::Classifier)
		  .allFeatures()
		  ->includes(operation)
		else
		  target.type.oclAsType(uml::Classification::Classifier)
		  .allFeatures()
		  ->includes(onPort) and
		  onPort.provided->union(onPort.required)
		  .allFeatures()
		  ->includes(operation)
		endif

	context uml::Actions::Clause

	inv body_output_pins:
		_'body'.oclAsType(uml::Actions::Action)
		.allActions()
		.output->includesAll(bodyOutput)

	inv decider_output:
		test.oclAsType(uml::Actions::Action)
		.allActions()
		.output->includes(decider) and decider.type = Boolean and
		decider.is(1, 1)

	inv test_and_body:
		test->intersection(_'body')->isEmpty()

	context uml::Actions::ClearAssociationAction

	inv multiplicity:
		object.is(1, 1)

	inv same_type:
		association.memberEnd->exists(self.object.type.conformsTo(type))

	context uml::Actions::ClearStructuralFeatureAction

	inv type_of_result:
		result <> null implies result.type = object.type

	inv multiplicity_of_result:
		result <> null implies result.is(1, 1)

	context uml::Actions::ConditionalNode

	inv result_no_incoming:
		result.incoming->isEmpty()

	inv no_input_pins:
		input->isEmpty()

	inv one_clause_with_executable_node:
		node->select(
		  oclIsKindOf(uml::Activities::ExecutableNode))
		.oclAsType(uml::Activities::ExecutableNode)
		->forAll(n |
		  self.clause->select(test->union(_'body')->includes(n))
		  ->size() = 1)

	inv matching_output_pins:
		clause->forAll(
		  bodyOutput->size() =
		  self.result->size() and
		  Sequence{1..self.result->size()
		  }
		  ->forAll(i |
		    bodyOutput->at(i)
		    .type.conformsTo(result->at(i).type) and
		    bodyOutput->at(i).isOrdered =
		    result->at(i).isOrdered and
		    bodyOutput->at(i).isUnique =
		    result->at(i).isUnique and
		    bodyOutput->at(i)
		    .compatibleWith(result->at(i))))

	inv executable_nodes:
		clause.test->union(clause._'body') =
		node->select(
		  oclIsKindOf(uml::Activities::ExecutableNode))
		.oclAsType(uml::Activities::ExecutableNode)

	inv clause_no_predecessor:
		clause->closure(predecessorClause)
		->intersection(clause)
		->isEmpty()

	context uml::Actions::CreateLinkAction

	inv association_not_abstract:
		not self.association().isAbstract

	context uml::Actions::CreateLinkObjectAction

	inv multiplicity:
		result.is(1, 1)

	inv type_of_result:
		result.type = association()

	inv association_class:
		self.association()
		.oclIsKindOf(uml::StructuredClassifiers::AssociationClass)

	context uml::Actions::CreateObjectAction

	inv classifier_not_abstract:
		not classifier.isAbstract

	inv multiplicity:
		result.is(1, 1)

	inv classifier_not_association_class:
		not classifier.oclIsKindOf(uml::StructuredClassifiers::AssociationClass)

	inv same_type:
		result.type = classifier

	context uml::Actions::DestroyObjectAction

	inv multiplicity:
		target.is(1, 1)

	inv no_type:
		target.type = null

	context uml::Actions::ExpansionNode

	inv region_as_input_or_output:
		regionAsInput->notEmpty() xor regionAsOutput->notEmpty()

	context uml::Actions::InputPin

	inv outgoing_edges_structured_only:
		outgoing->notEmpty() implies action <> null and
		action.oclIsKindOf(uml::Actions::StructuredActivityNode) and
		action.oclAsType(uml::Actions::StructuredActivityNode)
		.allOwnedNodes()
		->includesAll(outgoing.target)

	context uml::Actions::LinkAction

	inv same_pins:
		inputValue->asBag() = endData.allPins()

	inv same_association:
		endData.end = self.association().memberEnd->asBag()

	inv not_static:
		endData->forAll(not end.isStatic)

	context uml::Actions::LinkEndCreationData

	inv insertAt_pin:
		if not end.isOrdered
		then insertAt = null
		else not isReplaceAll = false implies insertAt <> null and
		  insertAt->forAll(type = UnlimitedNatural and is(1, 1))
		endif

	context uml::Actions::LinkEndData

	inv same_type:
		value <> null implies value.type.conformsTo(end.type)

	inv multiplicity:
		value <> null implies value.is(1, 1)

	inv end_object_input_pin:
		value->excludesAll(qualifier.value)

	inv property_is_association_end:
		end.association <> null

	inv qualifiers:
		end.qualifier->includesAll(qualifier.qualifier)

	context uml::Actions::LinkEndDestructionData

	inv destroyAt_pin:
		if not end.isOrdered or end.isUnique or isDestroyDuplicates
		then destroyAt = null
		else destroyAt <> null and
		  destroyAt->forAll(type = UnlimitedNatural and is(1, 1))
		endif

	context uml::Actions::LoopNode

	inv result_no_incoming:
		result.incoming->isEmpty()

	inv input_edges:
		loopVariableInput.outgoing->isEmpty()

	inv executable_nodes:
		setupPart->union(test)
		->union(bodyPart) =
		node->select(
		  oclIsKindOf(uml::Activities::ExecutableNode))
		.oclAsType(uml::Activities::ExecutableNode)
		->asSet()

	inv body_output_pins:
		bodyPart.oclAsType(uml::Actions::Action)
		.allActions()
		.output->includesAll(bodyOutput)

	inv setup_test_and_body:
		setupPart->intersection(test)
		->isEmpty() and
		setupPart->intersection(bodyPart)
		->isEmpty() and
		test->intersection(bodyPart)
		->isEmpty()

	inv matching_output_pins:
		bodyOutput->size() =
		loopVariable->size() and
		Sequence{1..loopVariable->size()
		}
		->forAll(i |
		  bodyOutput->at(i)
		  .type.conformsTo(loopVariable->at(i).type) and
		  bodyOutput->at(i).isOrdered =
		  loopVariable->at(i).isOrdered and
		  bodyOutput->at(i).isUnique =
		  loopVariable->at(i).isUnique and
		  loopVariable->at(i)
		  .includesMultiplicity(bodyOutput->at(i)))

	inv matching_loop_variables:
		loopVariableInput->size() =
		loopVariable->size() and loopVariableInput.type = loopVariable.type and loopVariableInput.isUnique = loopVariable.isUnique and loopVariableInput.lower = loopVariable.lower and loopVariableInput.upper = loopVariable.upper

	inv matching_result_pins:
		result->size() =
		loopVariable->size() and result.type = loopVariable.type and result.isUnique = loopVariable.isUnique and result.lower = loopVariable.lower and result.upper = loopVariable.upper

	inv loop_variable_outgoing:
		allOwnedNodes()
		->includesAll(loopVariable.outgoing.target)

	context uml::Actions::OpaqueAction

	inv language_body_size:
		language->notEmpty() implies _'body'->size() = language->size()

	context uml::Actions::OutputPin

	inv incoming_edges_structured_only:
		incoming->notEmpty() implies action <> null and
		action.oclIsKindOf(uml::Actions::StructuredActivityNode) and
		action.oclAsType(uml::Actions::StructuredActivityNode)
		.allOwnedNodes()
		->includesAll(incoming.source)

	context uml::Actions::Pin

	inv control_pins:
		isControl implies isControlType

	inv not_unique:
		not isUnique

	context uml::Actions::QualifierValue

	inv multiplicity_of_qualifier:
		value.is(1, 1)

	inv type_of_qualifier:
		value.type.conformsTo(qualifier.type)

	inv qualifier_attribute:
		linkEndData.end.qualifier->includes(qualifier)

	context uml::Actions::ReadExtentAction

	inv type_is_classifier:
		result.type = classifier

	inv multiplicity_of_result:
		result.is(0, *)

	context uml::Actions::ReadIsClassifiedObjectAction

	inv no_type:
		object.type = null

	inv multiplicity_of_output:
		result.is(1, 1)

	inv boolean_result:
		result.type = Boolean

	inv multiplicity_of_input:
		object.is(1, 1)

	context uml::Actions::ReadLinkAction

	inv type_and_ordering:
		self.openEnd()
		->forAll(type = result.type and isOrdered = result.isOrdered)

	inv compatible_multiplicity:
		self.openEnd()->first().compatibleWith(result)

	inv visibility:
		let openEnd : uml::Classification::Property = self.openEnd()->first()
		in openEnd.visibility = UML::CommonStructure::VisibilityKind::public or
		  endData->exists(oed | oed.end <> openEnd and
		    (_'context' = oed.end.type or openEnd.visibility = UML::CommonStructure::VisibilityKind::protected and
		      _'context'.conformsTo(
		        oed.end.type.oclAsType(uml::Classification::Classifier))
		    ))

	inv one_open_end:
		self.openEnd()->size() = 1

	inv navigable_open_end:
		self.openEnd()->first().isNavigable()

	context uml::Actions::ReadLinkObjectEndAction

	inv property:
		end.association <> null

	inv multiplicity_of_object:
		object.is(1, 1)

	inv ends_of_association:
		end.association.memberEnd->forAll(e | not e.isStatic)

	inv type_of_result:
		result.type = end.type

	inv multiplicity_of_result:
		result.is(1, 1)

	inv type_of_object:
		object.type = end.association

	inv association_of_association:
		end.association.oclIsKindOf(uml::StructuredClassifiers::AssociationClass)

	context uml::Actions::ReadLinkObjectEndQualifierAction

	inv multiplicity_of_object:
		object.is(1, 1)

	inv type_of_object:
		object.type = qualifier.associationEnd.association

	inv multiplicity_of_qualifier:
		qualifier.is(1, 1)

	inv ends_of_association:
		qualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic)

	inv multiplicity_of_result:
		result.is(1, 1)

	inv same_type:
		result.type = qualifier.type

	inv association_of_association:
		qualifier.associationEnd.association.oclIsKindOf(uml::StructuredClassifiers::AssociationClass)

	inv qualifier_attribute:
		qualifier.associationEnd <> null

	context uml::Actions::ReadSelfAction

	inv contained:
		_'context' <> null

	inv multiplicity:
		result.is(1, 1)

	inv not_static:
		let behavior : uml::CommonBehavior::Behavior = self.containingBehavior()
		in behavior.specification <> null implies not behavior.specification.isStatic

	inv type:
		result.type = _'context'

	context uml::Actions::ReadStructuralFeatureAction

	inv multiplicity:
		structuralFeature.compatibleWith(result)

	inv type_and_ordering:
		result.type = structuralFeature.type and result.isOrdered = structuralFeature.isOrdered

	context uml::Actions::ReadVariableAction

	inv type_and_ordering:
		result.type = variable.type and result.isOrdered = variable.isOrdered

	inv compatible_multiplicity:
		variable.compatibleWith(result)

	context uml::Actions::ReclassifyObjectAction

	inv input_pin:
		object.type = null

	inv classifier_not_abstract:
		not newClassifier->exists(isAbstract)

	inv multiplicity:
		object.is(1, 1)

	context uml::Actions::ReduceAction

	inv reducer_inputs_output:
		let
		  inputs : OrderedSet(UML::Classification::Parameter) = reducer.inputParameters()
		in
		  let
		    outputs : OrderedSet(UML::Classification::Parameter) = reducer.outputParameters()
		  in
		    inputs->size() = 2 and
		    outputs->size() = 1 and
		    inputs.type->forAll(t |
		      (
		        outputs.type->forAll(conformsTo(t)) and
		        collection.upperBound() > 1 implies
		        collection.type.conformsTo(t)
		      ))

	inv input_type_is_collection:
		null

	inv output_types_are_compatible:
		reducer.outputParameters()
		.type->forAll(conformsTo(result.type))

	context uml::Actions::RemoveStructuralFeatureValueAction

	inv removeAt_and_value:
		if structuralFeature.isOrdered and not structuralFeature.isUnique and not isRemoveDuplicates
		then value = null and removeAt <> null and removeAt.type = UnlimitedNatural and
		  removeAt.is(1, 1)
		else removeAt = null and value <> null
		endif

	context uml::Actions::RemoveVariableValueAction

	inv removeAt_and_value:
		if variable.isOrdered and not variable.isUnique and not isRemoveDuplicates
		then value = null and removeAt <> null and removeAt.type = UnlimitedNatural and
		  removeAt.is(1, 1)
		else removeAt = null and value <> null
		endif

	context uml::Actions::ReplyAction

	inv pins_match_parameter:
		let
		  parameter : OrderedSet(UML::Classification::Parameter) = replyToCall.event.oclAsType(uml::CommonBehavior::CallEvent)
		  .operation.outputParameters()
		in
		  replyValue->size() =
		  parameter->size() and
		  Sequence{1..replyValue->size()
		  }
		  ->forAll(i |
		    replyValue->at(i)
		    .type.conformsTo(parameter->at(i).type) and
		    replyValue->at(i).isOrdered =
		    parameter->at(i).isOrdered and
		    replyValue->at(i)
		    .compatibleWith(parameter->at(i)))

	inv event_on_reply_to_call_trigger:
		replyToCall.event.oclIsKindOf(uml::CommonBehavior::CallEvent)

	context uml::Actions::SendObjectAction

	inv type_target_pin:
		onPort <> null implies
		target.type.oclAsType(uml::Classification::Classifier)
		.allFeatures()
		->includes(onPort)

	context uml::Actions::SendSignalAction

	inv type_ordering_multiplicity:
		let
		  attribute : OrderedSet(UML::Classification::Property) = signal.allAttributes()
		in
		  Sequence{1..argument->size()
		  }
		  ->forAll(i |
		    argument->at(i)
		    .type.conformsTo(attribute->at(i).type) and
		    argument->at(i).isOrdered =
		    attribute->at(i).isOrdered and
		    argument->at(i)
		    .compatibleWith(attribute->at(i)))

	inv number_order:
		argument->size() = signal.allAttributes()->size()

	inv type_target_pin:
		not onPort->isEmpty() implies
		target.type.oclAsType(uml::Classification::Classifier)
		.allFeatures()
		->includes(onPort)

	context uml::Actions::StartClassifierBehaviorAction

	inv multiplicity:
		object.is(1, 1)

	inv type_has_classifier:
		object.type->notEmpty() implies
		object.type.oclIsKindOf(uml::SimpleClassifiers::BehavioredClassifier) and
		object.type.oclAsType(uml::SimpleClassifiers::BehavioredClassifier).classifierBehavior <> null

	context uml::Actions::StartObjectBehaviorAction

	inv multiplicity_of_object:
		object.is(1, 1)

	inv type_of_object:
		self.behavior() <> null

	inv no_onport:
		onPort->isEmpty()

	context uml::Actions::StructuralFeatureAction

	inv multiplicity:
		object.is(1, 1)

	inv object_type:
		object.type.oclAsType(uml::Classification::Classifier)
		.allFeatures()
		->includes(structuralFeature) or
		object.type.conformsTo(
		  structuralFeature.oclAsType(uml::Classification::Property).opposite.type)

	inv visibility:
		structuralFeature.visibility = UML::CommonStructure::VisibilityKind::public or
		_'context'.allFeatures()
		->includes(structuralFeature) or structuralFeature.visibility = UML::CommonStructure::VisibilityKind::protected and
		_'context'.conformsTo(
		  structuralFeature.oclAsType(uml::Classification::Property)
		  .opposite.type.oclAsType(uml::Classification::Classifier))

	inv not_static:
		not structuralFeature.isStatic

	inv one_featuring_classifier:
		structuralFeature.featuringClassifier->size() = 1

	context uml::Actions::StructuredActivityNode

	inv output_pin_edges:
		output.outgoing.target->excludesAll(allOwnedNodes() - input)

	inv edges:
		edge =
		self.sourceNodes()
		.outgoing->intersection(self.allOwnedNodes().incoming)
		->union(
		  self.targetNodes()
		  .incoming->intersection(self.allOwnedNodes().outgoing))
		->asSet()

	inv input_pin_edges:
		input.incoming.source->excludesAll(allOwnedNodes() - output)

	context uml::Actions::TestIdentityAction

	inv multiplicity:
		first.is(1, 1) and second.is(1, 1)

	inv no_type:
		first.type = null and second.type = null

	inv result_is_boolean:
		result.type = Boolean

	context uml::Actions::UnmarshallAction

	inv structural_feature:
		unmarshallType.allAttributes()->size() >= 1

	inv number_of_result:
		unmarshallType.allAttributes()->size() = result->size()

	inv type_ordering_and_multiplicity:
		let
		  attribute : OrderedSet(UML::Classification::Property) = unmarshallType.allAttributes()
		in
		  Sequence{1..result->size()
		  }
		  ->forAll(i |
		    attribute->at(i)
		    .type.conformsTo(result->at(i).type) and
		    attribute->at(i).isOrdered =
		    result->at(i).isOrdered and
		    attribute->at(i)
		    .compatibleWith(result->at(i)))

	inv multiplicity_of_object:
		object.is(1, 1)

	inv object_type:
		object.type.conformsTo(unmarshallType)

	context uml::Actions::ValuePin

	inv no_incoming_edges:
		incoming->isEmpty()

	inv compatible_type:
		value.type.conformsTo(type)

endpackage