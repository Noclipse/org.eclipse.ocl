/**
This clause describes the OCL Standard Library of predefined types, their operations, and predefined expression templates in the OCL.
This sub clause contains all standard types defined within OCL, including all the operations defined on those types.
For each operation the signature and a description of the semantics is given.
Within the description, the reserved word ‘result’ is used to refer to the value that results from evaluating the operation.
In several places, post conditions are used to describe properties of the result.
When there is more than one postcondition, all postconditions must be true.
A similar thing is true for multiple preconditions.
If these are used, the operation is only defined if all preconditions evaluate to oclText[true].

heading:1[Introduction]

The structure, syntax, and semantics of the OCL is defined in Clauses 8 (“Abstract Syntax”), 9 (“Concrete Syntax”),
and 10 (“Semantics Described using UML”).
This sub clause adds another part to the OCL definition: a library of predefined types and operations.
Any implementation of OCL must include this library package. This approach has also been taken by e.g., the Java definition,
where the language definition and the standard libraries are both mandatory parts of the complete language definition.

The OCL standard library defines a number of types.
It includes several primitive types: UnlimitedNatural, Integer, Real, String, and Boolean.
These are familiar from many other languages. The second part of the standard library consists of the collection types.
They are Bag, Set, Sequence, and Collection where Collection is an abstract type.
Note that all types defined in the OCL standard library are instances of an abstract syntax class.
The OCL standard library exists at the modeling level, also referred to as the M1 level, where the abstract syntax is the metalevel or M2 level.

Next to definitions of types the OCL standard library defines a number of template expressions.
Many operations defined on collections map not on the abstract syntax metaclass FeatureCallExp, but on the IteratorExp.
For each of these a template expression that defines the name and format of the expression is defined in 11.8, Predefined Iterator Expressions.

The Standard Library may be extended with new types, new operations and new iterators.
In particular new operations can be defined for collections.

Certain String operations depend on the prevailing locale to ensure that Strings are collated and characters are case-converted
in an appropriate fashion.
A locale is defined as a concatenation of up to three character sequences separated by underscores,
with the first sequence identifying the language and the second sequence identifying the country.
The third sequence is empty but may encode an implementation-specific variant.
Trailing empty strings and separators may be omitted.

The character sequences for languages are defined by ISO 639.

The character sequences for countries are defined by ISO 3166.

‘fr_CA’ therefore identifies the locale for the French language in the Canada country.

Comparison of strings and consequently the collation order of Collection::sortedBy()
conforms to the Unicode Collation algorithm defined by Unicode Technical Standard#10.

The locale is ‘en_us’ by default but may be configured by a property constraint on OclAny::oclLocale.

The prevailing locale is defined by the prevailing value of oclLocale within the current environment;
it may therefore be changed temporarily by using a Let expression.
let oclLocale : String = ‘fr_CA’ in aString.toUpperCase()

heading:1[Iterators]

This sub clause defines the standard OCL iterator expressions.
In the abstract syntax these are all instances of IteratorExp.
These iterator expressions always have a collection expression as their source,
as is defined in the well-formedness rules in Clause 8 (“Abstract Syntax”).
The defined iterator expressions are shown per source collection type.
The semantics of each iterator expression is defined through a mapping from the iterator to the ‘iterate’ construct.
This means that the semantics of the iterator expressions do not need to be defined separately in the semantics sub clauses. 

In all of the following OCL expressions, the lefthand side of the equals sign is the IteratorExp to be defined,
and the righthand side of the equals sign is the equivalent as an IterateExp.
The names source, body, and iterator refer to the role names in the abstract syntax:

source	The source expression of the IteratorExp.

body	The body expression of the IteratorExp.

iterator	The iterator variable of the IteratorExp.

result	The result variable of the IterateExp.

heading:2[Extending the Standard Library with Iterator Expressions]

It is possible to add new iterator expressions in the standard library.
If this is done the semantics of a new iterator should be defined by mapping it to existing constructs,
in the same way the semantics of pre-defined iterators is done (see sub clause 11.9)

**/
library ocl : ocl = 'http://www.eclipse.org/ocl/3.1.0/OCL.oclstdlib'
{
precedence left:NAVIGATION left:UNARY left:MULTIPLICATIVE left:ADDITIVE left:RELATIONAL left:EQUALITY left:AND left:OR left:XOR left:IMPLIES;

annotation 'http://www.omg.org/ocl'(
	PackageRole='StandardLibrary',
	ClassGroup_Collection='This sub clause defines the collection types and their operations. As defined in this sub clause, each collection type is actually a template type with one parameter. ‘T’ denotes the parameter. A concrete collection type is created by substituting a type for the T. So Set (Integer) and Bag (Person) are collection types.',
	ClassGroup_PrimitiveTypes='The primitive types defined in the OCL standard library are UnlimitedNatural, Integer, Real, String, and Boolean. They are all instances of the metaclass Primitive from the UML core package.'
);

type AnyClassifier<T> : ClassifierType conformsTo Class, OclType {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
}

/**
A bag is a collection with duplicates allowed. That is, one object can be an element of a bag many times.
There is no ordering defined on the elements in a bag.
Bag is itself an instance of the metatype BagType.
**/
type Bag<T> : BagType conformsTo Collection<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Collection');
	/**
	The closure of applying body transitively to every distinct element of the source collection.
	**/
	iteration closure(i : T | body : Lambda T() : Set<T>) : Set<T> => 'org.eclipse.ocl.examples.library.iterator.ClosureIteration';
	iteration collect<V>(i : T | body : Lambda T() : V) : Bag<V> => 'org.eclipse.ocl.examples.library.iterator.CollectIteration';
	/**
	The Bag of elements which results from applying body to every member of the source nonordered collection.
	**/
	iteration collectNested<V>(i : T | body : Lambda T() : V) : Bag<T> => 'org.eclipse.ocl.examples.library.iterator.CollectNestedIteration';
	/**
	The sub-bag of the source bag for which body is oclText[false].
	
	oclCode[self->reject(iterator | body) = self->select(iterator | not body)].	
	**/
	iteration reject(i : T | body : Lambda T() : Boolean) : Bag<T> => 'org.eclipse.ocl.examples.library.iterator.RejectIteration';
	/**
	The sub-bag of the source bag for which body is oclText[true].

	oclCode[self->select(iterator | body) =
        self->iterate(iterator; result : Bag<T> = Bag{} |
                        if body then result->including(iterator)
                                else result
                        endif)]
	**/
	iteration select(i : T | body : Lambda T() : Boolean) : Bag<T> => 'org.eclipse.ocl.examples.library.iterator.SelectIteration';
	/**
	Results in the Sequence containing all elements of the source collection.
	The element for which body has the lowest value comes first, and so on.
	The type of the body expression must have the < operation defined.
	The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c then a < c).
	**/
	iteration sortedBy(i : T | body : Lambda T() : OclAny) : Sequence<T> => 'org.eclipse.ocl.examples.library.iterator.SortedByIteration';
	/**
	True if oclText[self] and bag contain the same elements, the same number of times.
	**/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The bag containing all elements of oclText[self] apart from all occurrences of object.
	**/
	operation excluding(object : OclAny) : Bag<T> => 'org.eclipse.ocl.examples.library.collection.CollectionExcludingOperation';
	/**
	Redefines the Collection operation. If the element type is not a collection type, this results in the same bag as oclText[self].
	If the element type is a collection type, the result is the bag containing all the elements of all the recursively flattened elements of oclText[self]. 
	**/
	operation flatten<T2>() : Bag<T2> => 'org.eclipse.ocl.examples.library.collection.CollectionFlattenOperation';
	/**
	The bag containing all elements of oclText[self] plus object.
	**/
	operation including(object : T) : Bag<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIncludingOperation';
	/**
	The intersection of oclText[self] and bag; the bag of all elements that are in both oclText[self] and s.
	**/
	operation intersection(bag : Collection<T>) : Bag<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIntersectionOperation';
	/**
	The intersection of oclText[self] and s; the set of all elements that are in both oclText[self] and s.
	**/
	operation intersection(s : UniqueCollection<T>) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIntersectionOperation';
	operation selectByKind<TT>(type : AnyClassifier<TT>) : Bag<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByKindOperation';
	operation selectByType<TT>(type : AnyClassifier<TT>) : Bag<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByTypeOperation';
	/**
	The union of oclText[self] and bag; the bag of all elements that are in oclText[self] and all elements that are in bag.
	**/
	operation union(bag : Collection<T>) : Bag<T> => 'org.eclipse.ocl.examples.library.collection.CollectionUnionOperation';
	/**
	The union of oclText[self] and s; the set of all elements that are in oclText[self] and all elements that are in s.
	**/
	operation union(s : UniqueCollection<T>) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionUnionOperation';
}

/**
The standard type Boolean represents the common true/false values.
Boolean is itself an instance of the metatype PrimitiveType (from UML).
**/
type Boolean : PrimitiveType conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Primitive');
	/**
	Returns oclText[true] if the logical value of oclText[self] is the same as the numeric value of object2, oclText[false] otherwise.
	*/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	/**
	Returns oclText[true] if the logical value of oclText[self] is the not same as the numeric value of object2, oclText[false] otherwise.
	*/
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	Returns oclText[Set{false, true}].
	*/
	static operation allInstances() : Set<OclSelf> => 'org.eclipse.ocl.examples.library.logical.BooleanAllInstancesOperation';
	/**
	True if both b1 and b are oclText[true].
	**/
	operation and(b : Boolean) : Boolean precedence=AND => 'org.eclipse.ocl.examples.library.logical.BooleanAndOperation';
	/**
	True if oclText[self] is oclText[false], or if oclText[self] is oclText[true] and b is oclText[true].
	**/
	operation implies(b : Boolean) : Boolean precedence=IMPLIES => 'org.eclipse.ocl.examples.library.logical.BooleanImpliesOperation';
	/**
	True if oclText[self] is oclText[false].
	**/
	operation not() : Boolean precedence=UNARY => 'org.eclipse.ocl.examples.library.logical.BooleanNotOperation';
	/**
	True if either oclText[self] or b is oclText[true].
	**/
	operation or(b : Boolean) : Boolean precedence=OR => 'org.eclipse.ocl.examples.library.logical.BooleanOrOperation';
	/**
	Converts oclText[self] to a string value.
	**/
	operation toString() : String => 'org.eclipse.ocl.examples.library.oclany.OclAnyToStringOperation';
	/**
	True if either oclText[self] or b is oclText[true], but not both.
	**/
	operation xor(b : Boolean) : Boolean precedence=XOR => 'org.eclipse.ocl.examples.library.logical.BooleanXorOperation';
}

type Class conformsTo OclAny {
	/**
	Evaluates to the type of which self is an instance.
	**/
	operation oclType() : ClassClassifier<OclSelf> => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclTypeOperation';	
}

type ClassClassifier<T> : ClassifierType conformsTo AnyClassifier<T> {}

/**
Collection is the abstract supertype of all collection types in the OCL Standard Library.
Each occurrence of an object in a collection is called an element.
If an object occurs twice in a collection, there are two elements.

This sub clause defines the properties on Collections that have identical semantics for all collection subtypes.
Some operations may be defined within the subtype as well,
which means that there is an additional postcondition or a more specialized return value.
Collection is itself an instance of the metatype CollectionType.

The definition of several common operations is different for each subtype.
These operations are not mentioned in this sub clause.

The semantics of the collection operations is given in the form of a postcondition that uses the IterateExp of the IteratorExp construct.
The semantics of those constructs is defined in Clause 10 (“Semantics Described using UML”).
In several cases the postcondition refers to other collection operations,
which in turn are defined in terms of the IterateExp or IteratorExp constructs.

Well-formedness rules

[1] A collection cannot contain oclText[invalid] values.

	context Collection
	inv: self->forAll(not oclIsInvalid())
*/
type Collection<T> : CollectionType conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Collection');
	/**
	Returns any element in the source collection for which body evaluates to oclText[true].
	If there is more than one element for which body is oclText[true], one of them is returned.
	There must be at least one element fulfilling body, otherwise the result of this IteratorExp is oclText[null].
	**/
	iteration any(i : T | body : Lambda T() : Boolean) : T => 'org.eclipse.ocl.examples.library.iterator.AnyIteration';
	/**
	The Collection of elements that results from applying body to every member of the source set.
	The result is flattened. Notice that this is based on collectNested, which can be of different type depending on the type of source.
	collectNested is defined individually for each subclass of CollectionType.
	**/
	iteration collect<V>(i : T | body : Lambda T() : V) : Collection<V> => 'org.eclipse.ocl.examples.library.iterator.CollectIteration';
	/**
	The Collection of elements which results from applying body to every member of the source collection.
	**/
	iteration collectNested<V>(i : T | body : Lambda T() : V) : Collection<T> => 'org.eclipse.ocl.examples.library.iterator.CollectNestedIteration';
	/**
	Results in oclText[true] if body evaluates to oclText[true] for at least one element in the source collection.
	**/
	iteration exists(i : T | body : Lambda T() : Boolean) : Boolean => 'org.eclipse.ocl.examples.library.iterator.ExistsIteration';
	iteration exists(i : T, j : T | body : Lambda T() : Boolean) : Boolean => 'org.eclipse.ocl.examples.library.iterator.ExistsIteration';
	/**
	Results in oclText[true] if the body expression evaluates to oclText[true] for each element in the source collection; otherwise, result is oclText[false].
	**/
	iteration forAll(i : T | body : Lambda T() : Boolean) : Boolean => 'org.eclipse.ocl.examples.library.iterator.ForAllIteration';
	iteration forAll(i : T, j : T | body : Lambda T() : Boolean) : Boolean => 'org.eclipse.ocl.examples.library.iterator.ForAllIteration';
	/**
	Results in oclText[true] if body evaluates to a different value for each element in the source collection; otherwise, result is oclText[false].
	**/
	iteration isUnique(i : T | body : Lambda T() : OclAny) : Boolean => 'org.eclipse.ocl.examples.library.iterator.IsUniqueIteration';
	iteration iterate<Tacc>(i : T; acc : Tacc | body : Lambda T() : Tacc) : Tacc => 'org.eclipse.ocl.examples.library.iterator.IterateIteration';
	/**
	Results in oclText[true] if there is exactly one element in the source collection for which body is oclText[true].
	**/
	iteration one(i : T | body : Lambda T() : Boolean) : Boolean => 'org.eclipse.ocl.examples.library.iterator.OneIteration';
	/**
	The sub-collection of the source collection for which body is oclText[false].
	**/
	iteration reject(i : T | body : Lambda T() : Boolean) : Collection<T> => 'org.eclipse.ocl.examples.library.iterator.RejectIteration';
	/**
	The sub-collection of the source collection for which body is oclText[true].
	**/
	iteration select(i : T | body : Lambda T() : Boolean) : Collection<T> => 'org.eclipse.ocl.examples.library.iterator.SelectIteration';
	/**
	Results in the Collection containing all elements of the source collection.
	The element for which body has the lowest value comes first, and so on.
	The type of the body expression must have the < operation defined.
	The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c then a < c).
	**/
	iteration sortedBy(i : T | body : Lambda T() : OclAny) : Sequence<T> => 'org.eclipse.ocl.examples.library.iterator.SortedByIteration';
	/**
	True if c is a collection of the same kind as oclText[self] and contains the same elements in the same quantities and in the same order,
	in the case of an ordered collection type.
	**/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	/**
	True if c is not equal to oclText[self].
	**/
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The Bag that contains all the elements from oclText[self]. 
	**/
	operation asBag() : Bag<T> => 'org.eclipse.ocl.examples.library.collection.CollectionAsBagOperation';
	/**
	An OrderedSet that contains all the elements from oclText[self], with duplicates removed,
	in an order dependent on the particular concrete collection type.
	**/
	operation asOrderedSet() : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.CollectionAsOrderedSetOperation';
	/**
	A Sequence that contains all the elements from oclText[self], in an order dependent on the particular concrete collection type. 
	**/
	operation asSequence() : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.CollectionAsSequenceOperation';
	/**
	The Set containing all the elements from oclText[self], with duplicates removed.
	**/
	operation asSet() : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionAsSetOperation';
	/**
	The number of times that object occurs in the collection oclText[self].
	**/
	operation count(object : OclAny) : Integer => 'org.eclipse.ocl.examples.library.collection.CollectionCountOperation';
	/**
	True if object is not an element of oclText[self], oclText[false] otherwise.
	**/
	operation excludes(object : OclAny) : Boolean => 'org.eclipse.ocl.examples.library.collection.CollectionExcludesOperation';
	/**
	Does oclText[self] contain none of the elements of c2 ?
	**/
	operation excludesAll<T2>(c2 : Collection<T2>) : Boolean => 'org.eclipse.ocl.examples.library.collection.CollectionExcludesAllOperation';
	/**
	The collection containing all elements of oclText[self] apart from object.
	**/
	operation excluding(object : OclAny) : Collection<T> => 'org.eclipse.ocl.examples.library.collection.CollectionExcludingOperation';
	/**
	If the element type is not a collection type, this results in the same collection as oclText[self].
	If the element type is a collection type, the result is a collection containing all the elements of all the recursively flattened elements of oclText[self].
	**/
	operation flatten<T2>() : Collection<T2> => 'org.eclipse.ocl.examples.library.collection.CollectionFlattenOperation';
	/**
	True if object is an element of oclText[self], oclText[false] otherwise.
	**/
	operation includes(object : OclAny) : Boolean => 'org.eclipse.ocl.examples.library.collection.CollectionIncludesOperation';
	/**
	Does oclText[self] contain all the elements of c2 ?
	**/
	operation includesAll<T2>(c2 : Collection<T2>) : Boolean => 'org.eclipse.ocl.examples.library.collection.CollectionIncludesAllOperation';
	/**
	The collection containing all elements of oclText[self] plus object.
	**/
	operation including(object : T) : Collection<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIncludingOperation';
	/**
	Is oclText[self] the empty collection?

	Note: oclText[null->isEmpty()] returns oclText[true] in virtue of the implicit casting from oclText[null] to oclText[Bag{}].
	**/
	operation isEmpty() : Boolean => 'org.eclipse.ocl.examples.library.collection.CollectionIsEmptyOperation';
	/**
	The element with the maximum value of all elements in oclText[self].
	Elements must be of a type supporting the max operation.
	The max operation - supported by the elements - must take one parameter of type T and be both associative and commutative.
	UnlimitedNatural, Integer and Real fulfill this condition.
	**/
	operation max() : T => 'org.eclipse.ocl.examples.library.collection.CollectionMaxOperation';
	/**
	The element with the minimum value of all elements in oclText[self].
	Elements must be of a type supporting the min operation.
	The min operation - supported by the elements - must take one parameter of type T and be both associative and commutative.
	UnlimitedNatural, Integer and Real fulfill this condition.
	**/
	operation min() : T => 'org.eclipse.ocl.examples.library.collection.CollectionMinOperation';
	/**
	Is oclText[self] not the empty collection?
	
	oclText[null->notEmpty()] returns oclText[false] in virtue of the implicit casting from oclText[null] to oclText[Bag{}].
	**/
	operation notEmpty() : Boolean => 'org.eclipse.ocl.examples.library.collection.CollectionNotEmptyOperation';
	/**
	Evaluates to the type of which oclText[self] is an instance.
	**/
	operation oclType() : CollectionClassifier<OclSelf,T> => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclTypeOperation';
	/**
	The cartesian product operation of oclText[self] and c2.
	**/
	operation product<T2>(c2 : Collection<T2>) : Set<Tuple<first:T,second:T2>> => 'org.eclipse.ocl.examples.library.collection.CollectionProductOperation';
	operation selectByKind<TT>(type : AnyClassifier<TT>) : Collection<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByKindOperation';
	operation selectByType<TT>(type : AnyClassifier<TT>) : Collection<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByTypeOperation';
	/**
	The number of elements in the collection oclText[self].
	**/
	operation size() : Integer => 'org.eclipse.ocl.examples.library.collection.CollectionSizeOperation';
	/**
	The addition of all elements in oclText[self].
	Elements must be of an oclText[OclSummable] type to provide the zero() and sum() operations.
	The e[sum] operation must be both associative: a.sum(b).sum(c) = a.sum(b.sum(c)), and commutative: a.sum(b) = b.sum(a).
	UnlimitedNatural, Integer and Real fulfill this condition.

	If the e[sum] operation is not both associative and commutative, the e[sum] expression is not well-formed,
	which may result in unpredictable results during evaluation.
	If an implementation is able to detect a lack of associativity or commutativity,
	the implementation may bypass the evaluation and return an oclText[invalid] result.
	**/
	operation sum() : T => 'org.eclipse.ocl.examples.library.collection.CollectionSumOperation';
--	operation "->"<T>(object2 : OclAny) : T precedence=NAVIGATION => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation';
}

type CollectionClassifier<T,E> : ClassifierType conformsTo AnyClassifier<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Evaluates to the type of the collection elements.
	**/
	property elementType : E => 'org.eclipse.ocl.examples.library.collection.CollectionClassifierElementTypeProperty';
}

/**
 The Enumeration type is the type of an OrderedSet of EnumerationLiteral.
 **/
type Enumeration conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='UML');
	/**
	Return a set of all enumeration values of oclText[self].
	*/
	static operation allInstances() : Set<OclSelf> => 'org.eclipse.ocl.examples.library.enumeration.EnumerationAllInstancesOperation';
	/**
	Evaluates to the type of which oclText[self] is an instance.
	**/
	operation oclType() : EnumerationClassifier<OclSelf> => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclTypeOperation';
}

/**
 The standard type EnumerationClassifier represents the metatype of an Enumeration.
 **/
type EnumerationClassifier<T> : ClassifierType conformsTo AnyClassifier<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Evaluates to the literals of the enumeration.
	**/
	property ownedLiteral : OrderedSet<EnumerationLiteral> => 'org.eclipse.ocl.examples.library.enumeration.EnumerationClassifierOwnedLiteralProperty';
}

/**
 The standard type EnumerationLiteral represents a named constant value of an Enumeration.
 **/
type EnumerationLiteral conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='UML');
}

/**
The standard type Integer represents the mathematical concept of integer.
Note that UnlimitedNatural is a subclass of Integer, so for each parameter of type Integer,
you can use an unlimited natural as the actual parameter.
Integer is itself an instance of the metatype PrimitiveType (from UML).
**/
type Integer : PrimitiveType conformsTo Real {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Primitive');
	/**
	The negative value of oclText[self].
	**/
	operation "-"() : Integer precedence=UNARY => 'org.eclipse.ocl.examples.library.numeric.NumericNegateOperation';
	/**
	The value of the addition of oclText[self] and i.
	**/
	operation "+"(i : OclSelf) : Integer precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.integer.IntegerPlusOperation';
	/**
	The value of the subtraction of i from oclText[self].
	**/
	operation "-"(i : OclSelf) : Integer precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.integer.IntegerMinusOperation';
	/**
	The value of the multiplication of oclText[self] and i.
	**/
	operation "*"(i : OclSelf) : Integer precedence=MULTIPLICATIVE => 'org.eclipse.ocl.examples.library.numeric.NumericTimesOperation';
	/**
	The value of oclText[self] divided by i.
	Evaluates to oclText[invalid] if r is equal to zero.
	**/
	operation "/"(i : OclSelf) : Real precedence=MULTIPLICATIVE => 'org.eclipse.ocl.examples.library.numeric.NumericDivideOperation';
	/**
	The absolute value of oclText[self].
	**/
	operation abs() : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericAbsOperation';
	/**
	The comparison of oclText[self] with oclText[that]. -ve if less than, 0 if equal, +ve if greater than.
	**/ 
	operation compareTo(that : OclSelf) : Integer  => 'org.eclipse.ocl.examples.library.integer.IntegerCompareToOperation';	
	/**
	The number of times that i fits completely within oclText[self].
	**/
	operation div(i : Integer) : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericDivOperation';
	/**
	The result is oclText[self] modulo i.
	**/
	operation mod(i : Integer) : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericModOperation';
	/**
	The maximum of oclText[self] an i.
	**/
	operation max(i : OclSelf) : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericMaxOperation';
	/**
	The minimum of oclText[self] an i.
	**/
	operation min(i : OclSelf) : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericMinOperation';
	/**
	Converts oclText[self] to a string value.
	**/
	operation toString() : String => 'org.eclipse.ocl.examples.library.oclany.OclAnyToStringOperation';
}

/**
All types in the UML model and the primitive and collection types in the OCL standard library conforms to the type OclAny.
Conceptually, OclAny behaves as a supertype for all the types.
Features of OclAny are available on each object in all OCL expressions.
OclAny is itself an instance of the metatype AnyType.

All classes in a UML model inherit all operations defined on OclAny.
To avoid name conflicts between properties in the model and the properties inherited from OclAny,
all names on the properties of OclAny start with ‘ocl.’
Although theoretically there may still be name conflicts, they can be avoided. 
One can also use qualification by OclAny (name of the type) to explicitly refer to the OclAny properties.

Operations of OclAny, where the instance of OclAny is called object.
**/
type OclAny : AnyType {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	True if oclText[self] is the same object as object2. Infix operator.
	**/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation'
	{
		post: result = (self = object2);		
	}
	/**
	True if oclText[self] is a different object from object2. Infix operator.
	**/
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation'
	{
		post: result = not (self = object2);
	}
	/**
	Returns a Set with oclText[self] as the sole content, unless oclText[self] is oclText[null] in which case returns an empty set,
	*/
	operation oclAsSet() : Set<OclSelf> => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclAsSetOperation';
	/**
	Evaluates to oclText[self], where oclText[self] is of the type identified by T.
	The type T may be any classifier defined in the UML model;
	if the actual type of oclText[self] at evaluation time does not conform to T,
	then the oclAsType operation evaluates to oclText[invalid].

	In the case of feature redefinition, casting an object to a supertype of its actual type
	does not access the supertype’s definition of the feature;
	according to the semantics of redefinition, the redefined feature simply does not exist for the object.
	However, when casting to a supertype, any features additionally defined by the subtype are suppressed.
	
	**/
	operation oclAsType<TT>(type : AnyClassifier<TT>) : TT => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclAsTypeOperation'
	{
		post IsSelf: result = self;
		post IsType: result.oclIsTypeOf(type);
	}
	/**
	Evaluates to oclText[true] if the oclText[self] is in the state indentified by statespec. 
	**/
	operation oclIsInState(statespec : OclState) : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclIsInStateOperation';
	/**
	Evaluates to oclText[true] if the oclText[self] is equal to OclInvalid.
	**/
	operation oclIsInvalid() : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclIsInvalidOperation'
	{
		post: result = self.oclIsTypeOf(OclInvalid);
	}
	/**
	Evaluates to oclText[true] if the type of oclText[self] conforms to t.
	That is, oclText[self] is of type t or a subtype of t. 
	**/
	operation oclIsKindOf<T>(type : AnyClassifier<T>) : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclIsKindOfOperation';
	/**
	Can only be used in a postcondition.
	Evaluates to oclText[true] if the oclText[self] is created during performing the operation (for instance, it didn’t exist at precondition time). 
	**/
	operation oclIsNew() : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation'
	{
--		post: self@pre.oclIsUndefined();
	}
	/**
	Evaluates to oclText[true] if oclText[self] is of the type t but not a subtype of t 
	*/
	operation oclIsTypeOf<T>(type : AnyClassifier<T>) : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclIsTypeOfOperation';
	/**
	Evaluates to oclText[true] if the oclText[self] is equal to oclText[invalid] or equal to oclText[null]. 
	**/
	operation oclIsUndefined() : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclIsUndefinedOperation'
	{
		post: result = self.oclIsTypeOf( OclVoid ) or self.oclIsTypeOf(OclInvalid);
	}
	/**
	Evaluates to the type of which oclText[self] is an instance.
	**/
	operation oclType() : AnyClassifier<OclSelf> => 'org.eclipse.ocl.examples.library.oclany.OclAnyOclTypeOperation';
--	operation "."<T>(object2 : OclAny) : T precedence=NAVIGATION => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation';
}

/**
The type OclComparable defines the compareTo operation used by the sortedBy iteration. Only types that provide a derived
compareTo implementation may be sorted. 
**/
type OclComparable conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Return -ve, 0, +ve according to whether self is less than, equal to , or greater than that.

	The compareTo operation should be commutative.
	*/
	operation compareTo(that : OclSelf) : Integer;	
}

/**
The type OclElement is the implicit supertype of any user-defined type that has no explicit supertypes. Operations defined
for OclElement are therefore applicable to all user-defined types.
**/
type OclElement conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Return a set of all instances of the type and derived types of self.
	*/
	static operation allInstances() : Set<OclSelf> => 'org.eclipse.ocl.examples.library.classifier.ClassifierAllInstancesOperation';
	/**
	Returns the object for which self is a composed content or null if there is no such object.
	*/
	operation oclContainer() : OclElement => 'org.eclipse.ocl.examples.library.classifier.ClassifierOclContainerOperation';
	/**
	Returns the composed contents of self.
	*/
	operation oclContents() : Set<OclElement> => 'org.eclipse.ocl.examples.library.classifier.ClassifierOclContentsOperation';
}

/**
The type OclInvalid is a type that conforms to all other types.
It has one single instance, identified as  oclText[invalid].
Any property call applied on invalid results in oclText[invalid], except for the operations oclIsUndefined() and oclIsInvalid().
OclInvalid is itself an instance of the metatype InvalidType.
**/
type OclInvalid : InvalidType conformsTo OclVoid {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Returns oclText[invalid].
	*/
	static operation allInstances() : Set<OclSelf> => 'org.eclipse.ocl.examples.library.oclinvalid.OclInvalidAllInstancesOperation';
	/**
	Returns oclText[invalid].
	*/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	/**
	Returns oclText[invalid].
	*/
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	operation oclBadOperation() : OclInvalid;
	property oclBadProperty : OclInvalid;
	/**
	Returns 'invalid'.
	*/
	operation toString() : String => 'org.eclipse.ocl.examples.library.oclany.OclAnyToStringOperation';
}

/**
The type OclLambda is the implicit supertype of all Lambda types. The operations defined for OclLambda
therefore apply to all lambda expressions.
**/
type OclLambda conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
}

/**
OclMessage
This sub clause contains the definition of the standard type OclMessage.
As defined in this sub clause, each ocl message type is actually a template type with one parameter.
‘T’ denotes the parameter.
A concrete ocl message type is created by substituting an operation or signal for the T.

The predefined type OclMessage is an instance of MessageType.
Every OclMessage is fully determined by either the operation, or signal given as parameter.
Note that there is conceptually an undefined (infinite) number of these types,
as each is determined by a different operation or signal.
These types are unnamed. Every type has as attributes the name of the operation or signal,
and either all formal parameters of the operation, or all attributes of the signal.
OclMessage is itself an instance of the metatype MessageType.

OclMessage has a number of predefined operations, as shown in the OCL Standard Library.
**/
type OclMessage conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='UML');
	/**
	True if type of template parameter is an operation call, and the called operation has returned a value.
	This implies the fact that the message has been sent. False in all other cases.
	**/
	operation hasReturned() : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation';
	/**
	Returns the result of the called operation, if type of template parameter is an operation call,
	and the called operation has returned a value. Otherwise the oclText[invalid] value is returned. 
	**/
	operation result() : OclAny => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation';
	/**
	Returns oclText[true] if the OclMessage represents the sending of a UML Operation call. 
	**/
	operation isOperationCall() : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation';
	/**
	Returns oclText[true] if the OclMessage represents the sending of a UML Signal. 
	**/
	operation isSignalSent() : Boolean => 'org.eclipse.ocl.examples.library.oclany.OclAnyUnsupportedOperation';
}

/**
The pseudo-type OclSelf denotes the statically determinate type of oclText[self] in Operation
and Iteration signatures. Instances of OclSelf are never created. 
**/
type OclSelf : SelfType conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
}

type OclState conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='UML');
}

/**
The type OclSummable defines the sum and zero operations used by the Collection::sum iteration. Only types that provide derived
sum and zero implementations may be summed. 
*/
type OclSummable conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Return the sum of self and that.

	The sum operation should be associative.
	*/
	operation sum(that : OclSelf) : OclSelf;	
	/**
	Return the 'zero' value of self to initialize a summation.

	zero().sum(self) = self.
	*/
	operation zero() : OclSelf;	
}

/**
The type OclTuple is the implicit supertype of all Tuple types. The operations defined for OclTuple
therefore apply to all tuples.
**/
type OclTuple conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
}

/**
The type OclType is the implicit supertype of any UML type. Operations defined
for OclType are therefore applicable to all UML types.
**/
type OclType conformsTo OclElement {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Returns true if type2 conforms to self.
	*/
	operation conformsTo(type2 : OclType) : Boolean => 'org.eclipse.ocl.examples.library.classifier.OclTypeConformsToOperation';
}

/**
The type OclVoid is a type that conforms to all other types except OclInvalid.
It has one single instance, identified as oclText[null], that corresponds with the UML LiteralNull value specification.
Any property call applied on oclText[null] results in oclText[invalid], except for the
oclIsUndefined(), oclIsInvalid(), =(OclAny) and <>(OclAny) operations.
However, by virtue of the implicit conversion to a collection literal,
an expression evaluating to oclText[null] can be used as source of collection operations (such as ‘isEmpty’).
If the source is the oclText[null] literal, it is implicitly converted to Bag{}.

OclVoid is itself an instance of the metatype VoidType.
**/
type OclVoid : VoidType conformsTo OclAny {
	annotation 'http://www.omg.org/ocl'(ClassGroup='OCL');
	/**
	Returns oclText[Set{null}].
	*/
	static operation allInstances() : Set<OclSelf> => 'org.eclipse.ocl.examples.library.oclvoid.OclVoidAllInstancesOperation';
	/**
	Redefines the OclAny operation, returning oclText[true] if object is oclText[null], oclText[invalid]
	if object is oclText[invalid], oclText[false] otherwise.
	**/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	operation and(b : Boolean) : Boolean precedence=AND => 'org.eclipse.ocl.examples.library.oclvoid.OclVoidAndOperation';
	operation implies(b : Boolean) : Boolean precedence=IMPLIES => 'org.eclipse.ocl.examples.library.oclvoid.OclVoidImpliesOperation';
	operation or(b : Boolean) : Boolean precedence=OR => 'org.eclipse.ocl.examples.library.oclvoid.OclVoidOrOperation';
	/**
	Returns oclText[null].
	*/
	operation toString() : String => 'org.eclipse.ocl.examples.library.oclany.OclAnyToStringOperation';
}

/**
The OrderedSet is a Set, the elements of which are ordered.
It contains no duplicates. OrderedSet is itself an instance of the metatype OrderedSetType.
An OrderedSet is not a subtype of Set, neither a subtype of Sequence.
The common supertype of Sets and OrderedSets is Collection.
**/
type OrderedSet<T> : OrderedSetType conformsTo Sequence<T>,UniqueCollection<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Collection');
	/**
	The ordered set of the source ordered set for which body is oclText[false].
	**/
	iteration reject(i : T | body : Lambda T() : Boolean) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.iterator.RejectIteration';
	/**
	The ordered set of the source ordered set for which body is oclText[true]
	**/
	iteration select(i : T | body : Lambda T() : Boolean) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.iterator.SelectIteration';
	/**
	Results in the ordered set containing all elements of the source collection.
	The element for which body has the lowest value comes first, and so on.
	The type of the body expression must have the < operation defined.
	The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c, then a < c).
	**/
	iteration sortedBy(i : T | body : Lambda T() : OclAny) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.iterator.SortedByIteration';
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The elements of oclText[self], which are not in s.
	**/
	operation "-"(s : UniqueCollection<OclAny>) : OrderedSet<T> precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.collection.SetMinusOperation';
	/**
	The set of elements, consisting of all elements of oclText[self], followed by object.
	**/
	operation append(object : T) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionAppendOperation';
	/**
	The ordered set  containing all elements of oclText[self] apart from object.

	The order of the remaining elements is not changed.
	**/
	operation excluding(object : OclAny) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.CollectionExcludingOperation';
	operation flatten<T2>() : OrderedSet<T2> => 'org.eclipse.ocl.examples.library.collection.CollectionFlattenOperation';
	/**
	The ordered set containing all elements of oclText[self] plus object added as the last element if not already present.
	**/
	operation including(object : T) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIncludingOperation';
	/**
	The ordered set consisting of oclText[self] with object present at position index.
	**/
	operation insertAt(index : Integer, object : T) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionInsertAtOperation';
	operation intersection(o : Collection<T>) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIntersectionOperation';
	/**
	The sequence consisting of object, followed by all elements in oclText[self].
	**/
	operation prepend(object : T) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionPrependOperation'
	{
		post IsSizePlusOne: result->size() = self->size() + 1;
		post IsAtStart: result->at(1) = object;
		post IsShiftedAlong: Sequence{1..self->size()}->forAll(index : Integer | self->at(index) = result->at(index + 1));
	}
	/**
	The ordered set of elements with same elements but with the opposite order.
	**/
	operation reverse() : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionReverseOperation';
	operation selectByKind<TT>(type : AnyClassifier<TT>) : OrderedSet<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByKindOperation';
	operation selectByType<TT>(type : AnyClassifier<TT>) : OrderedSet<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByTypeOperation';
	/**
	The sub-set of oclText[self] starting at number lower, up to and including element number upper.
	**/
	operation subOrderedSet(lower : Integer, upper : Integer) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.OrderedSetSubOrderedSetOperation';
	/**
	The ordered set consisting of all elements in oclText[self] and all elements in o.
	**/
	operation union(o : Sequence<T>) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.CollectionUnionOperation';
}

/**
The standard type Real represents the mathematical concept of real.
Note that UnlimitedNatural is a subclass of Integer and that Integer is a subclass of Real,
so for each parameter of type Real, you can use an unlimited natural or an integer as the actual parameter.
Real is itself an instance of the metatype PrimitiveType (from UML).
**/
type Real : PrimitiveType conformsTo OclComparable, OclSummable {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Primitive');
	/**
	Returns oclText[true] if the numeric value of oclText[self] is the same as the numeric value of object2, oclText[false] otherwise.
	*/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	/**
	Returns oclText[true] if the numeric value of oclText[self] is the not the same as the numeric value of object2, oclText[false] otherwise.
	*/
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The value of the addition of oclText[self] and r.
	**/
	operation "+"(r : OclSelf) : Real precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.real.RealPlusOperation';
	/**
	The value of the subtraction of r from oclText[self].
	**/
	operation "-"(r : OclSelf) : Real precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.real.RealMinusOperation';
	/**
	The value of the multiplication of oclText[self] and r.
	**/
	operation "*"(r : OclSelf) : Real precedence=MULTIPLICATIVE => 'org.eclipse.ocl.examples.library.numeric.NumericTimesOperation';
	/**
	The negative value of oclText[self].
	**/
	operation "-"() : Real precedence=UNARY => 'org.eclipse.ocl.examples.library.numeric.NumericNegateOperation';
	/**
	The value of oclText[self] divided by r. Evaluates to oclText[invalid] if r is equal to zero.
	**/
	operation "/"(r : OclSelf) : Real precedence=MULTIPLICATIVE => 'org.eclipse.ocl.examples.library.numeric.NumericDivideOperation';
	/**
	True if oclText[self] is greater than r.
	**/
	operation ">"(r : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.numeric.NumericGreaterThanOperation';
	/**
	True if oclText[self] is less than r.
	**/
	operation "<"(r : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.numeric.NumericLessThanOperation';
	/**
	True if oclText[self] is less than or equal to r.
	**/
	operation "<="(r : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.numeric.NumericLessThanEqualOperation';
	/**
	True if oclText[self] is greater than or equal to r.
	**/
	operation ">="(r : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.numeric.NumericGreaterThanEqualOperation';
	/**
	The absolute value of oclText[self].
	**/
	operation abs() : Real => 'org.eclipse.ocl.examples.library.numeric.NumericAbsOperation';
	/**
	The comparison of oclText[self] with oclText[that]. -ve if less than, 0 if equal, +ve if greater than.
	**/ 
	operation compareTo(that : OclSelf) : Integer  => 'org.eclipse.ocl.examples.library.real.RealCompareToOperation';	
	/**
	The largest integer that is less than or equal to oclText[self].
	**/
	operation floor() : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericFloorOperation';
	/**
	The maximum of oclText[self] and r.
	**/
	operation max(r : OclSelf) : Real => 'org.eclipse.ocl.examples.library.numeric.NumericMaxOperation';
	/**
	The minimum of oclText[self] and r.
	**/
	operation min(r : OclSelf) : Real => 'org.eclipse.ocl.examples.library.numeric.NumericMinOperation';
	/**
	The integer that is closest to oclText[self]. When there are two such integers, the largest one.
	**/
	operation round() : Integer => 'org.eclipse.ocl.examples.library.numeric.NumericRoundOperation';
	/**
	Converts oclText[self] to a string value.
	**/
	operation toString() : String => 'org.eclipse.ocl.examples.library.oclany.OclAnyToStringOperation';
}

/**
A sequence is a collection where the elements are ordered.
An element may be part of a sequence more than once.
Sequence is itself an instance of the metatype SequenceType.
A Sentence is not a subtype of Bag.
The common supertype of Sentence and Bags is Collection.
**/
type Sequence<T> : SequenceType conformsTo Collection<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Collection');
	/**
	The closure of applying body transitively to every distinct element of the source collection.
	**/
	iteration closure(i : T | body : Lambda T() : OrderedSet<T>) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.iterator.ClosureIteration';
	iteration collect<V>(i : T | body : Lambda T() : V) : Sequence<V> => 'org.eclipse.ocl.examples.library.iterator.CollectIteration';
	/**
	The sequence of elements that results from applying body to every member of the source ordered collection.
	**/
	iteration collectNested<V>(i : T | body : Lambda T() : V) : Sequence<T> => 'org.eclipse.ocl.examples.library.iterator.CollectNestedIteration';
	/**
	The subsequence of the source sequence for which body is oclText[false].
	**/
	iteration reject(i : T | body : Lambda T() : Boolean) : Sequence<T> => 'org.eclipse.ocl.examples.library.iterator.RejectIteration';
	/**
	The subsequence of the source sequence for which body is oclText[true].
	**/
	iteration select(i : T | body : Lambda T() : Boolean) : Sequence<T> => 'org.eclipse.ocl.examples.library.iterator.SelectIteration';
	/**
	Results in the Sequence containing all elements of the source collection.
	The element for which body has the lowest value comes first, and so on.
	The type of the body expression must have the < operation defined.
	The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c then a < c).
	**/
	iteration sortedBy(i : T | body : Lambda T() : OclAny) : Sequence<T> => 'org.eclipse.ocl.examples.library.iterator.SortedByIteration';
	/**
	True if oclText[self] contains the same elements as s in the same order.
	**/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The sequence of elements, consisting of all elements of oclText[self], followed by object.
	**/
	operation append(object : T) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionAppendOperation';
	/**
	The i-th element of sequence.
	**/
	operation at(index : Integer) : T => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionAtOperation';
	/**
	The sequence containing all elements of oclText[self] apart from all occurrences of object.

	The order of the remaining elements is not changed.
	**/
	operation excluding(object : OclAny) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.CollectionExcludingOperation';
	/**
	The first element in oclText[self].
	**/
	operation first() : T => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionFirstOperation';
	/**
	Redefines the Collection operation. If the element type is not a collection type, this results in the same sequence as oclText[self].
	If the element type is a collection type, the result is the sequence containing all the elements
	of all the recursively flattened elements of oclText[self]. The order of the elements is partial. 
	**/
	operation flatten<T2>() : Sequence<T2> => 'org.eclipse.ocl.examples.library.collection.CollectionFlattenOperation';
	/**
	The sequence containing all elements of oclText[self] plus object added as the last element.
	**/
	operation including(object : T) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIncludingOperation';
	/**
	The index of object obj in the ordered collection.
	**/
	operation indexOf(obj : OclAny) : Integer => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionIndexOfOperation';
	/**
	The sequence consisting of oclText[self] with object inserted at position index.
	**/
	operation insertAt(index : Integer, object : T) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionInsertAtOperation';
	/**
	The intersection of oclText[self] and bag; the bag of all elements that are in both oclText[self] and s.
	**/
	operation intersection(c : Collection<T>) : Bag<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIntersectionOperation';
	/**
	The intersection of oclText[self] and s; the set of all elements that are in both oclText[self] and s.
	**/
	operation intersection(s : UniqueCollection<T>) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIntersectionOperation';
	/**
	The last element in oclText[self].
	**/
	operation last() : T => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionLastOperation';
	/**
	The sequence consisting of object, followed by all elements in oclText[self].
	**/
	operation prepend(object : T) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionPrependOperation';
	/**
	The sequence containing the same elements but with the opposite order.
	**/
	operation reverse() : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.OrderedCollectionReverseOperation';
	operation selectByKind<TT>(type : AnyClassifier<TT>) : Sequence<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByKindOperation';
	operation selectByType<TT>(type : AnyClassifier<TT>) : Sequence<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByTypeOperation';
	/**
	The sub-sequence of oclText[self] starting at number lower, up to and including element number upper.
	**/
	operation subSequence(lower : Integer, upper : Integer) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.SequenceSubSequenceOperation';
	/**
	The sequence consisting of all elements in oclText[self], followed by all elements in s.
	**/
	operation union(s : Sequence<T>) : Sequence<T> => 'org.eclipse.ocl.examples.library.collection.CollectionUnionOperation';
}

type Set<T> : SetType conformsTo Bag<T>,UniqueCollection<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Collection');
	/**
	The subset of the source set for which body is oclText[false].
	**/
	iteration reject(i : T | body : Lambda T() : Boolean) : Set<T> => 'org.eclipse.ocl.examples.library.iterator.RejectIteration';
	/**
	The subset of set for which expr is oclText[true].
	**/
	iteration select(i : T | body : Lambda T() : Boolean) : Set<T> => 'org.eclipse.ocl.examples.library.iterator.SelectIteration';
	/**
	Results in the ordered set containing all elements of the source collection.
	The element for which body has the lowest value comes first, and so on.
	The type of the body expression must have the < operation defined.
	The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c, then a < c).
	**/
	iteration sortedBy(i : T | body : Lambda T() : OclAny) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.iterator.SortedByIteration';
	/**
	Evaluates to oclText[true] if oclText[self] and s contain the same elements.
	**/
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The elements of oclText[self], which are not in s.
	**/
	operation "-"(s : UniqueCollection<OclAny>) : Set<T> precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.collection.SetMinusOperation';
	/**
	The set containing all elements of oclText[self] without object.
	**/
	operation excluding(object : OclAny) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionExcludingOperation';
	/**
	Redefines the Collection operation. If the element type is not a collection type, this results in the same set as oclText[self].
	If the element type is a collection type, the result is the set containing all the elements of all the recursively flattened elements of oclText[self].
	**/
	operation flatten<T2>() : Set<T2> => 'org.eclipse.ocl.examples.library.collection.CollectionFlattenOperation';
	/**
	The set containing all elements of oclText[self] plus object.
	**/
	operation including(object : T) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIncludingOperation';
	/**
	The intersection of oclText[self] and s (i.e., the set of all elements that are in both oclText[self] and s).
	**/
	operation intersection(s : Collection<T>) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionIntersectionOperation';
	operation selectByKind<TT>(type : AnyClassifier<TT>) : Set<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByKindOperation';
	operation selectByType<TT>(type : AnyClassifier<TT>) : Set<TT> => 'org.eclipse.ocl.examples.library.collection.CollectionSelectByTypeOperation';
	/**
	The set consisting of all elements in oclText[self] and all elements in s.
	**/
	operation union(s : Collection<T>) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionUnionOperation';
}

/**
The standard type String represents strings, which can be both ASCII or Unicode.
String is itself an instance of the metatype PrimitiveType (from UML).
**/
type String : PrimitiveType conformsTo OclComparable, OclSummable {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Primitive');
	operation "="(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyEqualOperation';
	operation "<>"(object2 : OclSelf) : Boolean precedence=EQUALITY => 'org.eclipse.ocl.examples.library.oclany.OclAnyNotEqualOperation';
	/**
	The concatenation of oclText[self] and s.
	**/
	operation "+"(s : String) : String precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.string.StringConcatOperation';
	/**
	Queries the character at position i in oclText[self].
	**/
	operation at(i : Integer) : String => 'org.eclipse.ocl.examples.library.string.StringAtOperation';
	/**
	Obtains the characters of oclText[self] as a sequence.
	**/
	operation characters() : Sequence<String>  => 'org.eclipse.ocl.examples.library.string.StringCharactersOperation';
	/**
	The comparison of oclText[self] with oclText[that]. -ve if less than, 0 if equal, +ve if greater than.
	**/ 
	operation compareTo(that : OclSelf) : Integer  => 'org.eclipse.ocl.examples.library.string.StringCompareToOperation';	
	/**
	The concatenation of oclText[self] and s.
	**/
	operation concat(s : String) : String => 'org.eclipse.ocl.examples.library.string.StringConcatOperation';
	/**
	Returns true if oclText[self] ends with the string s.
	Every string ends with the empty string.
	**/
	operation endsWith(s : String) : Boolean => 'org.eclipse.ocl.examples.library.string.StringEndsWithOperation';
	/**
	Queries whether s and oclText[self] are equivalent under case-insensitive collation.
	**/
	operation equalsIgnoreCase(s : String) : Boolean => 'org.eclipse.ocl.examples.library.string.StringEqualsIgnoreCaseOperation';
	/**
	Queries the first index in oclText[self] at which s is a substring of oclText[self], or zero if s is not a substring of oclText[self].
	The empty string is a substring of every string at index 1 (and also at all other indexes).
	**/
	operation indexOf(s : String) : Integer => 'org.eclipse.ocl.examples.library.string.StringIndexOfOperation';
	/**
	Queries the last in oclText[self] at which s is a substring of oclText[self], or zero if s is not a substring of oclText[self].
	The empty string is a substring of every string at index oclText[self]-size()+1 (and also at all other indexes).
	**/
	operation lastIndexOf(s : String) : Integer => 'org.eclipse.ocl.examples.library.string.StringLastIndexOfOperation';
	/**
	Use a regular expression match and return true if self matches regex, false otherwise.
	**/
	operation matches(regex : String) : Boolean => 'org.eclipse.ocl.examples.library.string.StringMatchesOperation';
	/**
	Return a string derived from self by replacing all matches of regex by replacement.
	**/
	operation replaceAll(regex : String, replacement : String) : String => 'org.eclipse.ocl.examples.library.string.StringReplaceAllOperation';
	/**
	Return a string derived from self by replacing the first match of regex by replacement.
	**/
	operation replaceFirst(regex : String, replacement : String) : String => 'org.eclipse.ocl.examples.library.string.StringReplaceFirstOperation';
	/**
	The number of characters in oclText[self].
	**/
	operation size() : Integer => 'org.eclipse.ocl.examples.library.string.StringSizeOperation';
	/**
	Returns true if oclText[self] starts with the string s.
	Every string starts with the empty string.
	**/
	operation startsWith(s : String) : Boolean => 'org.eclipse.ocl.examples.library.string.StringStartsWithOperation';
	/**
	Return a string derived from self by replacing all occurrences of oldSubstring by newSubstring.
	**/
	operation substituteAll(oldSubstring : String, newSubstring : String) : String => 'org.eclipse.ocl.examples.library.string.StringSubstituteAllOperation';
	/**
	Return a string derived from self by replacing the first occurrence of oldSubstring by newSubstring.
	Returns invalid if there is no first occurrence.
	**/
	operation substituteFirst(oldSubstring : String, newSubstring : String) : String => 'org.eclipse.ocl.examples.library.string.StringSubstituteFirstOperation';
	/**
	The sub-string of oclText[self] starting at character number lower, up to and including character number upper. Character numbers run from 1 to self.size().
	**/
	operation substring(lower : Integer, upper : Integer) : String => 'org.eclipse.ocl.examples.library.string.StringSubstringOperation';
	/**
	Converts oclText[self] to a boolean value.
	**/
	operation toBoolean() : Boolean => 'org.eclipse.ocl.examples.library.string.StringToBooleanOperation';
	/**
	Converts oclText[self] to an Integer value.
	**/
	operation toInteger() : Integer => 'org.eclipse.ocl.examples.library.string.StringToIntegerOperation';
	/**
	This is a deprecated variant of toLowerCase() preserving compatibility with traditional Eclipse OCL behaviour. 
	**/
	operation toLower() : String => 'org.eclipse.ocl.examples.library.string.StringToLowerCaseOperation';
	/**
	Converts oclText[self] to lower case, using the locale defined by looking up oclLocale in the current environment.
	Otherwise, returns the same string as oclText[self]. 
	**/
	operation toLowerCase() : String => 'org.eclipse.ocl.examples.library.string.StringToLowerCaseOperation';
	/**
	Converts oclText[self] to a Real value.
	**/
	operation toReal() : Real => 'org.eclipse.ocl.examples.library.string.StringToRealOperation';
	/**
	Returns oclText[self].
	*/
	operation toString() : String => 'org.eclipse.ocl.examples.library.oclany.OclAnyToStringOperation';
	/**
	This is a deprecated variant of toUpperCase() preserving compatibility with traditional Eclipse OCL behaviour. 
	**/
	operation toUpper() : String => 'org.eclipse.ocl.examples.library.string.StringToUpperCaseOperation';
	/**
	Converts oclText[self] to upper case, using the locale defined by looking up oclLocale in the current environment.
	Otherwise, returns the same string as oclText[self]. 
	**/
	operation toUpperCase() : String => 'org.eclipse.ocl.examples.library.string.StringToUpperCaseOperation';
	/**
	Partition oclText[self] into a sequence substrings separated by any of space, line-feed, carriage-return, form-feed and horizontal-tab delimiters.
	The delimiters are omitted from the return.
	**/
	operation tokenize() : Sequence<String> => 'org.eclipse.ocl.examples.library.string.StringTokenizeOperation';
	/**
	Partition oclText[self] into a sequence substrings separated by characters in the delimiters. The delimiters are omitted from the return.
	**/
	operation tokenize(delimiters : String) : Sequence<String> => 'org.eclipse.ocl.examples.library.string.StringTokenizeOperation';
	/**
	Partition oclText[self] into a sequence substrings separated by characters in the delimiters. If returnDelimeters is
	true the returned sequence includes the delimiters, otherwise the delimiters are omitted.
	**/
	operation tokenize(delimiters : String, returnDelimiters : Boolean) : Sequence<String> => 'org.eclipse.ocl.examples.library.string.StringTokenizeOperation';
	/**
	Return oclText[self] with leading and trailing whitespace removed.
	**/
	operation trim() : String => 'org.eclipse.ocl.examples.library.string.StringTrimOperation';
	/**
	True if oclText[self] is greater than s, using the locale defined by looking up oclLocale in the current environment.
	**/
	operation ">"(s : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.string.StringGreaterThanOperation';
	/**
	True if oclText[self] is less than s, using the locale defined by looking up oclLocale in the current environment.
	**/
	operation "<"(s : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.string.StringLessThanOperation';
	/**
	True if oclText[self] is less than or equal to s, using the locale defined by looking up oclLocale in the current environment.
	**/
	operation "<="(s : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.string.StringLessThanEqualOperation';
	/**
	True if oclText[self] is greater than or equal to s, using the locale defined by looking up oclLocale in the current environment.
	**/
	operation ">="(s : OclSelf) : Boolean precedence=RELATIONAL => 'org.eclipse.ocl.examples.library.string.StringGreaterThanEqualOperation';
}

type Type conformsTo OclType {
}

/**
The UniqueCollection type provides the shared functionality of the OrderedSet and Set
collections for which the elements are unique.
The common supertype of UniqueCollection is Collection.
**/
type UniqueCollection<T> : CollectionType conformsTo Collection<T> {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Collection');
	/**
	Results in the ordered set containing all elements of the source collection.
	The element for which body has the lowest value comes first, and so on.
	The type of the body expression must have the < operation defined.
	The < operation must return a Boolean value and must be transitive (i.e., if a < b and b < c, then a < c).
	**/
	iteration sortedBy(i : T | body : Lambda T() : OclAny) : OrderedSet<T> => 'org.eclipse.ocl.examples.library.iterator.SortedByIteration';
	/**
	The elements of oclText[self], which are not in s.
	**/
	operation "-"(s : UniqueCollection<OclAny>) : UniqueCollection<T> precedence=ADDITIVE => 'org.eclipse.ocl.examples.library.collection.SetMinusOperation';
	/**
	The set containing all the elements that are in oclText[self] or s, but not in both.
	**/
	operation symmetricDifference(s : UniqueCollection<OclAny>) : Set<T> => 'org.eclipse.ocl.examples.library.collection.SetSymmetricDifferenceOperation';
	/**
	The set consisting of all elements in oclText[self] and all elements in s.
	**/
	operation union(s : Collection<T>) : Set<T> => 'org.eclipse.ocl.examples.library.collection.CollectionUnionOperation';
}

/**
The standard type UnlimitedNatural is used to encode the non-negative values of a multiplicity specification.
This includes a special e[unlimited] value (*) that encodes the upper value of  a multiplicity specification.
UnlimitedNatural is itself an instance of the metatype UnlimitedNaturalType.

Note that although UnlimitedNatural is a subclass of Integer, the e[unlimited] value cannot be represented as an Integer.
Any use of the e[unlimited] value as an integer or real is replaced by the oclText[invalid] value.
**/
type UnlimitedNatural : PrimitiveType conformsTo Integer {
	annotation 'http://www.omg.org/ocl'(ClassGroup='Primitive');
	/**
	Evaluates to oclText[self], where oclText[self] is of the type identified by T.
	The type T may be any classifier defined in the UML model;
	if the actual type of oclText[self] at evaluation time does not conform to T,
	then the oclAsType operation evaluates to oclText[invalid].

	The standard behavior is redefined for UnlimitedNatural. Numeric values may be converted to
	Real or Integer, but the e[unlimited] value may not.
	Conversion of e[unlimited] to Real or Integer returns oclText[invalid].
	
	**/
	operation oclAsType<TT>(type : AnyClassifier<TT>) : TT => 'org.eclipse.ocl.examples.library.numeric.UnlimitedNaturalOclAsTypeOperation';
}

}
