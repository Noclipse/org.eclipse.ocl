/*
* generated by Xtext
*/

package org.eclipse.ocl.examples.xtext.essentialocl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EssentialOCLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Assignment cOwnedExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOwnedExpressionExpCSParserRuleCall_0 = (RuleCall)cOwnedExpressionAssignment.eContents().get(0);
		
		////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
		//Model returns ContextCS:
		//	ownedExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//ownedExpression=ExpCS
		public Assignment getOwnedExpressionAssignment() { return cOwnedExpressionAssignment; }

		//ExpCS
		public RuleCall getOwnedExpressionExpCSParserRuleCall_0() { return cOwnedExpressionExpCSParserRuleCall_0; }
	}

	public class IDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSIMPLE_IDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cESCAPED_IDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ID:
		//	SIMPLE_ID | ESCAPED_ID;
		public ParserRule getRule() { return rule; }

		//SIMPLE_ID | ESCAPED_ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//SIMPLE_ID
		public RuleCall getSIMPLE_IDTerminalRuleCall_0() { return cSIMPLE_IDTerminalRuleCall_0; }

		//ESCAPED_ID
		public RuleCall getESCAPED_IDTerminalRuleCall_1() { return cESCAPED_IDTerminalRuleCall_1; }
	}

	public class LOWERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LOWER");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LOWER returns ecore::EInt:
		//	INT;
		public ParserRule getRule() { return rule; }

		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}

	public class UPPERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UPPER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//UPPER returns ecore::EInt:
		//	INT | "*";
		public ParserRule getRule() { return rule; }

		//INT | "*"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}

	public class NUMBER_LITERALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER_LITERAL");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cEKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Keyword cEKeyword_2_0_1 = (Keyword)cAlternatives_2_0.eContents().get(1);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Keyword cPlusSignKeyword_2_1_0 = (Keyword)cAlternatives_2_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1_1 = (Keyword)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		
		//// Not terminal to allow parser backtracking to sort out "5..7"
		//NUMBER_LITERAL returns BigNumber:
		//	INT ("." INT)? (("e" | "E") ("+" | "-")? INT)?;
		public ParserRule getRule() { return rule; }

		//INT ("." INT)? (("e" | "E") ("+" | "-")? INT)?
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//("." INT)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }

		//(("e" | "E") ("+" | "-")? INT)?
		public Group getGroup_2() { return cGroup_2; }

		//"e" | "E"
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }

		//"e"
		public Keyword getEKeyword_2_0_0() { return cEKeyword_2_0_0; }

		//"E"
		public Keyword getEKeyword_2_0_1() { return cEKeyword_2_0_1; }

		//("+" | "-")?
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//"+"
		public Keyword getPlusSignKeyword_2_1_0() { return cPlusSignKeyword_2_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2_1_1() { return cHyphenMinusKeyword_2_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_2() { return cINTTerminalRuleCall_2_2; }
	}

	public class URIElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "URI");
		private final RuleCall cSINGLE_QUOTED_STRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//URI:
		//	SINGLE_QUOTED_STRING;
		public ParserRule getRule() { return rule; }

		//SINGLE_QUOTED_STRING
		public RuleCall getSINGLE_QUOTED_STRINGTerminalRuleCall() { return cSINGLE_QUOTED_STRINGTerminalRuleCall; }
	}

	public class EssentialOCLReservedKeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLReservedKeyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cElseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEndifKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cIfKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cImpliesKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cInKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLetKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNotKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cOrKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cThenKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cXorKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		
		//EssentialOCLReservedKeyword:
		//	"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor";
		public ParserRule getRule() { return rule; }

		//"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"and"
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }

		//"else"
		public Keyword getElseKeyword_1() { return cElseKeyword_1; }

		//"endif"
		public Keyword getEndifKeyword_2() { return cEndifKeyword_2; }

		//"if"
		public Keyword getIfKeyword_3() { return cIfKeyword_3; }

		//"implies"
		public Keyword getImpliesKeyword_4() { return cImpliesKeyword_4; }

		//"in"
		public Keyword getInKeyword_5() { return cInKeyword_5; }

		//"let"
		public Keyword getLetKeyword_6() { return cLetKeyword_6; }

		//"not"
		public Keyword getNotKeyword_7() { return cNotKeyword_7; }

		//"or"
		public Keyword getOrKeyword_8() { return cOrKeyword_8; }

		//"then"
		public Keyword getThenKeyword_9() { return cThenKeyword_9; }

		//"xor"
		public Keyword getXorKeyword_10() { return cXorKeyword_10; }
	}

	public class EssentialOCLUnrestrictedIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLUnrestrictedIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EssentialOCLUnrestrictedIdentifier:
		//	"e" | "E";
		public ParserRule getRule() { return rule; }

		//"e" | "E"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"e"
		public Keyword getEKeyword_0() { return cEKeyword_0; }

		//"E"
		public Keyword getEKeyword_1() { return cEKeyword_1; }
	}

	public class EssentialOCLPrefixOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLPrefixOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EssentialOCLPrefixOperator:
		//	"-" | "not";
		public ParserRule getRule() { return rule; }

		//"-" | "not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//"not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
	}

	public class EssentialOCLInfixOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLInfixOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPlusSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLessThanSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cGreaterThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLessThanSignEqualsSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cEqualsSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cLessThanSignGreaterThanSignKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cAndKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cOrKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cXorKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cImpliesKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		//EssentialOCLInfixOperator:
		//	"*" | "/" | "+" | "-" | ">" | "<" | ">=" | "<=" | "=" | "<>" | "and" | "or" | "xor" | "implies";
		public ParserRule getRule() { return rule; }

		//"*" | "/" | "+" | "-" | ">" | "<" | ">=" | "<=" | "=" | "<>" | "and" | "or" | "xor" | "implies"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//"+"
		public Keyword getPlusSignKeyword_2() { return cPlusSignKeyword_2; }

		//"-"
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }

		//"<"
		public Keyword getLessThanSignKeyword_5() { return cLessThanSignKeyword_5; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_6() { return cGreaterThanSignEqualsSignKeyword_6; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_7() { return cLessThanSignEqualsSignKeyword_7; }

		//"="
		public Keyword getEqualsSignKeyword_8() { return cEqualsSignKeyword_8; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_9() { return cLessThanSignGreaterThanSignKeyword_9; }

		//"and"
		public Keyword getAndKeyword_10() { return cAndKeyword_10; }

		//"or"
		public Keyword getOrKeyword_11() { return cOrKeyword_11; }

		//"xor"
		public Keyword getXorKeyword_12() { return cXorKeyword_12; }

		//"implies"
		public Keyword getImpliesKeyword_13() { return cImpliesKeyword_13; }
	}

	public class EssentialOCLNavigationOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLNavigationOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EssentialOCLNavigationOperator:
		//	"." | "->";
		public ParserRule getRule() { return rule; }

		//"." | "->"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
	}

	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEssentialOCLUnrestrictedIdentifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Identifier:
		//	ID | EssentialOCLUnrestrictedIdentifier;
		public ParserRule getRule() { return rule; }

		//ID | EssentialOCLUnrestrictedIdentifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDParserRuleCall_0() { return cIDParserRuleCall_0; }

		//EssentialOCLUnrestrictedIdentifier
		public RuleCall getEssentialOCLUnrestrictedIdentifierParserRuleCall_1() { return cEssentialOCLUnrestrictedIdentifierParserRuleCall_1; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final RuleCall cSINGLE_QUOTED_STRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StringLiteral:
		//	SINGLE_QUOTED_STRING;
		public ParserRule getRule() { return rule; }

		//SINGLE_QUOTED_STRING
		public RuleCall getSINGLE_QUOTED_STRINGTerminalRuleCall() { return cSINGLE_QUOTED_STRINGTerminalRuleCall; }
	}

	public class PrefixOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrefixOperator");
		private final RuleCall cEssentialOCLPrefixOperatorParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		//PrefixOperator:
		//	EssentialOCLPrefixOperator;
		public ParserRule getRule() { return rule; }

		//EssentialOCLPrefixOperator
		public RuleCall getEssentialOCLPrefixOperatorParserRuleCall() { return cEssentialOCLPrefixOperatorParserRuleCall; }
	}

	public class InfixOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixOperator");
		private final RuleCall cEssentialOCLInfixOperatorParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		//InfixOperator:
		//	EssentialOCLInfixOperator;
		public ParserRule getRule() { return rule; }

		//EssentialOCLInfixOperator
		public RuleCall getEssentialOCLInfixOperatorParserRuleCall() { return cEssentialOCLInfixOperatorParserRuleCall; }
	}

	public class NavigationOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigationOperator");
		private final RuleCall cEssentialOCLNavigationOperatorParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		//NavigationOperator:
		//	EssentialOCLNavigationOperator;
		public ParserRule getRule() { return rule; }

		//EssentialOCLNavigationOperator
		public RuleCall getEssentialOCLNavigationOperatorParserRuleCall() { return cEssentialOCLNavigationOperatorParserRuleCall; }
	}

	public class EssentialOCLUnrestrictedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLUnrestrictedName");
		private final RuleCall cIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////---------------------------------------------------------------------
		////  Names
		////---------------------------------------------------------------------
		//EssentialOCLUnrestrictedName returns ecore::EString:
		//	Identifier;
		public ParserRule getRule() { return rule; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall() { return cIdentifierParserRuleCall; }
	}

	public class UnrestrictedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnrestrictedName");
		private final RuleCall cEssentialOCLUnrestrictedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		//UnrestrictedName returns ecore::EString:
		//	EssentialOCLUnrestrictedName;
		public ParserRule getRule() { return rule; }

		//EssentialOCLUnrestrictedName
		public RuleCall getEssentialOCLUnrestrictedNameParserRuleCall() { return cEssentialOCLUnrestrictedNameParserRuleCall; }
	}

	public class EssentialOCLUnreservedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLUnreservedName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnrestrictedNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCollectionTypeIdentifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPrimitiveTypeIdentifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Keyword cTupleKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//EssentialOCLUnreservedName returns ecore::EString:
		//	UnrestrictedName | CollectionTypeIdentifier | PrimitiveTypeIdentifier | "Tuple";
		public ParserRule getRule() { return rule; }

		//UnrestrictedName | CollectionTypeIdentifier | PrimitiveTypeIdentifier | "Tuple"
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_0() { return cUnrestrictedNameParserRuleCall_0; }

		//CollectionTypeIdentifier
		public RuleCall getCollectionTypeIdentifierParserRuleCall_1() { return cCollectionTypeIdentifierParserRuleCall_1; }

		//PrimitiveTypeIdentifier
		public RuleCall getPrimitiveTypeIdentifierParserRuleCall_2() { return cPrimitiveTypeIdentifierParserRuleCall_2; }

		//"Tuple"
		public Keyword getTupleKeyword_3() { return cTupleKeyword_3; }
	}

	public class UnreservedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnreservedName");
		private final RuleCall cEssentialOCLUnreservedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		//UnreservedName returns ecore::EString:
		//	EssentialOCLUnreservedName;
		public ParserRule getRule() { return rule; }

		//EssentialOCLUnreservedName
		public RuleCall getEssentialOCLUnreservedNameParserRuleCall() { return cEssentialOCLUnreservedNameParserRuleCall; }
	}

	public class PathNameCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathNameCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPathAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPathFirstPathElementCSParserRuleCall_0_0 = (RuleCall)cPathAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPathAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPathNextPathElementCSParserRuleCall_1_1_0 = (RuleCall)cPathAssignment_1_1.eContents().get(0);
		
		//PathNameCS returns base::PathNameCS:
		//	path+=FirstPathElementCS ("::" path+=NextPathElementCS)*;
		public ParserRule getRule() { return rule; }

		//path+=FirstPathElementCS ("::" path+=NextPathElementCS)*
		public Group getGroup() { return cGroup; }

		//path+=FirstPathElementCS
		public Assignment getPathAssignment_0() { return cPathAssignment_0; }

		//FirstPathElementCS
		public RuleCall getPathFirstPathElementCSParserRuleCall_0_0() { return cPathFirstPathElementCSParserRuleCall_0_0; }

		//("::" path+=NextPathElementCS)*
		public Group getGroup_1() { return cGroup_1; }

		//"::"
		public Keyword getColonColonKeyword_1_0() { return cColonColonKeyword_1_0; }

		//path+=NextPathElementCS
		public Assignment getPathAssignment_1_1() { return cPathAssignment_1_1; }

		//NextPathElementCS
		public RuleCall getPathNextPathElementCSParserRuleCall_1_1_0() { return cPathNextPathElementCSParserRuleCall_1_1_0; }
	}

	public class FirstPathElementCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FirstPathElementCS");
		private final Assignment cElementAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cElementNamedElementCrossReference_0 = (CrossReference)cElementAssignment.eContents().get(0);
		private final RuleCall cElementNamedElementUnrestrictedNameParserRuleCall_0_1 = (RuleCall)cElementNamedElementCrossReference_0.eContents().get(1);
		
		//FirstPathElementCS returns base::PathElementCS:
		//	element=[pivot::NamedElement|UnrestrictedName];
		public ParserRule getRule() { return rule; }

		//element=[pivot::NamedElement|UnrestrictedName]
		public Assignment getElementAssignment() { return cElementAssignment; }

		//[pivot::NamedElement|UnrestrictedName]
		public CrossReference getElementNamedElementCrossReference_0() { return cElementNamedElementCrossReference_0; }

		//UnrestrictedName
		public RuleCall getElementNamedElementUnrestrictedNameParserRuleCall_0_1() { return cElementNamedElementUnrestrictedNameParserRuleCall_0_1; }
	}

	public class NextPathElementCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NextPathElementCS");
		private final Assignment cElementAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cElementNamedElementCrossReference_0 = (CrossReference)cElementAssignment.eContents().get(0);
		private final RuleCall cElementNamedElementUnreservedNameParserRuleCall_0_1 = (RuleCall)cElementNamedElementCrossReference_0.eContents().get(1);
		
		//NextPathElementCS returns base::PathElementCS:
		//	element=[pivot::NamedElement|UnreservedName];
		public ParserRule getRule() { return rule; }

		//element=[pivot::NamedElement|UnreservedName]
		public Assignment getElementAssignment() { return cElementAssignment; }

		//[pivot::NamedElement|UnreservedName]
		public CrossReference getElementNamedElementCrossReference_0() { return cElementNamedElementCrossReference_0; }

		//UnreservedName
		public RuleCall getElementNamedElementUnreservedNameParserRuleCall_0_1() { return cElementNamedElementUnreservedNameParserRuleCall_0_1; }
	}

	public class PrimitiveTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveTypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBooleanKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIntegerKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRealKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cStringKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cUnlimitedNaturalKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cOclAnyKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cOclInvalidKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cOclVoidKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		////---------------------------------------------------------------------
		////  Types
		////---------------------------------------------------------------------
		//PrimitiveTypeIdentifier:
		//	"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid";
		public ParserRule getRule() { return rule; }

		//"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"Boolean"
		public Keyword getBooleanKeyword_0() { return cBooleanKeyword_0; }

		//"Integer"
		public Keyword getIntegerKeyword_1() { return cIntegerKeyword_1; }

		//"Real"
		public Keyword getRealKeyword_2() { return cRealKeyword_2; }

		//"String"
		public Keyword getStringKeyword_3() { return cStringKeyword_3; }

		//"UnlimitedNatural"
		public Keyword getUnlimitedNaturalKeyword_4() { return cUnlimitedNaturalKeyword_4; }

		//"OclAny"
		public Keyword getOclAnyKeyword_5() { return cOclAnyKeyword_5; }

		//"OclInvalid"
		public Keyword getOclInvalidKeyword_6() { return cOclInvalidKeyword_6; }

		//"OclVoid"
		public Keyword getOclVoidKeyword_7() { return cOclVoidKeyword_7; }
	}

	public class PrimitiveTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveTypeCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNamePrimitiveTypeIdentifierParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//PrimitiveTypeCS returns base::PrimitiveTypeRefCS:
		//	name=PrimitiveTypeIdentifier;
		public ParserRule getRule() { return rule; }

		//name=PrimitiveTypeIdentifier
		public Assignment getNameAssignment() { return cNameAssignment; }

		//PrimitiveTypeIdentifier
		public RuleCall getNamePrimitiveTypeIdentifierParserRuleCall_0() { return cNamePrimitiveTypeIdentifierParserRuleCall_0; }
	}

	public class CollectionTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionTypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSetKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBagKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSequenceKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCollectionKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cOrderedSetKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//CollectionTypeIdentifier returns ecore::EString:
		//	"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet";
		public ParserRule getRule() { return rule; }

		//"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"Set"
		public Keyword getSetKeyword_0() { return cSetKeyword_0; }

		//"Bag"
		public Keyword getBagKeyword_1() { return cBagKeyword_1; }

		//"Sequence"
		public Keyword getSequenceKeyword_2() { return cSequenceKeyword_2; }

		//"Collection"
		public Keyword getCollectionKeyword_3() { return cCollectionKeyword_3; }

		//"OrderedSet"
		public Keyword getOrderedSetKeyword_4() { return cOrderedSetKeyword_4; }
	}

	public class CollectionTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameCollectionTypeIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cOwnedTypeAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//CollectionTypeCS:
		//	name=CollectionTypeIdentifier ("(" ownedType=TypeExpCS ")")?;
		public ParserRule getRule() { return rule; }

		//name=CollectionTypeIdentifier ("(" ownedType=TypeExpCS ")")?
		public Group getGroup() { return cGroup; }

		//name=CollectionTypeIdentifier
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//CollectionTypeIdentifier
		public RuleCall getNameCollectionTypeIdentifierParserRuleCall_0_0() { return cNameCollectionTypeIdentifierParserRuleCall_0_0; }

		//("(" ownedType=TypeExpCS ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_1_1() { return cOwnedTypeAssignment_1_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_1_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class MultiplicityBoundsCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicityBoundsCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLowerBoundAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLowerBoundLOWERParserRuleCall_0_0 = (RuleCall)cLowerBoundAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cUpperBoundAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUpperBoundUPPERParserRuleCall_1_1_0 = (RuleCall)cUpperBoundAssignment_1_1.eContents().get(0);
		
		//MultiplicityBoundsCS returns base::MultiplicityBoundsCS:
		//	lowerBound=LOWER (".." upperBound=UPPER)?;
		public ParserRule getRule() { return rule; }

		//lowerBound=LOWER (".." upperBound=UPPER)?
		public Group getGroup() { return cGroup; }

		//lowerBound=LOWER
		public Assignment getLowerBoundAssignment_0() { return cLowerBoundAssignment_0; }

		//LOWER
		public RuleCall getLowerBoundLOWERParserRuleCall_0_0() { return cLowerBoundLOWERParserRuleCall_0_0; }

		//(".." upperBound=UPPER)?
		public Group getGroup_1() { return cGroup_1; }

		//".."
		public Keyword getFullStopFullStopKeyword_1_0() { return cFullStopFullStopKeyword_1_0; }

		//upperBound=UPPER
		public Assignment getUpperBoundAssignment_1_1() { return cUpperBoundAssignment_1_1; }

		//UPPER
		public RuleCall getUpperBoundUPPERParserRuleCall_1_1_0() { return cUpperBoundUPPERParserRuleCall_1_1_0; }
	}

	public class MultiplicityCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicityCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cMultiplicityBoundsCSParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cMultiplicityStringCSParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//MultiplicityCS returns base::MultiplicityCS:
		//	"[" (MultiplicityBoundsCS | MultiplicityStringCS) "]";
		public ParserRule getRule() { return rule; }

		//"[" (MultiplicityBoundsCS | MultiplicityStringCS) "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//MultiplicityBoundsCS | MultiplicityStringCS
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//MultiplicityBoundsCS
		public RuleCall getMultiplicityBoundsCSParserRuleCall_1_0() { return cMultiplicityBoundsCSParserRuleCall_1_0; }

		//MultiplicityStringCS
		public RuleCall getMultiplicityStringCSParserRuleCall_1_1() { return cMultiplicityStringCSParserRuleCall_1_1; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class MultiplicityStringCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicityStringCS");
		private final Assignment cStringBoundsAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cStringBoundsAlternatives_0 = (Alternatives)cStringBoundsAssignment.eContents().get(0);
		private final Keyword cStringBoundsAsteriskKeyword_0_0 = (Keyword)cStringBoundsAlternatives_0.eContents().get(0);
		private final Keyword cStringBoundsPlusSignKeyword_0_1 = (Keyword)cStringBoundsAlternatives_0.eContents().get(1);
		private final Keyword cStringBoundsQuestionMarkKeyword_0_2 = (Keyword)cStringBoundsAlternatives_0.eContents().get(2);
		
		//MultiplicityStringCS returns base::MultiplicityStringCS:
		//	stringBounds=("*" | "+" | "?");
		public ParserRule getRule() { return rule; }

		//stringBounds=("*" | "+" | "?")
		public Assignment getStringBoundsAssignment() { return cStringBoundsAssignment; }

		//"*" | "+" | "?"
		public Alternatives getStringBoundsAlternatives_0() { return cStringBoundsAlternatives_0; }

		//"*"
		public Keyword getStringBoundsAsteriskKeyword_0_0() { return cStringBoundsAsteriskKeyword_0_0; }

		//"+"
		public Keyword getStringBoundsPlusSignKeyword_0_1() { return cStringBoundsPlusSignKeyword_0_1; }

		//"?"
		public Keyword getStringBoundsQuestionMarkKeyword_0_2() { return cStringBoundsQuestionMarkKeyword_0_2; }
	}

	public class TupleTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameTupleKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cOwnedPartsAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cOwnedPartsTuplePartCSParserRuleCall_1_1_0_0 = (RuleCall)cOwnedPartsAssignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cOwnedPartsAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cOwnedPartsTuplePartCSParserRuleCall_1_1_1_1_0 = (RuleCall)cOwnedPartsAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//TupleTypeCS returns base::TupleTypeCS:
		//	name="Tuple" ("(" (ownedParts+=tuplePartCS ("," ownedParts+=tuplePartCS)*)? ")")?;
		public ParserRule getRule() { return rule; }

		//name="Tuple" ("(" (ownedParts+=tuplePartCS ("," ownedParts+=tuplePartCS)*)? ")")?
		public Group getGroup() { return cGroup; }

		//name="Tuple"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"Tuple"
		public Keyword getNameTupleKeyword_0_0() { return cNameTupleKeyword_0_0; }

		//("(" (ownedParts+=tuplePartCS ("," ownedParts+=tuplePartCS)*)? ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//(ownedParts+=tuplePartCS ("," ownedParts+=tuplePartCS)*)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//ownedParts+=tuplePartCS
		public Assignment getOwnedPartsAssignment_1_1_0() { return cOwnedPartsAssignment_1_1_0; }

		//tuplePartCS
		public RuleCall getOwnedPartsTuplePartCSParserRuleCall_1_1_0_0() { return cOwnedPartsTuplePartCSParserRuleCall_1_1_0_0; }

		//("," ownedParts+=tuplePartCS)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }

		//ownedParts+=tuplePartCS
		public Assignment getOwnedPartsAssignment_1_1_1_1() { return cOwnedPartsAssignment_1_1_1_1; }

		//tuplePartCS
		public RuleCall getOwnedPartsTuplePartCSParserRuleCall_1_1_1_1_0() { return cOwnedPartsTuplePartCSParserRuleCall_1_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class TuplePartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tuplePartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOwnedTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_2_0 = (RuleCall)cOwnedTypeAssignment_2.eContents().get(0);
		
		//tuplePartCS returns base::TuplePartCS:
		//	name=UnrestrictedName ":" ownedType=TypeExpCS;
		public ParserRule getRule() { return rule; }

		//name=UnrestrictedName ":" ownedType=TypeExpCS
		public Group getGroup() { return cGroup; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0_0() { return cNameUnrestrictedNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_2() { return cOwnedTypeAssignment_2; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_2_0() { return cOwnedTypeTypeExpCSParserRuleCall_2_0; }
	}

	public class CollectionLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnedTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOwnedTypeCollectionTypeCSParserRuleCall_0_0 = (RuleCall)cOwnedTypeAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cOwnedPartsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cOwnedPartsCollectionLiteralPartCSParserRuleCall_2_0_0 = (RuleCall)cOwnedPartsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cOwnedPartsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cOwnedPartsCollectionLiteralPartCSParserRuleCall_2_1_1_0 = (RuleCall)cOwnedPartsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////---------------------------------------------------------------------
		////  Literals
		////---------------------------------------------------------------------
		//CollectionLiteralExpCS:
		//	ownedType=CollectionTypeCS "{" (ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)? "}";
		public ParserRule getRule() { return rule; }

		//ownedType=CollectionTypeCS "{" (ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)? "}"
		public Group getGroup() { return cGroup; }

		//ownedType=CollectionTypeCS
		public Assignment getOwnedTypeAssignment_0() { return cOwnedTypeAssignment_0; }

		//CollectionTypeCS
		public RuleCall getOwnedTypeCollectionTypeCSParserRuleCall_0_0() { return cOwnedTypeCollectionTypeCSParserRuleCall_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)?
		public Group getGroup_2() { return cGroup_2; }

		//ownedParts+=CollectionLiteralPartCS
		public Assignment getOwnedPartsAssignment_2_0() { return cOwnedPartsAssignment_2_0; }

		//CollectionLiteralPartCS
		public RuleCall getOwnedPartsCollectionLiteralPartCSParserRuleCall_2_0_0() { return cOwnedPartsCollectionLiteralPartCSParserRuleCall_2_0_0; }

		//("," ownedParts+=CollectionLiteralPartCS)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//ownedParts+=CollectionLiteralPartCS
		public Assignment getOwnedPartsAssignment_2_1_1() { return cOwnedPartsAssignment_2_1_1; }

		//CollectionLiteralPartCS
		public RuleCall getOwnedPartsCollectionLiteralPartCSParserRuleCall_2_1_1_0() { return cOwnedPartsCollectionLiteralPartCSParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class CollectionLiteralPartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionLiteralPartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionCSAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionCSExpCSParserRuleCall_0_0 = (RuleCall)cExpressionCSAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cLastExpressionCSAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLastExpressionCSExpCSParserRuleCall_1_1_0 = (RuleCall)cLastExpressionCSAssignment_1_1.eContents().get(0);
		
		//CollectionLiteralPartCS:
		//	expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?;
		public ParserRule getRule() { return rule; }

		//expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?
		public Group getGroup() { return cGroup; }

		//expressionCS=ExpCS
		public Assignment getExpressionCSAssignment_0() { return cExpressionCSAssignment_0; }

		//ExpCS
		public RuleCall getExpressionCSExpCSParserRuleCall_0_0() { return cExpressionCSExpCSParserRuleCall_0_0; }

		//(".." lastExpressionCS=ExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//".."
		public Keyword getFullStopFullStopKeyword_1_0() { return cFullStopFullStopKeyword_1_0; }

		//lastExpressionCS=ExpCS
		public Assignment getLastExpressionCSAssignment_1_1() { return cLastExpressionCSAssignment_1_1; }

		//ExpCS
		public RuleCall getLastExpressionCSExpCSParserRuleCall_1_1_0() { return cLastExpressionCSExpCSParserRuleCall_1_1_0; }
	}

	public class ConstructorPartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstructorPartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPropertyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cPropertyPropertyCrossReference_0_0 = (CrossReference)cPropertyAssignment_0.eContents().get(0);
		private final RuleCall cPropertyPropertyUnrestrictedNameParserRuleCall_0_0_1 = (RuleCall)cPropertyPropertyCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitExpressionExpCSParserRuleCall_2_0 = (RuleCall)cInitExpressionAssignment_2.eContents().get(0);
		
		//ConstructorPartCS:
		//	property=[pivot::Property|UnrestrictedName] "=" initExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//property=[pivot::Property|UnrestrictedName] "=" initExpression=ExpCS
		public Group getGroup() { return cGroup; }

		//property=[pivot::Property|UnrestrictedName]
		public Assignment getPropertyAssignment_0() { return cPropertyAssignment_0; }

		//[pivot::Property|UnrestrictedName]
		public CrossReference getPropertyPropertyCrossReference_0_0() { return cPropertyPropertyCrossReference_0_0; }

		//UnrestrictedName
		public RuleCall getPropertyPropertyUnrestrictedNameParserRuleCall_0_0_1() { return cPropertyPropertyUnrestrictedNameParserRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//initExpression=ExpCS
		public Assignment getInitExpressionAssignment_2() { return cInitExpressionAssignment_2; }

		//ExpCS
		public RuleCall getInitExpressionExpCSParserRuleCall_2_0() { return cInitExpressionExpCSParserRuleCall_2_0; }
	}

	public class PrimitiveLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveLiteralExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanLiteralExpCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnlimitedNaturalLiteralExpCSParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cInvalidLiteralExpCSParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cNullLiteralExpCSParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//PrimitiveLiteralExpCS:
		//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
		//	NullLiteralExpCS;
		public ParserRule getRule() { return rule; }

		//NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
		//NullLiteralExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteralExpCS
		public RuleCall getNumberLiteralExpCSParserRuleCall_0() { return cNumberLiteralExpCSParserRuleCall_0; }

		//StringLiteralExpCS
		public RuleCall getStringLiteralExpCSParserRuleCall_1() { return cStringLiteralExpCSParserRuleCall_1; }

		//BooleanLiteralExpCS
		public RuleCall getBooleanLiteralExpCSParserRuleCall_2() { return cBooleanLiteralExpCSParserRuleCall_2; }

		//UnlimitedNaturalLiteralExpCS
		public RuleCall getUnlimitedNaturalLiteralExpCSParserRuleCall_3() { return cUnlimitedNaturalLiteralExpCSParserRuleCall_3; }

		//InvalidLiteralExpCS
		public RuleCall getInvalidLiteralExpCSParserRuleCall_4() { return cInvalidLiteralExpCSParserRuleCall_4; }

		//NullLiteralExpCS
		public RuleCall getNullLiteralExpCSParserRuleCall_5() { return cNullLiteralExpCSParserRuleCall_5; }
	}

	public class TupleLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTupleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOwnedPartsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedPartsTupleLiteralPartCSParserRuleCall_2_0 = (RuleCall)cOwnedPartsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cOwnedPartsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOwnedPartsTupleLiteralPartCSParserRuleCall_3_1_0 = (RuleCall)cOwnedPartsAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TupleLiteralExpCS:
		//	"Tuple" "{" ownedParts+=TupleLiteralPartCS ("," ownedParts+=TupleLiteralPartCS)* "}";
		public ParserRule getRule() { return rule; }

		//"Tuple" "{" ownedParts+=TupleLiteralPartCS ("," ownedParts+=TupleLiteralPartCS)* "}"
		public Group getGroup() { return cGroup; }

		//"Tuple"
		public Keyword getTupleKeyword_0() { return cTupleKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//ownedParts+=TupleLiteralPartCS
		public Assignment getOwnedPartsAssignment_2() { return cOwnedPartsAssignment_2; }

		//TupleLiteralPartCS
		public RuleCall getOwnedPartsTupleLiteralPartCSParserRuleCall_2_0() { return cOwnedPartsTupleLiteralPartCSParserRuleCall_2_0; }

		//("," ownedParts+=TupleLiteralPartCS)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//ownedParts+=TupleLiteralPartCS
		public Assignment getOwnedPartsAssignment_3_1() { return cOwnedPartsAssignment_3_1; }

		//TupleLiteralPartCS
		public RuleCall getOwnedPartsTupleLiteralPartCSParserRuleCall_3_1_0() { return cOwnedPartsTupleLiteralPartCSParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class TupleLiteralPartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleLiteralPartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cOwnedTypeAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInitExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInitExpressionExpCSParserRuleCall_3_0 = (RuleCall)cInitExpressionAssignment_3.eContents().get(0);
		
		//TupleLiteralPartCS:
		//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS
		public Group getGroup() { return cGroup; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0_0() { return cNameUnrestrictedNameParserRuleCall_0_0; }

		//(":" ownedType=TypeExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_1_1() { return cOwnedTypeAssignment_1_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_1_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_1_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//initExpression=ExpCS
		public Assignment getInitExpressionAssignment_3() { return cInitExpressionAssignment_3; }

		//ExpCS
		public RuleCall getInitExpressionExpCSParserRuleCall_3_0() { return cInitExpressionExpCSParserRuleCall_3_0; }
	}

	public class NumberLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteralExpCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameNUMBER_LITERALParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//NumberLiteralExpCS:
		//	name=NUMBER_LITERAL;
		public ParserRule getRule() { return rule; }

		//name=NUMBER_LITERAL
		public Assignment getNameAssignment() { return cNameAssignment; }

		//NUMBER_LITERAL
		public RuleCall getNameNUMBER_LITERALParserRuleCall_0() { return cNameNUMBER_LITERALParserRuleCall_0; }
	}

	public class StringLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteralExpCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameStringLiteralParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//StringLiteralExpCS:
		//	name+=StringLiteral+;
		public ParserRule getRule() { return rule; }

		//name+=StringLiteral+
		public Assignment getNameAssignment() { return cNameAssignment; }

		//StringLiteral
		public RuleCall getNameStringLiteralParserRuleCall_0() { return cNameStringLiteralParserRuleCall_0; }
	}

	public class BooleanLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteralExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cNameTrueKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cNameFalseKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//BooleanLiteralExpCS:
		//	name="true" | name="false";
		public ParserRule getRule() { return rule; }

		//name="true" | name="false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//name="true"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"true"
		public Keyword getNameTrueKeyword_0_0() { return cNameTrueKeyword_0_0; }

		//name="false"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//"false"
		public Keyword getNameFalseKeyword_1_0() { return cNameFalseKeyword_1_0; }
	}

	public class UnlimitedNaturalLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnlimitedNaturalLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnlimitedNaturalLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//UnlimitedNaturalLiteralExpCS:
		//	{UnlimitedNaturalLiteralExpCS} "*";
		public ParserRule getRule() { return rule; }

		//{UnlimitedNaturalLiteralExpCS} "*"
		public Group getGroup() { return cGroup; }

		//{UnlimitedNaturalLiteralExpCS}
		public Action getUnlimitedNaturalLiteralExpCSAction_0() { return cUnlimitedNaturalLiteralExpCSAction_0; }

		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}

	public class InvalidLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InvalidLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInvalidLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInvalidKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//InvalidLiteralExpCS:
		//	{InvalidLiteralExpCS} "invalid";
		public ParserRule getRule() { return rule; }

		//{InvalidLiteralExpCS} "invalid"
		public Group getGroup() { return cGroup; }

		//{InvalidLiteralExpCS}
		public Action getInvalidLiteralExpCSAction_0() { return cInvalidLiteralExpCSAction_0; }

		//"invalid"
		public Keyword getInvalidKeyword_1() { return cInvalidKeyword_1; }
	}

	public class NullLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullLiteralExpCS:
		//	{NullLiteralExpCS} "null";
		public ParserRule getRule() { return rule; }

		//{NullLiteralExpCS} "null"
		public Group getGroup() { return cGroup; }

		//{NullLiteralExpCS}
		public Action getNullLiteralExpCSAction_0() { return cNullLiteralExpCSAction_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class TypeLiteralCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeLiteralCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveTypeCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCollectionTypeCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTupleTypeCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//TypeLiteralCS returns base::TypedRefCS:
		//	PrimitiveTypeCS | CollectionTypeCS | TupleTypeCS;
		public ParserRule getRule() { return rule; }

		//PrimitiveTypeCS | CollectionTypeCS | TupleTypeCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimitiveTypeCS
		public RuleCall getPrimitiveTypeCSParserRuleCall_0() { return cPrimitiveTypeCSParserRuleCall_0; }

		//CollectionTypeCS
		public RuleCall getCollectionTypeCSParserRuleCall_1() { return cCollectionTypeCSParserRuleCall_1; }

		//TupleTypeCS
		public RuleCall getTupleTypeCSParserRuleCall_2() { return cTupleTypeCSParserRuleCall_2; }
	}

	public class TypeLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeLiteralExpCS");
		private final Assignment cOwnedTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOwnedTypeTypeLiteralCSParserRuleCall_0 = (RuleCall)cOwnedTypeAssignment.eContents().get(0);
		
		//TypeLiteralExpCS:
		//	ownedType=TypeLiteralCS;
		public ParserRule getRule() { return rule; }

		//ownedType=TypeLiteralCS
		public Assignment getOwnedTypeAssignment() { return cOwnedTypeAssignment; }

		//TypeLiteralCS
		public RuleCall getOwnedTypeTypeLiteralCSParserRuleCall_0() { return cOwnedTypeTypeLiteralCSParserRuleCall_0; }
	}

	public class TypeNameExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeNameExpCS");
		private final Assignment cPathNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPathNamePathNameCSParserRuleCall_0 = (RuleCall)cPathNameAssignment.eContents().get(0);
		
		//TypeNameExpCS:
		//	pathName=PathNameCS;
		public ParserRule getRule() { return rule; }

		//pathName=PathNameCS
		public Assignment getPathNameAssignment() { return cPathNameAssignment; }

		//PathNameCS
		public RuleCall getPathNamePathNameCSParserRuleCall_0() { return cPathNamePathNameCSParserRuleCall_0; }
	}

	public class TypeExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cTypeNameExpCSParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cTypeLiteralCSParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Assignment cMultiplicityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMultiplicityMultiplicityCSParserRuleCall_1_0 = (RuleCall)cMultiplicityAssignment_1.eContents().get(0);
		
		//TypeExpCS returns base::TypedRefCS:
		//	(TypeNameExpCS | TypeLiteralCS) multiplicity=MultiplicityCS?;
		public ParserRule getRule() { return rule; }

		//(TypeNameExpCS | TypeLiteralCS) multiplicity=MultiplicityCS?
		public Group getGroup() { return cGroup; }

		//TypeNameExpCS | TypeLiteralCS
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//TypeNameExpCS
		public RuleCall getTypeNameExpCSParserRuleCall_0_0() { return cTypeNameExpCSParserRuleCall_0_0; }

		//TypeLiteralCS
		public RuleCall getTypeLiteralCSParserRuleCall_0_1() { return cTypeLiteralCSParserRuleCall_0_1; }

		//multiplicity=MultiplicityCS?
		public Assignment getMultiplicityAssignment_1() { return cMultiplicityAssignment_1; }

		//MultiplicityCS
		public RuleCall getMultiplicityMultiplicityCSParserRuleCall_1_0() { return cMultiplicityMultiplicityCSParserRuleCall_1_0; }
	}

	public class ExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cInfixExpCSAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOwnedExpressionAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOwnedExpressionPrefixedExpCSParserRuleCall_0_1_0 = (RuleCall)cOwnedExpressionAssignment_0_1.eContents().get(0);
		private final Assignment cOwnedOperatorAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOwnedOperatorBinaryOperatorCSParserRuleCall_0_2_0 = (RuleCall)cOwnedOperatorAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Assignment cOwnedExpressionAssignment_0_3_0 = (Assignment)cGroup_0_3.eContents().get(0);
		private final RuleCall cOwnedExpressionPrefixedExpCSParserRuleCall_0_3_0_0 = (RuleCall)cOwnedExpressionAssignment_0_3_0.eContents().get(0);
		private final Assignment cOwnedOperatorAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cOwnedOperatorBinaryOperatorCSParserRuleCall_0_3_1_0 = (RuleCall)cOwnedOperatorAssignment_0_3_1.eContents().get(0);
		private final Assignment cOwnedExpressionAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cOwnedExpressionPrefixedExpOrLetExpCSParserRuleCall_0_4_0 = (RuleCall)cOwnedExpressionAssignment_0_4.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrefixExpCSAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOwnedOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0 = (RuleCall)cOwnedOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOwnedExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOwnedExpressionPrimaryExpOrLetExpCSParserRuleCall_1_2_0 = (RuleCall)cOwnedExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cPrimaryExpOrLetExpCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////---------------------------------------------------------------------
		////  Expressions
		////---------------------------------------------------------------------
		//// An ExpCS permits a LetExpCS only in the final term to ensure
		////  that let is right associative, whereas infix operators are left associative.
		////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
		//// is
		////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
		//ExpCS:
		//	{InfixExpCS} ownedExpression+=PrefixedExpCS ownedOperator+=BinaryOperatorCS (ownedExpression+=PrefixedExpCS
		//	ownedOperator+=BinaryOperatorCS)* ownedExpression+=PrefixedExpOrLetExpCS | {PrefixExpCS}
		//	ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS | PrimaryExpOrLetExpCS;
		public ParserRule getRule() { return rule; }

		//{InfixExpCS} ownedExpression+=PrefixedExpCS ownedOperator+=BinaryOperatorCS (ownedExpression+=PrefixedExpCS
		//ownedOperator+=BinaryOperatorCS)* ownedExpression+=PrefixedExpOrLetExpCS | {PrefixExpCS}
		//ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS | PrimaryExpOrLetExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//{InfixExpCS} ownedExpression+=PrefixedExpCS ownedOperator+=BinaryOperatorCS (ownedExpression+=PrefixedExpCS
		//ownedOperator+=BinaryOperatorCS)* ownedExpression+=PrefixedExpOrLetExpCS
		public Group getGroup_0() { return cGroup_0; }

		//{InfixExpCS}
		public Action getInfixExpCSAction_0_0() { return cInfixExpCSAction_0_0; }

		//ownedExpression+=PrefixedExpCS
		public Assignment getOwnedExpressionAssignment_0_1() { return cOwnedExpressionAssignment_0_1; }

		//PrefixedExpCS
		public RuleCall getOwnedExpressionPrefixedExpCSParserRuleCall_0_1_0() { return cOwnedExpressionPrefixedExpCSParserRuleCall_0_1_0; }

		//ownedOperator+=BinaryOperatorCS
		public Assignment getOwnedOperatorAssignment_0_2() { return cOwnedOperatorAssignment_0_2; }

		//BinaryOperatorCS
		public RuleCall getOwnedOperatorBinaryOperatorCSParserRuleCall_0_2_0() { return cOwnedOperatorBinaryOperatorCSParserRuleCall_0_2_0; }

		//(ownedExpression+=PrefixedExpCS ownedOperator+=BinaryOperatorCS)*
		public Group getGroup_0_3() { return cGroup_0_3; }

		//ownedExpression+=PrefixedExpCS
		public Assignment getOwnedExpressionAssignment_0_3_0() { return cOwnedExpressionAssignment_0_3_0; }

		//PrefixedExpCS
		public RuleCall getOwnedExpressionPrefixedExpCSParserRuleCall_0_3_0_0() { return cOwnedExpressionPrefixedExpCSParserRuleCall_0_3_0_0; }

		//ownedOperator+=BinaryOperatorCS
		public Assignment getOwnedOperatorAssignment_0_3_1() { return cOwnedOperatorAssignment_0_3_1; }

		//BinaryOperatorCS
		public RuleCall getOwnedOperatorBinaryOperatorCSParserRuleCall_0_3_1_0() { return cOwnedOperatorBinaryOperatorCSParserRuleCall_0_3_1_0; }

		//ownedExpression+=PrefixedExpOrLetExpCS
		public Assignment getOwnedExpressionAssignment_0_4() { return cOwnedExpressionAssignment_0_4; }

		//PrefixedExpOrLetExpCS
		public RuleCall getOwnedExpressionPrefixedExpOrLetExpCSParserRuleCall_0_4_0() { return cOwnedExpressionPrefixedExpOrLetExpCSParserRuleCall_0_4_0; }

		//{PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS
		public Group getGroup_1() { return cGroup_1; }

		//{PrefixExpCS}
		public Action getPrefixExpCSAction_1_0() { return cPrefixExpCSAction_1_0; }

		//ownedOperator+=UnaryOperatorCS+
		public Assignment getOwnedOperatorAssignment_1_1() { return cOwnedOperatorAssignment_1_1; }

		//UnaryOperatorCS
		public RuleCall getOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0() { return cOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0; }

		//ownedExpression=PrimaryExpOrLetExpCS
		public Assignment getOwnedExpressionAssignment_1_2() { return cOwnedExpressionAssignment_1_2; }

		//PrimaryExpOrLetExpCS
		public RuleCall getOwnedExpressionPrimaryExpOrLetExpCSParserRuleCall_1_2_0() { return cOwnedExpressionPrimaryExpOrLetExpCSParserRuleCall_1_2_0; }

		//PrimaryExpOrLetExpCS
		public RuleCall getPrimaryExpOrLetExpCSParserRuleCall_2() { return cPrimaryExpOrLetExpCSParserRuleCall_2; }
	}

	public class BinaryOperatorCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BinaryOperatorCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInfixOperatorCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNavigationOperatorCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BinaryOperatorCS:
		//	InfixOperatorCS | NavigationOperatorCS;
		public ParserRule getRule() { return rule; }

		//InfixOperatorCS | NavigationOperatorCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//InfixOperatorCS
		public RuleCall getInfixOperatorCSParserRuleCall_0() { return cInfixOperatorCSParserRuleCall_0; }

		//NavigationOperatorCS
		public RuleCall getNavigationOperatorCSParserRuleCall_1() { return cNavigationOperatorCSParserRuleCall_1; }
	}

	public class InfixOperatorCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixOperatorCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameInfixOperatorParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//InfixOperatorCS returns BinaryOperatorCS:
		//	name=InfixOperator;
		public ParserRule getRule() { return rule; }

		//name=InfixOperator
		public Assignment getNameAssignment() { return cNameAssignment; }

		//InfixOperator
		public RuleCall getNameInfixOperatorParserRuleCall_0() { return cNameInfixOperatorParserRuleCall_0; }
	}

	public class NavigationOperatorCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigationOperatorCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameNavigationOperatorParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//NavigationOperatorCS:
		//	name=NavigationOperator;
		public ParserRule getRule() { return rule; }

		//name=NavigationOperator
		public Assignment getNameAssignment() { return cNameAssignment; }

		//NavigationOperator
		public RuleCall getNameNavigationOperatorParserRuleCall_0() { return cNameNavigationOperatorParserRuleCall_0; }
	}

	public class PrefixedExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrefixedExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrefixExpCSAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOwnedOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0 = (RuleCall)cOwnedOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOwnedExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOwnedExpressionPrimaryExpCSParserRuleCall_1_2_0 = (RuleCall)cOwnedExpressionAssignment_1_2.eContents().get(0);
		
		//PrefixedExpCS returns ExpCS:
		//	PrimaryExpCS | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpCS;
		public ParserRule getRule() { return rule; }

		//PrimaryExpCS | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpCS
		public RuleCall getPrimaryExpCSParserRuleCall_0() { return cPrimaryExpCSParserRuleCall_0; }

		//{PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpCS
		public Group getGroup_1() { return cGroup_1; }

		//{PrefixExpCS}
		public Action getPrefixExpCSAction_1_0() { return cPrefixExpCSAction_1_0; }

		//ownedOperator+=UnaryOperatorCS+
		public Assignment getOwnedOperatorAssignment_1_1() { return cOwnedOperatorAssignment_1_1; }

		//UnaryOperatorCS
		public RuleCall getOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0() { return cOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0; }

		//ownedExpression=PrimaryExpCS
		public Assignment getOwnedExpressionAssignment_1_2() { return cOwnedExpressionAssignment_1_2; }

		//PrimaryExpCS
		public RuleCall getOwnedExpressionPrimaryExpCSParserRuleCall_1_2_0() { return cOwnedExpressionPrimaryExpCSParserRuleCall_1_2_0; }
	}

	public class PrefixedExpOrLetExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrefixedExpOrLetExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpOrLetExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrefixExpCSAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOwnedOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0 = (RuleCall)cOwnedOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOwnedExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOwnedExpressionPrimaryExpOrLetExpCSParserRuleCall_1_2_0 = (RuleCall)cOwnedExpressionAssignment_1_2.eContents().get(0);
		
		//PrefixedExpOrLetExpCS returns ExpCS:
		//	PrimaryExpOrLetExpCS | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS;
		public ParserRule getRule() { return rule; }

		//PrimaryExpOrLetExpCS | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpOrLetExpCS
		public RuleCall getPrimaryExpOrLetExpCSParserRuleCall_0() { return cPrimaryExpOrLetExpCSParserRuleCall_0; }

		//{PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS
		public Group getGroup_1() { return cGroup_1; }

		//{PrefixExpCS}
		public Action getPrefixExpCSAction_1_0() { return cPrefixExpCSAction_1_0; }

		//ownedOperator+=UnaryOperatorCS+
		public Assignment getOwnedOperatorAssignment_1_1() { return cOwnedOperatorAssignment_1_1; }

		//UnaryOperatorCS
		public RuleCall getOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0() { return cOwnedOperatorUnaryOperatorCSParserRuleCall_1_1_0; }

		//ownedExpression=PrimaryExpOrLetExpCS
		public Assignment getOwnedExpressionAssignment_1_2() { return cOwnedExpressionAssignment_1_2; }

		//PrimaryExpOrLetExpCS
		public RuleCall getOwnedExpressionPrimaryExpOrLetExpCSParserRuleCall_1_2_0() { return cOwnedExpressionPrimaryExpOrLetExpCSParserRuleCall_1_2_0; }
	}

	public class UnaryOperatorCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperatorCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNamePrefixOperatorParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//UnaryOperatorCS:
		//	name=PrefixOperator;
		public ParserRule getRule() { return rule; }

		//name=PrefixOperator
		public Assignment getNameAssignment() { return cNameAssignment; }

		//PrefixOperator
		public RuleCall getNamePrefixOperatorParserRuleCall_0() { return cNamePrefixOperatorParserRuleCall_0; }
	}

	public class PrimaryExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIndexExpCSAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cPathNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cPathNamePathNameCSParserRuleCall_0_1_0 = (RuleCall)cPathNameAssignment_0_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cFirstIndexesAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cFirstIndexesExpCSParserRuleCall_0_3_0 = (RuleCall)cFirstIndexesAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cCommaKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cFirstIndexesAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cFirstIndexesExpCSParserRuleCall_0_4_1_0 = (RuleCall)cFirstIndexesAssignment_0_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_0_6 = (Group)cGroup_0.eContents().get(6);
		private final Keyword cLeftSquareBracketKeyword_0_6_0 = (Keyword)cGroup_0_6.eContents().get(0);
		private final Assignment cSecondIndexesAssignment_0_6_1 = (Assignment)cGroup_0_6.eContents().get(1);
		private final RuleCall cSecondIndexesExpCSParserRuleCall_0_6_1_0 = (RuleCall)cSecondIndexesAssignment_0_6_1.eContents().get(0);
		private final Group cGroup_0_6_2 = (Group)cGroup_0_6.eContents().get(2);
		private final Keyword cCommaKeyword_0_6_2_0 = (Keyword)cGroup_0_6_2.eContents().get(0);
		private final Assignment cSecondIndexesAssignment_0_6_2_1 = (Assignment)cGroup_0_6_2.eContents().get(1);
		private final RuleCall cSecondIndexesExpCSParserRuleCall_0_6_2_1_0 = (RuleCall)cSecondIndexesAssignment_0_6_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_6_3 = (Keyword)cGroup_0_6.eContents().get(3);
		private final Group cGroup_0_7 = (Group)cGroup_0.eContents().get(7);
		private final Assignment cAtPreAssignment_0_7_0 = (Assignment)cGroup_0_7.eContents().get(0);
		private final Keyword cAtPreCommercialAtKeyword_0_7_0_0 = (Keyword)cAtPreAssignment_0_7_0.eContents().get(0);
		private final Keyword cPreKeyword_0_7_1 = (Keyword)cGroup_0_7.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cConstructorExpCSAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cPathNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPathNamePathNameCSParserRuleCall_1_1_0 = (RuleCall)cPathNameAssignment_1_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cOwnedPartsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cOwnedPartsConstructorPartCSParserRuleCall_1_3_0 = (RuleCall)cOwnedPartsAssignment_1_3.eContents().get(0);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Keyword cCommaKeyword_1_4_0 = (Keyword)cGroup_1_4.eContents().get(0);
		private final Assignment cOwnedPartsAssignment_1_4_1 = (Assignment)cGroup_1_4.eContents().get(1);
		private final RuleCall cOwnedPartsConstructorPartCSParserRuleCall_1_4_1_0 = (RuleCall)cOwnedPartsAssignment_1_4_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cInvocationExpCSAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cPathNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPathNamePathNameCSParserRuleCall_2_1_0 = (RuleCall)cPathNameAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Assignment cAtPreAssignment_2_2_0 = (Assignment)cGroup_2_2.eContents().get(0);
		private final Keyword cAtPreCommercialAtKeyword_2_2_0_0 = (Keyword)cAtPreAssignment_2_2_0.eContents().get(0);
		private final Keyword cPreKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Group cGroup_2_4 = (Group)cGroup_2.eContents().get(4);
		private final Assignment cArgumentAssignment_2_4_0 = (Assignment)cGroup_2_4.eContents().get(0);
		private final RuleCall cArgumentNavigatingArgCSParserRuleCall_2_4_0_0 = (RuleCall)cArgumentAssignment_2_4_0.eContents().get(0);
		private final Assignment cArgumentAssignment_2_4_1 = (Assignment)cGroup_2_4.eContents().get(1);
		private final RuleCall cArgumentNavigatingCommaArgCSParserRuleCall_2_4_1_0 = (RuleCall)cArgumentAssignment_2_4_1.eContents().get(0);
		private final Group cGroup_2_4_2 = (Group)cGroup_2_4.eContents().get(2);
		private final Assignment cArgumentAssignment_2_4_2_0 = (Assignment)cGroup_2_4_2.eContents().get(0);
		private final RuleCall cArgumentNavigatingSemiArgCSParserRuleCall_2_4_2_0_0 = (RuleCall)cArgumentAssignment_2_4_2_0.eContents().get(0);
		private final Assignment cArgumentAssignment_2_4_2_1 = (Assignment)cGroup_2_4_2.eContents().get(1);
		private final RuleCall cArgumentNavigatingCommaArgCSParserRuleCall_2_4_2_1_0 = (RuleCall)cArgumentAssignment_2_4_2_1.eContents().get(0);
		private final Group cGroup_2_4_3 = (Group)cGroup_2_4.eContents().get(3);
		private final Assignment cArgumentAssignment_2_4_3_0 = (Assignment)cGroup_2_4_3.eContents().get(0);
		private final RuleCall cArgumentNavigatingBarArgCSParserRuleCall_2_4_3_0_0 = (RuleCall)cArgumentAssignment_2_4_3_0.eContents().get(0);
		private final Assignment cArgumentAssignment_2_4_3_1 = (Assignment)cGroup_2_4_3.eContents().get(1);
		private final RuleCall cArgumentNavigatingCommaArgCSParserRuleCall_2_4_3_1_0 = (RuleCall)cArgumentAssignment_2_4_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cNameExpCSAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cPathNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cPathNamePathNameCSParserRuleCall_3_1_0 = (RuleCall)cPathNameAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Assignment cAtPreAssignment_3_2_0 = (Assignment)cGroup_3_2.eContents().get(0);
		private final Keyword cAtPreCommercialAtKeyword_3_2_0_0 = (Keyword)cAtPreAssignment_3_2_0.eContents().get(0);
		private final Keyword cPreKeyword_3_2_1 = (Keyword)cGroup_3_2.eContents().get(1);
		private final RuleCall cSelfExpCSParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cPrimitiveLiteralExpCSParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cTupleLiteralExpCSParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cCollectionLiteralExpCSParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cTypeLiteralExpCSParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cIfExpCSParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cNestedExpCSParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		//// These rules are ordered most rejectable first
		//PrimaryExpCS returns ExpCS:
		//	{IndexExpCS} pathName=PathNameCS "[" firstIndexes+=ExpCS ("," firstIndexes+=ExpCS)* "]" ("[" secondIndexes+=ExpCS (","
		//	secondIndexes+=ExpCS)* "]")? (atPre?="@" "pre")? | {ConstructorExpCS} pathName=PathNameCS "{"
		//	ownedParts+=ConstructorPartCS ("," ownedParts+=ConstructorPartCS)* "}" | {InvocationExpCS} pathName=PathNameCS
		//	(atPre?="@" "pre")? "(" (argument+=NavigatingArgCS argument+=NavigatingCommaArgCS* (argument+=NavigatingSemiArgCS
		//	argument+=NavigatingCommaArgCS*)? (argument+=NavigatingBarArgCS argument+=NavigatingCommaArgCS*)?)? ")" | {NameExpCS}
		//	pathName=PathNameCS (atPre?="@" "pre")? | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
		//	CollectionLiteralExpCS | TypeLiteralExpCS | IfExpCS | NestedExpCS;
		public ParserRule getRule() { return rule; }

		//{IndexExpCS} pathName=PathNameCS "[" firstIndexes+=ExpCS ("," firstIndexes+=ExpCS)* "]" ("[" secondIndexes+=ExpCS (","
		//secondIndexes+=ExpCS)* "]")? (atPre?="@" "pre")? | {ConstructorExpCS} pathName=PathNameCS "{"
		//ownedParts+=ConstructorPartCS ("," ownedParts+=ConstructorPartCS)* "}" | {InvocationExpCS} pathName=PathNameCS
		//(atPre?="@" "pre")? "(" (argument+=NavigatingArgCS argument+=NavigatingCommaArgCS* (argument+=NavigatingSemiArgCS
		//argument+=NavigatingCommaArgCS*)? (argument+=NavigatingBarArgCS argument+=NavigatingCommaArgCS*)?)? ")" | {NameExpCS}
		//pathName=PathNameCS (atPre?="@" "pre")? | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
		//CollectionLiteralExpCS | TypeLiteralExpCS | IfExpCS | NestedExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//{IndexExpCS} pathName=PathNameCS "[" firstIndexes+=ExpCS ("," firstIndexes+=ExpCS)* "]" ("[" secondIndexes+=ExpCS (","
		//secondIndexes+=ExpCS)* "]")? (atPre?="@" "pre")?
		public Group getGroup_0() { return cGroup_0; }

		//{IndexExpCS}
		public Action getIndexExpCSAction_0_0() { return cIndexExpCSAction_0_0; }

		//pathName=PathNameCS
		public Assignment getPathNameAssignment_0_1() { return cPathNameAssignment_0_1; }

		//PathNameCS
		public RuleCall getPathNamePathNameCSParserRuleCall_0_1_0() { return cPathNamePathNameCSParserRuleCall_0_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_2() { return cLeftSquareBracketKeyword_0_2; }

		//firstIndexes+=ExpCS
		public Assignment getFirstIndexesAssignment_0_3() { return cFirstIndexesAssignment_0_3; }

		//ExpCS
		public RuleCall getFirstIndexesExpCSParserRuleCall_0_3_0() { return cFirstIndexesExpCSParserRuleCall_0_3_0; }

		//("," firstIndexes+=ExpCS)*
		public Group getGroup_0_4() { return cGroup_0_4; }

		//","
		public Keyword getCommaKeyword_0_4_0() { return cCommaKeyword_0_4_0; }

		//firstIndexes+=ExpCS
		public Assignment getFirstIndexesAssignment_0_4_1() { return cFirstIndexesAssignment_0_4_1; }

		//ExpCS
		public RuleCall getFirstIndexesExpCSParserRuleCall_0_4_1_0() { return cFirstIndexesExpCSParserRuleCall_0_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_5() { return cRightSquareBracketKeyword_0_5; }

		//("[" secondIndexes+=ExpCS ("," secondIndexes+=ExpCS)* "]")?
		public Group getGroup_0_6() { return cGroup_0_6; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_6_0() { return cLeftSquareBracketKeyword_0_6_0; }

		//secondIndexes+=ExpCS
		public Assignment getSecondIndexesAssignment_0_6_1() { return cSecondIndexesAssignment_0_6_1; }

		//ExpCS
		public RuleCall getSecondIndexesExpCSParserRuleCall_0_6_1_0() { return cSecondIndexesExpCSParserRuleCall_0_6_1_0; }

		//("," secondIndexes+=ExpCS)*
		public Group getGroup_0_6_2() { return cGroup_0_6_2; }

		//","
		public Keyword getCommaKeyword_0_6_2_0() { return cCommaKeyword_0_6_2_0; }

		//secondIndexes+=ExpCS
		public Assignment getSecondIndexesAssignment_0_6_2_1() { return cSecondIndexesAssignment_0_6_2_1; }

		//ExpCS
		public RuleCall getSecondIndexesExpCSParserRuleCall_0_6_2_1_0() { return cSecondIndexesExpCSParserRuleCall_0_6_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_6_3() { return cRightSquareBracketKeyword_0_6_3; }

		//(atPre?="@" "pre")?
		public Group getGroup_0_7() { return cGroup_0_7; }

		//atPre?="@"
		public Assignment getAtPreAssignment_0_7_0() { return cAtPreAssignment_0_7_0; }

		//"@"
		public Keyword getAtPreCommercialAtKeyword_0_7_0_0() { return cAtPreCommercialAtKeyword_0_7_0_0; }

		//"pre"
		public Keyword getPreKeyword_0_7_1() { return cPreKeyword_0_7_1; }

		//{ConstructorExpCS} pathName=PathNameCS "{" ownedParts+=ConstructorPartCS ("," ownedParts+=ConstructorPartCS)* "}"
		public Group getGroup_1() { return cGroup_1; }

		//{ConstructorExpCS}
		public Action getConstructorExpCSAction_1_0() { return cConstructorExpCSAction_1_0; }

		//pathName=PathNameCS
		public Assignment getPathNameAssignment_1_1() { return cPathNameAssignment_1_1; }

		//PathNameCS
		public RuleCall getPathNamePathNameCSParserRuleCall_1_1_0() { return cPathNamePathNameCSParserRuleCall_1_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_2() { return cLeftCurlyBracketKeyword_1_2; }

		//ownedParts+=ConstructorPartCS
		public Assignment getOwnedPartsAssignment_1_3() { return cOwnedPartsAssignment_1_3; }

		//ConstructorPartCS
		public RuleCall getOwnedPartsConstructorPartCSParserRuleCall_1_3_0() { return cOwnedPartsConstructorPartCSParserRuleCall_1_3_0; }

		//("," ownedParts+=ConstructorPartCS)*
		public Group getGroup_1_4() { return cGroup_1_4; }

		//","
		public Keyword getCommaKeyword_1_4_0() { return cCommaKeyword_1_4_0; }

		//ownedParts+=ConstructorPartCS
		public Assignment getOwnedPartsAssignment_1_4_1() { return cOwnedPartsAssignment_1_4_1; }

		//ConstructorPartCS
		public RuleCall getOwnedPartsConstructorPartCSParserRuleCall_1_4_1_0() { return cOwnedPartsConstructorPartCSParserRuleCall_1_4_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }

		//{InvocationExpCS} pathName=PathNameCS (atPre?="@" "pre")? "(" (argument+=NavigatingArgCS argument+=NavigatingCommaArgCS*
		//(argument+=NavigatingSemiArgCS argument+=NavigatingCommaArgCS*)? (argument+=NavigatingBarArgCS
		//argument+=NavigatingCommaArgCS*)?)? ")"
		public Group getGroup_2() { return cGroup_2; }

		//{InvocationExpCS}
		public Action getInvocationExpCSAction_2_0() { return cInvocationExpCSAction_2_0; }

		//pathName=PathNameCS
		public Assignment getPathNameAssignment_2_1() { return cPathNameAssignment_2_1; }

		//PathNameCS
		public RuleCall getPathNamePathNameCSParserRuleCall_2_1_0() { return cPathNamePathNameCSParserRuleCall_2_1_0; }

		//(atPre?="@" "pre")?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//atPre?="@"
		public Assignment getAtPreAssignment_2_2_0() { return cAtPreAssignment_2_2_0; }

		//"@"
		public Keyword getAtPreCommercialAtKeyword_2_2_0_0() { return cAtPreCommercialAtKeyword_2_2_0_0; }

		//"pre"
		public Keyword getPreKeyword_2_2_1() { return cPreKeyword_2_2_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_3() { return cLeftParenthesisKeyword_2_3; }

		//(argument+=NavigatingArgCS argument+=NavigatingCommaArgCS* (argument+=NavigatingSemiArgCS
		//argument+=NavigatingCommaArgCS*)? (argument+=NavigatingBarArgCS argument+=NavigatingCommaArgCS*)?)?
		public Group getGroup_2_4() { return cGroup_2_4; }

		//argument+=NavigatingArgCS
		public Assignment getArgumentAssignment_2_4_0() { return cArgumentAssignment_2_4_0; }

		//NavigatingArgCS
		public RuleCall getArgumentNavigatingArgCSParserRuleCall_2_4_0_0() { return cArgumentNavigatingArgCSParserRuleCall_2_4_0_0; }

		//argument+=NavigatingCommaArgCS*
		public Assignment getArgumentAssignment_2_4_1() { return cArgumentAssignment_2_4_1; }

		//NavigatingCommaArgCS
		public RuleCall getArgumentNavigatingCommaArgCSParserRuleCall_2_4_1_0() { return cArgumentNavigatingCommaArgCSParserRuleCall_2_4_1_0; }

		//(argument+=NavigatingSemiArgCS argument+=NavigatingCommaArgCS*)?
		public Group getGroup_2_4_2() { return cGroup_2_4_2; }

		//argument+=NavigatingSemiArgCS
		public Assignment getArgumentAssignment_2_4_2_0() { return cArgumentAssignment_2_4_2_0; }

		//NavigatingSemiArgCS
		public RuleCall getArgumentNavigatingSemiArgCSParserRuleCall_2_4_2_0_0() { return cArgumentNavigatingSemiArgCSParserRuleCall_2_4_2_0_0; }

		//argument+=NavigatingCommaArgCS*
		public Assignment getArgumentAssignment_2_4_2_1() { return cArgumentAssignment_2_4_2_1; }

		//NavigatingCommaArgCS
		public RuleCall getArgumentNavigatingCommaArgCSParserRuleCall_2_4_2_1_0() { return cArgumentNavigatingCommaArgCSParserRuleCall_2_4_2_1_0; }

		//(argument+=NavigatingBarArgCS argument+=NavigatingCommaArgCS*)?
		public Group getGroup_2_4_3() { return cGroup_2_4_3; }

		//argument+=NavigatingBarArgCS
		public Assignment getArgumentAssignment_2_4_3_0() { return cArgumentAssignment_2_4_3_0; }

		//NavigatingBarArgCS
		public RuleCall getArgumentNavigatingBarArgCSParserRuleCall_2_4_3_0_0() { return cArgumentNavigatingBarArgCSParserRuleCall_2_4_3_0_0; }

		//argument+=NavigatingCommaArgCS*
		public Assignment getArgumentAssignment_2_4_3_1() { return cArgumentAssignment_2_4_3_1; }

		//NavigatingCommaArgCS
		public RuleCall getArgumentNavigatingCommaArgCSParserRuleCall_2_4_3_1_0() { return cArgumentNavigatingCommaArgCSParserRuleCall_2_4_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_5() { return cRightParenthesisKeyword_2_5; }

		//{NameExpCS} pathName=PathNameCS (atPre?="@" "pre")?
		public Group getGroup_3() { return cGroup_3; }

		//{NameExpCS}
		public Action getNameExpCSAction_3_0() { return cNameExpCSAction_3_0; }

		//pathName=PathNameCS
		public Assignment getPathNameAssignment_3_1() { return cPathNameAssignment_3_1; }

		//PathNameCS
		public RuleCall getPathNamePathNameCSParserRuleCall_3_1_0() { return cPathNamePathNameCSParserRuleCall_3_1_0; }

		//(atPre?="@" "pre")?
		public Group getGroup_3_2() { return cGroup_3_2; }

		//atPre?="@"
		public Assignment getAtPreAssignment_3_2_0() { return cAtPreAssignment_3_2_0; }

		//"@"
		public Keyword getAtPreCommercialAtKeyword_3_2_0_0() { return cAtPreCommercialAtKeyword_3_2_0_0; }

		//"pre"
		public Keyword getPreKeyword_3_2_1() { return cPreKeyword_3_2_1; }

		//SelfExpCS
		public RuleCall getSelfExpCSParserRuleCall_4() { return cSelfExpCSParserRuleCall_4; }

		//PrimitiveLiteralExpCS
		public RuleCall getPrimitiveLiteralExpCSParserRuleCall_5() { return cPrimitiveLiteralExpCSParserRuleCall_5; }

		//TupleLiteralExpCS
		public RuleCall getTupleLiteralExpCSParserRuleCall_6() { return cTupleLiteralExpCSParserRuleCall_6; }

		//CollectionLiteralExpCS
		public RuleCall getCollectionLiteralExpCSParserRuleCall_7() { return cCollectionLiteralExpCSParserRuleCall_7; }

		//TypeLiteralExpCS
		public RuleCall getTypeLiteralExpCSParserRuleCall_8() { return cTypeLiteralExpCSParserRuleCall_8; }

		//IfExpCS
		public RuleCall getIfExpCSParserRuleCall_9() { return cIfExpCSParserRuleCall_9; }

		//NestedExpCS
		public RuleCall getNestedExpCSParserRuleCall_10() { return cNestedExpCSParserRuleCall_10; }
	}

	public class PrimaryExpOrLetExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpOrLetExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLetExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PrimaryExpOrLetExpCS returns ExpCS:
		//	PrimaryExpCS | LetExpCS;
		public ParserRule getRule() { return rule; }

		//PrimaryExpCS | LetExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpCS
		public RuleCall getPrimaryExpCSParserRuleCall_0() { return cPrimaryExpCSParserRuleCall_0; }

		//LetExpCS
		public RuleCall getLetExpCSParserRuleCall_1() { return cLetExpCSParserRuleCall_1; }
	}

	public class NavigatingArgCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigatingArgCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNavigatingArgExpCSParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cOwnedTypeAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cEqualsSignKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cInitAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cInitExpCSParserRuleCall_1_2_1_0 = (RuleCall)cInitAssignment_1_2_1.eContents().get(0);
		
		//// Type-less init is an illegal infix expression
		//NavigatingArgCS:
		//	name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
		public ParserRule getRule() { return rule; }

		//name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup() { return cGroup; }

		//name=NavigatingArgExpCS
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//NavigatingArgExpCS
		public RuleCall getNameNavigatingArgExpCSParserRuleCall_0_0() { return cNameNavigatingArgExpCSParserRuleCall_0_0; }

		//(":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_1_1() { return cOwnedTypeAssignment_1_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_1_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_1_1_0; }

		//("=" init=ExpCS)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"="
		public Keyword getEqualsSignKeyword_1_2_0() { return cEqualsSignKeyword_1_2_0; }

		//init=ExpCS
		public Assignment getInitAssignment_1_2_1() { return cInitAssignment_1_2_1; }

		//ExpCS
		public RuleCall getInitExpCSParserRuleCall_1_2_1_0() { return cInitExpCSParserRuleCall_1_2_1_0; }
	}

	public class NavigatingBarArgCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigatingBarArgCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrefixAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cPrefixVerticalLineKeyword_0_0 = (Keyword)cPrefixAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNavigatingArgExpCSParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_2_1_0 = (RuleCall)cOwnedTypeAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cEqualsSignKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cInitAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cInitExpCSParserRuleCall_2_2_1_0 = (RuleCall)cInitAssignment_2_2_1.eContents().get(0);
		
		//// Type-less init is an illegal infix expression
		//NavigatingBarArgCS returns NavigatingArgCS:
		//	prefix="|" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
		public ParserRule getRule() { return rule; }

		//prefix="|" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup() { return cGroup; }

		//prefix="|"
		public Assignment getPrefixAssignment_0() { return cPrefixAssignment_0; }

		//"|"
		public Keyword getPrefixVerticalLineKeyword_0_0() { return cPrefixVerticalLineKeyword_0_0; }

		//name=NavigatingArgExpCS
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//NavigatingArgExpCS
		public RuleCall getNameNavigatingArgExpCSParserRuleCall_1_0() { return cNameNavigatingArgExpCSParserRuleCall_1_0; }

		//(":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_2_1() { return cOwnedTypeAssignment_2_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_2_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_2_1_0; }

		//("=" init=ExpCS)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_0() { return cEqualsSignKeyword_2_2_0; }

		//init=ExpCS
		public Assignment getInitAssignment_2_2_1() { return cInitAssignment_2_2_1; }

		//ExpCS
		public RuleCall getInitExpCSParserRuleCall_2_2_1_0() { return cInitExpCSParserRuleCall_2_2_1_0; }
	}

	public class NavigatingCommaArgCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigatingCommaArgCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrefixAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cPrefixCommaKeyword_0_0 = (Keyword)cPrefixAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNavigatingArgExpCSParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_2_1_0 = (RuleCall)cOwnedTypeAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cEqualsSignKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cInitAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cInitExpCSParserRuleCall_2_2_1_0 = (RuleCall)cInitAssignment_2_2_1.eContents().get(0);
		
		//// Type-less init is an illegal infix expression
		//NavigatingCommaArgCS returns NavigatingArgCS:
		//	prefix="," name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
		public ParserRule getRule() { return rule; }

		//prefix="," name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup() { return cGroup; }

		//prefix=","
		public Assignment getPrefixAssignment_0() { return cPrefixAssignment_0; }

		//","
		public Keyword getPrefixCommaKeyword_0_0() { return cPrefixCommaKeyword_0_0; }

		//name=NavigatingArgExpCS
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//NavigatingArgExpCS
		public RuleCall getNameNavigatingArgExpCSParserRuleCall_1_0() { return cNameNavigatingArgExpCSParserRuleCall_1_0; }

		//(":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_2_1() { return cOwnedTypeAssignment_2_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_2_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_2_1_0; }

		//("=" init=ExpCS)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_0() { return cEqualsSignKeyword_2_2_0; }

		//init=ExpCS
		public Assignment getInitAssignment_2_2_1() { return cInitAssignment_2_2_1; }

		//ExpCS
		public RuleCall getInitExpCSParserRuleCall_2_2_1_0() { return cInitExpCSParserRuleCall_2_2_1_0; }
	}

	public class NavigatingSemiArgCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigatingSemiArgCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrefixAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cPrefixSemicolonKeyword_0_0 = (Keyword)cPrefixAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNavigatingArgExpCSParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_2_1_0 = (RuleCall)cOwnedTypeAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cEqualsSignKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cInitAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cInitExpCSParserRuleCall_2_2_1_0 = (RuleCall)cInitAssignment_2_2_1.eContents().get(0);
		
		//// Type-less init is an illegal infix expression
		//NavigatingSemiArgCS returns NavigatingArgCS:
		//	prefix=";" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
		public ParserRule getRule() { return rule; }

		//prefix=";" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup() { return cGroup; }

		//prefix=";"
		public Assignment getPrefixAssignment_0() { return cPrefixAssignment_0; }

		//";"
		public Keyword getPrefixSemicolonKeyword_0_0() { return cPrefixSemicolonKeyword_0_0; }

		//name=NavigatingArgExpCS
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//NavigatingArgExpCS
		public RuleCall getNameNavigatingArgExpCSParserRuleCall_1_0() { return cNameNavigatingArgExpCSParserRuleCall_1_0; }

		//(":" ownedType=TypeExpCS ("=" init=ExpCS)?)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_2_1() { return cOwnedTypeAssignment_2_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_2_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_2_1_0; }

		//("=" init=ExpCS)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"="
		public Keyword getEqualsSignKeyword_2_2_0() { return cEqualsSignKeyword_2_2_0; }

		//init=ExpCS
		public Assignment getInitAssignment_2_2_1() { return cInitAssignment_2_2_1; }

		//ExpCS
		public RuleCall getInitExpCSParserRuleCall_2_2_1_0() { return cInitExpCSParserRuleCall_2_2_1_0; }
	}

	public class NavigatingArgExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigatingArgExpCS");
		private final RuleCall cExpCSParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		////	'?'	-- defined by Complete OCL
		//NavigatingArgExpCS returns ExpCS:
		//	ExpCS;
		public ParserRule getRule() { return rule; }

		//ExpCS
		public RuleCall getExpCSParserRuleCall() { return cExpCSParserRuleCall; }
	}

	public class IfExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpCSParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExpressionExpCSParserRuleCall_3_0 = (RuleCall)cThenExpressionAssignment_3.eContents().get(0);
		private final Keyword cElseKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElseExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseExpressionExpCSParserRuleCall_5_0 = (RuleCall)cElseExpressionAssignment_5.eContents().get(0);
		private final Keyword cEndifKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IfExpCS:
		//	"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif";
		public ParserRule getRule() { return rule; }

		//"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif"
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condition=ExpCS
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//ExpCS
		public RuleCall getConditionExpCSParserRuleCall_1_0() { return cConditionExpCSParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//thenExpression=ExpCS
		public Assignment getThenExpressionAssignment_3() { return cThenExpressionAssignment_3; }

		//ExpCS
		public RuleCall getThenExpressionExpCSParserRuleCall_3_0() { return cThenExpressionExpCSParserRuleCall_3_0; }

		//"else"
		public Keyword getElseKeyword_4() { return cElseKeyword_4; }

		//elseExpression=ExpCS
		public Assignment getElseExpressionAssignment_5() { return cElseExpressionAssignment_5; }

		//ExpCS
		public RuleCall getElseExpressionExpCSParserRuleCall_5_0() { return cElseExpressionExpCSParserRuleCall_5_0; }

		//"endif"
		public Keyword getEndifKeyword_6() { return cEndifKeyword_6; }
	}

	public class LetExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableLetVariableCSParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariableAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariableLetVariableCSParserRuleCall_2_1_0 = (RuleCall)cVariableAssignment_2_1.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInExpCSParserRuleCall_4_0 = (RuleCall)cInAssignment_4.eContents().get(0);
		
		//LetExpCS:
		//	"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS;
		public ParserRule getRule() { return rule; }

		//"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS
		public Group getGroup() { return cGroup; }

		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }

		//variable+=LetVariableCS
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//LetVariableCS
		public RuleCall getVariableLetVariableCSParserRuleCall_1_0() { return cVariableLetVariableCSParserRuleCall_1_0; }

		//("," variable+=LetVariableCS)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//variable+=LetVariableCS
		public Assignment getVariableAssignment_2_1() { return cVariableAssignment_2_1; }

		//LetVariableCS
		public RuleCall getVariableLetVariableCSParserRuleCall_2_1_0() { return cVariableLetVariableCSParserRuleCall_2_1_0; }

		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }

		//in=ExpCS
		public Assignment getInAssignment_4() { return cInAssignment_4; }

		//ExpCS
		public RuleCall getInExpCSParserRuleCall_4_0() { return cInExpCSParserRuleCall_4_0; }
	}

	public class LetVariableCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetVariableCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedTypeTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cOwnedTypeAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInitExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInitExpressionExpCSParserRuleCall_3_0 = (RuleCall)cInitExpressionAssignment_3.eContents().get(0);
		
		//LetVariableCS:
		//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS
		public Group getGroup() { return cGroup; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0_0() { return cNameUnrestrictedNameParserRuleCall_0_0; }

		//(":" ownedType=TypeExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//ownedType=TypeExpCS
		public Assignment getOwnedTypeAssignment_1_1() { return cOwnedTypeAssignment_1_1; }

		//TypeExpCS
		public RuleCall getOwnedTypeTypeExpCSParserRuleCall_1_1_0() { return cOwnedTypeTypeExpCSParserRuleCall_1_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//initExpression=ExpCS
		public Assignment getInitExpressionAssignment_3() { return cInitExpressionAssignment_3; }

		//ExpCS
		public RuleCall getInitExpressionExpCSParserRuleCall_3_0() { return cInitExpressionExpCSParserRuleCall_3_0; }
	}

	public class NestedExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NestedExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSourceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSourceExpCSParserRuleCall_1_0 = (RuleCall)cSourceAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//NestedExpCS:
		//	"(" source=ExpCS ")";
		public ParserRule getRule() { return rule; }

		//"(" source=ExpCS ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//source=ExpCS
		public Assignment getSourceAssignment_1() { return cSourceAssignment_1; }

		//ExpCS
		public RuleCall getSourceExpCSParserRuleCall_1_0() { return cSourceExpCSParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class SelfExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelfExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelfExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSelfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//SelfExpCS:
		//	{SelfExpCS} "self";
		public ParserRule getRule() { return rule; }

		//{SelfExpCS} "self"
		public Group getGroup() { return cGroup; }

		//{SelfExpCS}
		public Action getSelfExpCSAction_0() { return cSelfExpCSAction_0; }

		//"self"
		public Keyword getSelfKeyword_1() { return cSelfKeyword_1; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tDOUBLE_QUOTED_STRING;
	private TerminalRule tSINGLE_QUOTED_STRING;
	private TerminalRule tML_SINGLE_QUOTED_STRING;
	private TerminalRule tSIMPLE_ID;
	private TerminalRule tESCAPED_ID;
	private IDElements pID;
	private TerminalRule tINT;
	private LOWERElements pLOWER;
	private UPPERElements pUPPER;
	private NUMBER_LITERALElements pNUMBER_LITERAL;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tANY_OTHER;
	private URIElements pURI;
	private EssentialOCLReservedKeywordElements pEssentialOCLReservedKeyword;
	private EssentialOCLUnrestrictedIdentifierElements pEssentialOCLUnrestrictedIdentifier;
	private EssentialOCLPrefixOperatorElements pEssentialOCLPrefixOperator;
	private EssentialOCLInfixOperatorElements pEssentialOCLInfixOperator;
	private EssentialOCLNavigationOperatorElements pEssentialOCLNavigationOperator;
	private IdentifierElements pIdentifier;
	private StringLiteralElements pStringLiteral;
	private PrefixOperatorElements pPrefixOperator;
	private InfixOperatorElements pInfixOperator;
	private NavigationOperatorElements pNavigationOperator;
	private EssentialOCLUnrestrictedNameElements pEssentialOCLUnrestrictedName;
	private UnrestrictedNameElements pUnrestrictedName;
	private EssentialOCLUnreservedNameElements pEssentialOCLUnreservedName;
	private UnreservedNameElements pUnreservedName;
	private PathNameCSElements pPathNameCS;
	private FirstPathElementCSElements pFirstPathElementCS;
	private NextPathElementCSElements pNextPathElementCS;
	private PrimitiveTypeIdentifierElements pPrimitiveTypeIdentifier;
	private PrimitiveTypeCSElements pPrimitiveTypeCS;
	private CollectionTypeIdentifierElements pCollectionTypeIdentifier;
	private CollectionTypeCSElements pCollectionTypeCS;
	private MultiplicityBoundsCSElements pMultiplicityBoundsCS;
	private MultiplicityCSElements pMultiplicityCS;
	private MultiplicityStringCSElements pMultiplicityStringCS;
	private TupleTypeCSElements pTupleTypeCS;
	private TuplePartCSElements pTuplePartCS;
	private CollectionLiteralExpCSElements pCollectionLiteralExpCS;
	private CollectionLiteralPartCSElements pCollectionLiteralPartCS;
	private ConstructorPartCSElements pConstructorPartCS;
	private PrimitiveLiteralExpCSElements pPrimitiveLiteralExpCS;
	private TupleLiteralExpCSElements pTupleLiteralExpCS;
	private TupleLiteralPartCSElements pTupleLiteralPartCS;
	private NumberLiteralExpCSElements pNumberLiteralExpCS;
	private StringLiteralExpCSElements pStringLiteralExpCS;
	private BooleanLiteralExpCSElements pBooleanLiteralExpCS;
	private UnlimitedNaturalLiteralExpCSElements pUnlimitedNaturalLiteralExpCS;
	private InvalidLiteralExpCSElements pInvalidLiteralExpCS;
	private NullLiteralExpCSElements pNullLiteralExpCS;
	private TypeLiteralCSElements pTypeLiteralCS;
	private TypeLiteralExpCSElements pTypeLiteralExpCS;
	private TypeNameExpCSElements pTypeNameExpCS;
	private TypeExpCSElements pTypeExpCS;
	private ExpCSElements pExpCS;
	private BinaryOperatorCSElements pBinaryOperatorCS;
	private InfixOperatorCSElements pInfixOperatorCS;
	private NavigationOperatorCSElements pNavigationOperatorCS;
	private PrefixedExpCSElements pPrefixedExpCS;
	private PrefixedExpOrLetExpCSElements pPrefixedExpOrLetExpCS;
	private UnaryOperatorCSElements pUnaryOperatorCS;
	private PrimaryExpCSElements pPrimaryExpCS;
	private PrimaryExpOrLetExpCSElements pPrimaryExpOrLetExpCS;
	private NavigatingArgCSElements pNavigatingArgCS;
	private NavigatingBarArgCSElements pNavigatingBarArgCS;
	private NavigatingCommaArgCSElements pNavigatingCommaArgCS;
	private NavigatingSemiArgCSElements pNavigatingSemiArgCS;
	private NavigatingArgExpCSElements pNavigatingArgExpCS;
	private IfExpCSElements pIfExpCS;
	private LetExpCSElements pLetExpCS;
	private LetVariableCSElements pLetVariableCS;
	private NestedExpCSElements pNestedExpCS;
	private SelfExpCSElements pSelfExpCS;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public EssentialOCLGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	//Model returns ContextCS:
	//	ownedExpression=ExpCS;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//terminal DOUBLE_QUOTED_STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"";
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return (tDOUBLE_QUOTED_STRING != null) ? tDOUBLE_QUOTED_STRING : (tDOUBLE_QUOTED_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOUBLE_QUOTED_STRING"));
	} 

	//terminal SINGLE_QUOTED_STRING:
	//	"\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return (tSINGLE_QUOTED_STRING != null) ? tSINGLE_QUOTED_STRING : (tSINGLE_QUOTED_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SINGLE_QUOTED_STRING"));
	} 

	//terminal ML_SINGLE_QUOTED_STRING:
	//	"/\'"->"\'/";
	public TerminalRule getML_SINGLE_QUOTED_STRINGRule() {
		return (tML_SINGLE_QUOTED_STRING != null) ? tML_SINGLE_QUOTED_STRING : (tML_SINGLE_QUOTED_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_SINGLE_QUOTED_STRING"));
	} 

	//terminal SIMPLE_ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getSIMPLE_IDRule() {
		return (tSIMPLE_ID != null) ? tSIMPLE_ID : (tSIMPLE_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SIMPLE_ID"));
	} 

	//terminal ESCAPED_ID:
	//	"_" SINGLE_QUOTED_STRING;
	public TerminalRule getESCAPED_IDRule() {
		return (tESCAPED_ID != null) ? tESCAPED_ID : (tESCAPED_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ESCAPED_ID"));
	} 

	//ID:
	//	SIMPLE_ID | ESCAPED_ID;
	public IDElements getIDAccess() {
		return (pID != null) ? pID : (pID = new IDElements());
	}
	
	public ParserRule getIDRule() {
		return getIDAccess().getRule();
	}

	//// String to allow diverse re-use
	//terminal INT:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//LOWER returns ecore::EInt:
	//	INT;
	public LOWERElements getLOWERAccess() {
		return (pLOWER != null) ? pLOWER : (pLOWER = new LOWERElements());
	}
	
	public ParserRule getLOWERRule() {
		return getLOWERAccess().getRule();
	}

	//UPPER returns ecore::EInt:
	//	INT | "*";
	public UPPERElements getUPPERAccess() {
		return (pUPPER != null) ? pUPPER : (pUPPER = new UPPERElements());
	}
	
	public ParserRule getUPPERRule() {
		return getUPPERAccess().getRule();
	}

	//// Not terminal to allow parser backtracking to sort out "5..7"
	//NUMBER_LITERAL returns BigNumber:
	//	INT ("." INT)? (("e" | "E") ("+" | "-")? INT)?;
	public NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return (pNUMBER_LITERAL != null) ? pNUMBER_LITERAL : (pNUMBER_LITERAL = new NUMBER_LITERALElements());
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//URI:
	//	SINGLE_QUOTED_STRING;
	public URIElements getURIAccess() {
		return (pURI != null) ? pURI : (pURI = new URIElements());
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}

	//EssentialOCLReservedKeyword:
	//	"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor";
	public EssentialOCLReservedKeywordElements getEssentialOCLReservedKeywordAccess() {
		return (pEssentialOCLReservedKeyword != null) ? pEssentialOCLReservedKeyword : (pEssentialOCLReservedKeyword = new EssentialOCLReservedKeywordElements());
	}
	
	public ParserRule getEssentialOCLReservedKeywordRule() {
		return getEssentialOCLReservedKeywordAccess().getRule();
	}

	//EssentialOCLUnrestrictedIdentifier:
	//	"e" | "E";
	public EssentialOCLUnrestrictedIdentifierElements getEssentialOCLUnrestrictedIdentifierAccess() {
		return (pEssentialOCLUnrestrictedIdentifier != null) ? pEssentialOCLUnrestrictedIdentifier : (pEssentialOCLUnrestrictedIdentifier = new EssentialOCLUnrestrictedIdentifierElements());
	}
	
	public ParserRule getEssentialOCLUnrestrictedIdentifierRule() {
		return getEssentialOCLUnrestrictedIdentifierAccess().getRule();
	}

	//EssentialOCLPrefixOperator:
	//	"-" | "not";
	public EssentialOCLPrefixOperatorElements getEssentialOCLPrefixOperatorAccess() {
		return (pEssentialOCLPrefixOperator != null) ? pEssentialOCLPrefixOperator : (pEssentialOCLPrefixOperator = new EssentialOCLPrefixOperatorElements());
	}
	
	public ParserRule getEssentialOCLPrefixOperatorRule() {
		return getEssentialOCLPrefixOperatorAccess().getRule();
	}

	//EssentialOCLInfixOperator:
	//	"*" | "/" | "+" | "-" | ">" | "<" | ">=" | "<=" | "=" | "<>" | "and" | "or" | "xor" | "implies";
	public EssentialOCLInfixOperatorElements getEssentialOCLInfixOperatorAccess() {
		return (pEssentialOCLInfixOperator != null) ? pEssentialOCLInfixOperator : (pEssentialOCLInfixOperator = new EssentialOCLInfixOperatorElements());
	}
	
	public ParserRule getEssentialOCLInfixOperatorRule() {
		return getEssentialOCLInfixOperatorAccess().getRule();
	}

	//EssentialOCLNavigationOperator:
	//	"." | "->";
	public EssentialOCLNavigationOperatorElements getEssentialOCLNavigationOperatorAccess() {
		return (pEssentialOCLNavigationOperator != null) ? pEssentialOCLNavigationOperator : (pEssentialOCLNavigationOperator = new EssentialOCLNavigationOperatorElements());
	}
	
	public ParserRule getEssentialOCLNavigationOperatorRule() {
		return getEssentialOCLNavigationOperatorAccess().getRule();
	}

	//Identifier:
	//	ID | EssentialOCLUnrestrictedIdentifier;
	public IdentifierElements getIdentifierAccess() {
		return (pIdentifier != null) ? pIdentifier : (pIdentifier = new IdentifierElements());
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//StringLiteral:
	//	SINGLE_QUOTED_STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//// Intended to be overridden
	//PrefixOperator:
	//	EssentialOCLPrefixOperator;
	public PrefixOperatorElements getPrefixOperatorAccess() {
		return (pPrefixOperator != null) ? pPrefixOperator : (pPrefixOperator = new PrefixOperatorElements());
	}
	
	public ParserRule getPrefixOperatorRule() {
		return getPrefixOperatorAccess().getRule();
	}

	//// Intended to be overridden
	//InfixOperator:
	//	EssentialOCLInfixOperator;
	public InfixOperatorElements getInfixOperatorAccess() {
		return (pInfixOperator != null) ? pInfixOperator : (pInfixOperator = new InfixOperatorElements());
	}
	
	public ParserRule getInfixOperatorRule() {
		return getInfixOperatorAccess().getRule();
	}

	//// Intended to be overridden
	//NavigationOperator:
	//	EssentialOCLNavigationOperator;
	public NavigationOperatorElements getNavigationOperatorAccess() {
		return (pNavigationOperator != null) ? pNavigationOperator : (pNavigationOperator = new NavigationOperatorElements());
	}
	
	public ParserRule getNavigationOperatorRule() {
		return getNavigationOperatorAccess().getRule();
	}

	////---------------------------------------------------------------------
	////  Names
	////---------------------------------------------------------------------
	//EssentialOCLUnrestrictedName returns ecore::EString:
	//	Identifier;
	public EssentialOCLUnrestrictedNameElements getEssentialOCLUnrestrictedNameAccess() {
		return (pEssentialOCLUnrestrictedName != null) ? pEssentialOCLUnrestrictedName : (pEssentialOCLUnrestrictedName = new EssentialOCLUnrestrictedNameElements());
	}
	
	public ParserRule getEssentialOCLUnrestrictedNameRule() {
		return getEssentialOCLUnrestrictedNameAccess().getRule();
	}

	//// Intended to be overridden
	//UnrestrictedName returns ecore::EString:
	//	EssentialOCLUnrestrictedName;
	public UnrestrictedNameElements getUnrestrictedNameAccess() {
		return (pUnrestrictedName != null) ? pUnrestrictedName : (pUnrestrictedName = new UnrestrictedNameElements());
	}
	
	public ParserRule getUnrestrictedNameRule() {
		return getUnrestrictedNameAccess().getRule();
	}

	//EssentialOCLUnreservedName returns ecore::EString:
	//	UnrestrictedName | CollectionTypeIdentifier | PrimitiveTypeIdentifier | "Tuple";
	public EssentialOCLUnreservedNameElements getEssentialOCLUnreservedNameAccess() {
		return (pEssentialOCLUnreservedName != null) ? pEssentialOCLUnreservedName : (pEssentialOCLUnreservedName = new EssentialOCLUnreservedNameElements());
	}
	
	public ParserRule getEssentialOCLUnreservedNameRule() {
		return getEssentialOCLUnreservedNameAccess().getRule();
	}

	//// Intended to be overridden
	//UnreservedName returns ecore::EString:
	//	EssentialOCLUnreservedName;
	public UnreservedNameElements getUnreservedNameAccess() {
		return (pUnreservedName != null) ? pUnreservedName : (pUnreservedName = new UnreservedNameElements());
	}
	
	public ParserRule getUnreservedNameRule() {
		return getUnreservedNameAccess().getRule();
	}

	//PathNameCS returns base::PathNameCS:
	//	path+=FirstPathElementCS ("::" path+=NextPathElementCS)*;
	public PathNameCSElements getPathNameCSAccess() {
		return (pPathNameCS != null) ? pPathNameCS : (pPathNameCS = new PathNameCSElements());
	}
	
	public ParserRule getPathNameCSRule() {
		return getPathNameCSAccess().getRule();
	}

	//FirstPathElementCS returns base::PathElementCS:
	//	element=[pivot::NamedElement|UnrestrictedName];
	public FirstPathElementCSElements getFirstPathElementCSAccess() {
		return (pFirstPathElementCS != null) ? pFirstPathElementCS : (pFirstPathElementCS = new FirstPathElementCSElements());
	}
	
	public ParserRule getFirstPathElementCSRule() {
		return getFirstPathElementCSAccess().getRule();
	}

	//NextPathElementCS returns base::PathElementCS:
	//	element=[pivot::NamedElement|UnreservedName];
	public NextPathElementCSElements getNextPathElementCSAccess() {
		return (pNextPathElementCS != null) ? pNextPathElementCS : (pNextPathElementCS = new NextPathElementCSElements());
	}
	
	public ParserRule getNextPathElementCSRule() {
		return getNextPathElementCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	////  Types
	////---------------------------------------------------------------------
	//PrimitiveTypeIdentifier:
	//	"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid";
	public PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return (pPrimitiveTypeIdentifier != null) ? pPrimitiveTypeIdentifier : (pPrimitiveTypeIdentifier = new PrimitiveTypeIdentifierElements());
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}

	//PrimitiveTypeCS returns base::PrimitiveTypeRefCS:
	//	name=PrimitiveTypeIdentifier;
	public PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return (pPrimitiveTypeCS != null) ? pPrimitiveTypeCS : (pPrimitiveTypeCS = new PrimitiveTypeCSElements());
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}

	//CollectionTypeIdentifier returns ecore::EString:
	//	"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet";
	public CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return (pCollectionTypeIdentifier != null) ? pCollectionTypeIdentifier : (pCollectionTypeIdentifier = new CollectionTypeIdentifierElements());
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}

	//CollectionTypeCS:
	//	name=CollectionTypeIdentifier ("(" ownedType=TypeExpCS ")")?;
	public CollectionTypeCSElements getCollectionTypeCSAccess() {
		return (pCollectionTypeCS != null) ? pCollectionTypeCS : (pCollectionTypeCS = new CollectionTypeCSElements());
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}

	//MultiplicityBoundsCS returns base::MultiplicityBoundsCS:
	//	lowerBound=LOWER (".." upperBound=UPPER)?;
	public MultiplicityBoundsCSElements getMultiplicityBoundsCSAccess() {
		return (pMultiplicityBoundsCS != null) ? pMultiplicityBoundsCS : (pMultiplicityBoundsCS = new MultiplicityBoundsCSElements());
	}
	
	public ParserRule getMultiplicityBoundsCSRule() {
		return getMultiplicityBoundsCSAccess().getRule();
	}

	//MultiplicityCS returns base::MultiplicityCS:
	//	"[" (MultiplicityBoundsCS | MultiplicityStringCS) "]";
	public MultiplicityCSElements getMultiplicityCSAccess() {
		return (pMultiplicityCS != null) ? pMultiplicityCS : (pMultiplicityCS = new MultiplicityCSElements());
	}
	
	public ParserRule getMultiplicityCSRule() {
		return getMultiplicityCSAccess().getRule();
	}

	//MultiplicityStringCS returns base::MultiplicityStringCS:
	//	stringBounds=("*" | "+" | "?");
	public MultiplicityStringCSElements getMultiplicityStringCSAccess() {
		return (pMultiplicityStringCS != null) ? pMultiplicityStringCS : (pMultiplicityStringCS = new MultiplicityStringCSElements());
	}
	
	public ParserRule getMultiplicityStringCSRule() {
		return getMultiplicityStringCSAccess().getRule();
	}

	//TupleTypeCS returns base::TupleTypeCS:
	//	name="Tuple" ("(" (ownedParts+=tuplePartCS ("," ownedParts+=tuplePartCS)*)? ")")?;
	public TupleTypeCSElements getTupleTypeCSAccess() {
		return (pTupleTypeCS != null) ? pTupleTypeCS : (pTupleTypeCS = new TupleTypeCSElements());
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}

	//tuplePartCS returns base::TuplePartCS:
	//	name=UnrestrictedName ":" ownedType=TypeExpCS;
	public TuplePartCSElements getTuplePartCSAccess() {
		return (pTuplePartCS != null) ? pTuplePartCS : (pTuplePartCS = new TuplePartCSElements());
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	////  Literals
	////---------------------------------------------------------------------
	//CollectionLiteralExpCS:
	//	ownedType=CollectionTypeCS "{" (ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)? "}";
	public CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return (pCollectionLiteralExpCS != null) ? pCollectionLiteralExpCS : (pCollectionLiteralExpCS = new CollectionLiteralExpCSElements());
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}

	//CollectionLiteralPartCS:
	//	expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?;
	public CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return (pCollectionLiteralPartCS != null) ? pCollectionLiteralPartCS : (pCollectionLiteralPartCS = new CollectionLiteralPartCSElements());
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}

	//ConstructorPartCS:
	//	property=[pivot::Property|UnrestrictedName] "=" initExpression=ExpCS;
	public ConstructorPartCSElements getConstructorPartCSAccess() {
		return (pConstructorPartCS != null) ? pConstructorPartCS : (pConstructorPartCS = new ConstructorPartCSElements());
	}
	
	public ParserRule getConstructorPartCSRule() {
		return getConstructorPartCSAccess().getRule();
	}

	//PrimitiveLiteralExpCS:
	//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
	//	NullLiteralExpCS;
	public PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return (pPrimitiveLiteralExpCS != null) ? pPrimitiveLiteralExpCS : (pPrimitiveLiteralExpCS = new PrimitiveLiteralExpCSElements());
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}

	//TupleLiteralExpCS:
	//	"Tuple" "{" ownedParts+=TupleLiteralPartCS ("," ownedParts+=TupleLiteralPartCS)* "}";
	public TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return (pTupleLiteralExpCS != null) ? pTupleLiteralExpCS : (pTupleLiteralExpCS = new TupleLiteralExpCSElements());
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}

	//TupleLiteralPartCS:
	//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS;
	public TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return (pTupleLiteralPartCS != null) ? pTupleLiteralPartCS : (pTupleLiteralPartCS = new TupleLiteralPartCSElements());
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}

	//NumberLiteralExpCS:
	//	name=NUMBER_LITERAL;
	public NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return (pNumberLiteralExpCS != null) ? pNumberLiteralExpCS : (pNumberLiteralExpCS = new NumberLiteralExpCSElements());
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}

	//StringLiteralExpCS:
	//	name+=StringLiteral+;
	public StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return (pStringLiteralExpCS != null) ? pStringLiteralExpCS : (pStringLiteralExpCS = new StringLiteralExpCSElements());
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}

	//BooleanLiteralExpCS:
	//	name="true" | name="false";
	public BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return (pBooleanLiteralExpCS != null) ? pBooleanLiteralExpCS : (pBooleanLiteralExpCS = new BooleanLiteralExpCSElements());
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}

	//UnlimitedNaturalLiteralExpCS:
	//	{UnlimitedNaturalLiteralExpCS} "*";
	public UnlimitedNaturalLiteralExpCSElements getUnlimitedNaturalLiteralExpCSAccess() {
		return (pUnlimitedNaturalLiteralExpCS != null) ? pUnlimitedNaturalLiteralExpCS : (pUnlimitedNaturalLiteralExpCS = new UnlimitedNaturalLiteralExpCSElements());
	}
	
	public ParserRule getUnlimitedNaturalLiteralExpCSRule() {
		return getUnlimitedNaturalLiteralExpCSAccess().getRule();
	}

	//InvalidLiteralExpCS:
	//	{InvalidLiteralExpCS} "invalid";
	public InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return (pInvalidLiteralExpCS != null) ? pInvalidLiteralExpCS : (pInvalidLiteralExpCS = new InvalidLiteralExpCSElements());
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}

	//NullLiteralExpCS:
	//	{NullLiteralExpCS} "null";
	public NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return (pNullLiteralExpCS != null) ? pNullLiteralExpCS : (pNullLiteralExpCS = new NullLiteralExpCSElements());
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}

	//TypeLiteralCS returns base::TypedRefCS:
	//	PrimitiveTypeCS | CollectionTypeCS | TupleTypeCS;
	public TypeLiteralCSElements getTypeLiteralCSAccess() {
		return (pTypeLiteralCS != null) ? pTypeLiteralCS : (pTypeLiteralCS = new TypeLiteralCSElements());
	}
	
	public ParserRule getTypeLiteralCSRule() {
		return getTypeLiteralCSAccess().getRule();
	}

	//TypeLiteralExpCS:
	//	ownedType=TypeLiteralCS;
	public TypeLiteralExpCSElements getTypeLiteralExpCSAccess() {
		return (pTypeLiteralExpCS != null) ? pTypeLiteralExpCS : (pTypeLiteralExpCS = new TypeLiteralExpCSElements());
	}
	
	public ParserRule getTypeLiteralExpCSRule() {
		return getTypeLiteralExpCSAccess().getRule();
	}

	//TypeNameExpCS:
	//	pathName=PathNameCS;
	public TypeNameExpCSElements getTypeNameExpCSAccess() {
		return (pTypeNameExpCS != null) ? pTypeNameExpCS : (pTypeNameExpCS = new TypeNameExpCSElements());
	}
	
	public ParserRule getTypeNameExpCSRule() {
		return getTypeNameExpCSAccess().getRule();
	}

	//TypeExpCS returns base::TypedRefCS:
	//	(TypeNameExpCS | TypeLiteralCS) multiplicity=MultiplicityCS?;
	public TypeExpCSElements getTypeExpCSAccess() {
		return (pTypeExpCS != null) ? pTypeExpCS : (pTypeExpCS = new TypeExpCSElements());
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	////  Expressions
	////---------------------------------------------------------------------
	//// An ExpCS permits a LetExpCS only in the final term to ensure
	////  that let is right associative, whereas infix operators are left associative.
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
	//// is
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	//ExpCS:
	//	{InfixExpCS} ownedExpression+=PrefixedExpCS ownedOperator+=BinaryOperatorCS (ownedExpression+=PrefixedExpCS
	//	ownedOperator+=BinaryOperatorCS)* ownedExpression+=PrefixedExpOrLetExpCS | {PrefixExpCS}
	//	ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS | PrimaryExpOrLetExpCS;
	public ExpCSElements getExpCSAccess() {
		return (pExpCS != null) ? pExpCS : (pExpCS = new ExpCSElements());
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}

	//BinaryOperatorCS:
	//	InfixOperatorCS | NavigationOperatorCS;
	public BinaryOperatorCSElements getBinaryOperatorCSAccess() {
		return (pBinaryOperatorCS != null) ? pBinaryOperatorCS : (pBinaryOperatorCS = new BinaryOperatorCSElements());
	}
	
	public ParserRule getBinaryOperatorCSRule() {
		return getBinaryOperatorCSAccess().getRule();
	}

	//InfixOperatorCS returns BinaryOperatorCS:
	//	name=InfixOperator;
	public InfixOperatorCSElements getInfixOperatorCSAccess() {
		return (pInfixOperatorCS != null) ? pInfixOperatorCS : (pInfixOperatorCS = new InfixOperatorCSElements());
	}
	
	public ParserRule getInfixOperatorCSRule() {
		return getInfixOperatorCSAccess().getRule();
	}

	//NavigationOperatorCS:
	//	name=NavigationOperator;
	public NavigationOperatorCSElements getNavigationOperatorCSAccess() {
		return (pNavigationOperatorCS != null) ? pNavigationOperatorCS : (pNavigationOperatorCS = new NavigationOperatorCSElements());
	}
	
	public ParserRule getNavigationOperatorCSRule() {
		return getNavigationOperatorCSAccess().getRule();
	}

	//PrefixedExpCS returns ExpCS:
	//	PrimaryExpCS | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpCS;
	public PrefixedExpCSElements getPrefixedExpCSAccess() {
		return (pPrefixedExpCS != null) ? pPrefixedExpCS : (pPrefixedExpCS = new PrefixedExpCSElements());
	}
	
	public ParserRule getPrefixedExpCSRule() {
		return getPrefixedExpCSAccess().getRule();
	}

	//PrefixedExpOrLetExpCS returns ExpCS:
	//	PrimaryExpOrLetExpCS | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpOrLetExpCS;
	public PrefixedExpOrLetExpCSElements getPrefixedExpOrLetExpCSAccess() {
		return (pPrefixedExpOrLetExpCS != null) ? pPrefixedExpOrLetExpCS : (pPrefixedExpOrLetExpCS = new PrefixedExpOrLetExpCSElements());
	}
	
	public ParserRule getPrefixedExpOrLetExpCSRule() {
		return getPrefixedExpOrLetExpCSAccess().getRule();
	}

	//UnaryOperatorCS:
	//	name=PrefixOperator;
	public UnaryOperatorCSElements getUnaryOperatorCSAccess() {
		return (pUnaryOperatorCS != null) ? pUnaryOperatorCS : (pUnaryOperatorCS = new UnaryOperatorCSElements());
	}
	
	public ParserRule getUnaryOperatorCSRule() {
		return getUnaryOperatorCSAccess().getRule();
	}

	//// These rules are ordered most rejectable first
	//PrimaryExpCS returns ExpCS:
	//	{IndexExpCS} pathName=PathNameCS "[" firstIndexes+=ExpCS ("," firstIndexes+=ExpCS)* "]" ("[" secondIndexes+=ExpCS (","
	//	secondIndexes+=ExpCS)* "]")? (atPre?="@" "pre")? | {ConstructorExpCS} pathName=PathNameCS "{"
	//	ownedParts+=ConstructorPartCS ("," ownedParts+=ConstructorPartCS)* "}" | {InvocationExpCS} pathName=PathNameCS
	//	(atPre?="@" "pre")? "(" (argument+=NavigatingArgCS argument+=NavigatingCommaArgCS* (argument+=NavigatingSemiArgCS
	//	argument+=NavigatingCommaArgCS*)? (argument+=NavigatingBarArgCS argument+=NavigatingCommaArgCS*)?)? ")" | {NameExpCS}
	//	pathName=PathNameCS (atPre?="@" "pre")? | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
	//	CollectionLiteralExpCS | TypeLiteralExpCS | IfExpCS | NestedExpCS;
	public PrimaryExpCSElements getPrimaryExpCSAccess() {
		return (pPrimaryExpCS != null) ? pPrimaryExpCS : (pPrimaryExpCS = new PrimaryExpCSElements());
	}
	
	public ParserRule getPrimaryExpCSRule() {
		return getPrimaryExpCSAccess().getRule();
	}

	//PrimaryExpOrLetExpCS returns ExpCS:
	//	PrimaryExpCS | LetExpCS;
	public PrimaryExpOrLetExpCSElements getPrimaryExpOrLetExpCSAccess() {
		return (pPrimaryExpOrLetExpCS != null) ? pPrimaryExpOrLetExpCS : (pPrimaryExpOrLetExpCS = new PrimaryExpOrLetExpCSElements());
	}
	
	public ParserRule getPrimaryExpOrLetExpCSRule() {
		return getPrimaryExpOrLetExpCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	//NavigatingArgCS:
	//	name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public NavigatingArgCSElements getNavigatingArgCSAccess() {
		return (pNavigatingArgCS != null) ? pNavigatingArgCS : (pNavigatingArgCS = new NavigatingArgCSElements());
	}
	
	public ParserRule getNavigatingArgCSRule() {
		return getNavigatingArgCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	//NavigatingBarArgCS returns NavigatingArgCS:
	//	prefix="|" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public NavigatingBarArgCSElements getNavigatingBarArgCSAccess() {
		return (pNavigatingBarArgCS != null) ? pNavigatingBarArgCS : (pNavigatingBarArgCS = new NavigatingBarArgCSElements());
	}
	
	public ParserRule getNavigatingBarArgCSRule() {
		return getNavigatingBarArgCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	//NavigatingCommaArgCS returns NavigatingArgCS:
	//	prefix="," name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public NavigatingCommaArgCSElements getNavigatingCommaArgCSAccess() {
		return (pNavigatingCommaArgCS != null) ? pNavigatingCommaArgCS : (pNavigatingCommaArgCS = new NavigatingCommaArgCSElements());
	}
	
	public ParserRule getNavigatingCommaArgCSRule() {
		return getNavigatingCommaArgCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	//NavigatingSemiArgCS returns NavigatingArgCS:
	//	prefix=";" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public NavigatingSemiArgCSElements getNavigatingSemiArgCSAccess() {
		return (pNavigatingSemiArgCS != null) ? pNavigatingSemiArgCS : (pNavigatingSemiArgCS = new NavigatingSemiArgCSElements());
	}
	
	public ParserRule getNavigatingSemiArgCSRule() {
		return getNavigatingSemiArgCSAccess().getRule();
	}

	//// Intended to be overridden
	////	'?'	-- defined by Complete OCL
	//NavigatingArgExpCS returns ExpCS:
	//	ExpCS;
	public NavigatingArgExpCSElements getNavigatingArgExpCSAccess() {
		return (pNavigatingArgExpCS != null) ? pNavigatingArgExpCS : (pNavigatingArgExpCS = new NavigatingArgExpCSElements());
	}
	
	public ParserRule getNavigatingArgExpCSRule() {
		return getNavigatingArgExpCSAccess().getRule();
	}

	//IfExpCS:
	//	"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif";
	public IfExpCSElements getIfExpCSAccess() {
		return (pIfExpCS != null) ? pIfExpCS : (pIfExpCS = new IfExpCSElements());
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}

	//LetExpCS:
	//	"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS;
	public LetExpCSElements getLetExpCSAccess() {
		return (pLetExpCS != null) ? pLetExpCS : (pLetExpCS = new LetExpCSElements());
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}

	//LetVariableCS:
	//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS;
	public LetVariableCSElements getLetVariableCSAccess() {
		return (pLetVariableCS != null) ? pLetVariableCS : (pLetVariableCS = new LetVariableCSElements());
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}

	//NestedExpCS:
	//	"(" source=ExpCS ")";
	public NestedExpCSElements getNestedExpCSAccess() {
		return (pNestedExpCS != null) ? pNestedExpCS : (pNestedExpCS = new NestedExpCSElements());
	}
	
	public ParserRule getNestedExpCSRule() {
		return getNestedExpCSAccess().getRule();
	}

	//SelfExpCS:
	//	{SelfExpCS} "self";
	public SelfExpCSElements getSelfExpCSAccess() {
		return (pSelfExpCS != null) ? pSelfExpCS : (pSelfExpCS = new SelfExpCSElements());
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}
}
