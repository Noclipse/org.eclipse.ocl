/*******************************************************************************
 * Copyright (c) 2010 E.D.Willink and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial API and implementation
 *******************************************************************************/
grammar org.eclipse.ocl.examples.xtext.essentialocl.EssentialOCL hidden(WS, ML_COMMENT, SL_COMMENT) //with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/ocl/3.1.0/Pivot" as pivot
import "http://www.eclipse.org/ocl/3.1.0/BaseCST" as base
import "http://www.eclipse.org/ocl/3.1.0/EssentialOCLCST"
//generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
Model returns ContextCS:
	ownedExpression=ExpCS;

terminal fragment ESCAPED_CHARACTER:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\');

terminal fragment LETTER_CHARACTER:
	'a'..'z' | 'A'..'Z' | '_';

terminal DOUBLE_QUOTED_STRING:
	'"' (ESCAPED_CHARACTER | !('\\' | '"'))* '"';

terminal SINGLE_QUOTED_STRING:
	"'" (ESCAPED_CHARACTER | !('\\' | "'"))* "'";

terminal ML_SINGLE_QUOTED_STRING:
	"/'"->"'/";

terminal SIMPLE_ID:
	LETTER_CHARACTER (LETTER_CHARACTER | ('0'..'9'))*;

terminal ESCAPED_ID:
	"_" SINGLE_QUOTED_STRING;

ID: SIMPLE_ID | ESCAPED_ID;

terminal INT: // String to allow diverse re-use
	('0'..'9')+;		// multiple leading zeroes occur as floating point fractional part

/* A lowerbounded integer is used to define the lowerbound of a collection multiplicity. The value may not be the unlimited value. */
LOWER returns ecore::EInt:
	INT
;

/* An upperbounded integer is used to define the upperbound of a collection multiplicity. The value may be the unlimited value. */
UPPER returns ecore::EInt:
	INT | '*'
;

/* A number may be an integer or floating point value. The declaration here appears to be that for just an integer. This is to avoid
 * lookahead conflicts in simple lexers between a dot within a floating point number and the dot-dot in a CollectionLiteralPartCS. A
 * practical implementation should give high priority to a successful parse of INT ('.' INT)? (('e' | 'E') ('+' | '-')? INT)? than
 * to the unsuccessful partial parse of INT '..'. The type of the INT terminal is String to allow the floating point syntax to be used.
 */
NUMBER_LITERAL returns BigNumber: // Not terminal to allow parser backtracking to sort out "5..7"
	INT; // EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;

/* A multi-line comment supports a comment that may span more than one line using familiar slash-star...star-slash comment delimiters */
terminal ML_COMMENT:
	'/*' ->'*/';

/* A single-line comment supports a comment that terminates at the end of the line */
terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?;

/* Whitespace may occur between any pair of tokens */
terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;
	
URI:
	SINGLE_QUOTED_STRING;

/** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
EssentialOCLReservedKeyword:
	'and'
	| 'else'
	| 'endif'
	| 'if'
	| 'implies'
	| 'in'
	| 'let'
	| 'not'
	| 'or'
	| 'then'
	| 'xor';

/** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
EssentialOCLUnaryOperatorCS returns UnaryOperatorCS:
	name=('-' | 'not');

/** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
EssentialOCLInfixOperatorCS returns BinaryOperatorCS:
	name=('*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'or' | 'xor' | 'implies');

/** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
EssentialOCLNavigationOperatorCS returns NavigationOperatorCS:
	name=('.' | '->' | '?.' | '?->');

Identifier:
	ID;

StringLiteral:
	SINGLE_QUOTED_STRING;

BinaryOperatorCS returns BinaryOperatorCS:
	InfixOperatorCS | NavigationOperatorCS;

InfixOperatorCS returns BinaryOperatorCS: 			// Intended to be overrideable
	EssentialOCLInfixOperatorCS;

NavigationOperatorCS returns NavigationOperatorCS: 	// Intended to be overrideable
	EssentialOCLNavigationOperatorCS;

UnaryOperatorCS returns UnaryOperatorCS: 			// Intended to be overrideable
	EssentialOCLUnaryOperatorCS;

//---------------------------------------------------------------------
//  Names
//---------------------------------------------------------------------
/** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
EssentialOCLUnrestrictedName returns ecore::EString:
	Identifier;

UnrestrictedName returns ecore::EString: // Intended to be overridden
	EssentialOCLUnrestrictedName;

/** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
EssentialOCLUnreservedName returns ecore::EString:
	UnrestrictedName
|	CollectionTypeIdentifier
|	PrimitiveTypeIdentifier
|	'Tuple'
;

UnreservedName returns ecore::EString: // Intended to be overridden
	EssentialOCLUnreservedName;

PathNameCS returns base::PathNameCS:
	path+=FirstPathElementCS ('::' path+=NextPathElementCS)*;

FirstPathElementCS returns base::PathElementCS:
	element=[pivot::NamedElement|UnrestrictedName];

NextPathElementCS returns base::PathElementCS:
	element=[pivot::NamedElement|UnreservedName];

/* This slightly odd formulation avoids an LALR shift-reduce conflict wrt URIFirstPathElementCS '::' '*' */
URIPathNameCS returns base::PathNameCS:
	path+=URIFirstPathElementCS ('::' (path+=NextPathElementCS '::')* path+=NextPathElementCS)?;

URIFirstPathElementCS returns base::PathElementCS:
	element=[pivot::NamedElement|UnrestrictedName] | {base::PathElementWithURICS} element=[pivot::Namespace|URI];

//---------------------------------------------------------------------
//  Types
//---------------------------------------------------------------------
PrimitiveTypeIdentifier:
	'Boolean'
	| 'Integer'
	| 'Real'
	| 'String'
	| 'UnlimitedNatural'
	| 'OclAny'
	| 'OclInvalid'
	| 'OclVoid';

PrimitiveTypeCS returns base::PrimitiveTypeRefCS:
	name=PrimitiveTypeIdentifier;

CollectionTypeIdentifier returns ecore::EString:
	'Set'
	| 'Bag'
	| 'Sequence'
	| 'Collection'
	| 'OrderedSet';

CollectionTypeCS returns CollectionTypeCS:
	name=CollectionTypeIdentifier ('(' ownedType=TypeExpCS ')')?;

MultiplicityBoundsCS returns base::MultiplicityBoundsCS:
	lowerBound=LOWER ('..' upperBound=UPPER)?;

MultiplicityCS returns base::MultiplicityCS:
	'[' (MultiplicityBoundsCS | MultiplicityStringCS) ']';

MultiplicityStringCS returns base::MultiplicityStringCS:
	stringBounds=('*'|'+'|'?');

TupleTypeCS returns base::TupleTypeCS:
	name='Tuple' ('(' (ownedParts+=TuplePartCS (',' ownedParts+=TuplePartCS)*)? ')')?;

TuplePartCS returns base::TuplePartCS:
	name=UnrestrictedName ':' ownedType=TypeExpCS;

//---------------------------------------------------------------------
//  Literals
//---------------------------------------------------------------------
CollectionLiteralExpCS returns CollectionLiteralExpCS:
	ownedType=CollectionTypeCS
	'{' (ownedParts+=CollectionLiteralPartCS
	(',' ownedParts+=CollectionLiteralPartCS)*)?
	'}';

CollectionLiteralPartCS returns CollectionLiteralPartCS:
	expressionCS=ExpCS ('..' lastExpressionCS=ExpCS)?;

ConstructorPartCS returns ConstructorPartCS:
	property=[pivot::Property|UnrestrictedName] '=' initExpression=ExpCS;

LambdaLiteralExpCS returns LambdaLiteralExpCS:
	'Lambda' '{' expressionCS=ExpCS '}';

PrimitiveLiteralExpCS returns PrimitiveLiteralExpCS:
	NumberLiteralExpCS
	| StringLiteralExpCS
	| BooleanLiteralExpCS
	| UnlimitedNaturalLiteralExpCS
	| InvalidLiteralExpCS
	| NullLiteralExpCS;

TupleLiteralExpCS returns TupleLiteralExpCS:
	'Tuple' '{' ownedParts+=TupleLiteralPartCS (',' ownedParts+=TupleLiteralPartCS)* '}';

TupleLiteralPartCS returns TupleLiteralPartCS:
	name=UnrestrictedName (':' ownedType=TypeExpCS)? '=' initExpression=ExpCS;

NumberLiteralExpCS returns NumberLiteralExpCS:
	name=NUMBER_LITERAL;

StringLiteralExpCS returns StringLiteralExpCS:
	name+=StringLiteral+;

BooleanLiteralExpCS returns BooleanLiteralExpCS:
	name='true'
	| name='false';

UnlimitedNaturalLiteralExpCS returns UnlimitedNaturalLiteralExpCS:
	{UnlimitedNaturalLiteralExpCS} '*';

InvalidLiteralExpCS returns InvalidLiteralExpCS:
	{InvalidLiteralExpCS} 'invalid';

NullLiteralExpCS returns NullLiteralExpCS:
	{NullLiteralExpCS} 'null';

TypeLiteralCS returns base::TypedRefCS:
	PrimitiveTypeCS
	| CollectionTypeCS
	| TupleTypeCS;

TypeLiteralWithMultiplicityCS returns base::TypedRefCS:
	TypeLiteralCS multiplicity=MultiplicityCS?;

TypeLiteralExpCS returns TypeLiteralExpCS:
	ownedType=TypeLiteralWithMultiplicityCS;

TypeNameExpCS returns TypeNameExpCS:
	pathName=PathNameCS;

TypeExpCS returns base::TypedRefCS:
	(TypeNameExpCS | TypeLiteralCS) multiplicity=MultiplicityCS?;

	//---------------------------------------------------------------------
//  Expressions
//---------------------------------------------------------------------
// An ExpCS permits a LetExpCS only in the final term to ensure
//  that let is right associative, whereas infix operators are left associative.
//   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
// is
//   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
ExpCS returns ExpCS:
	(PrefixedExpCS
		({InfixExpCS.ownedExpression+=current} ownedOperator+=BinaryOperatorCS
			(	(ownedExpression+=PrefixedExpCS
					(ownedOperator+=BinaryOperatorCS ownedExpression+=PrefixedExpCS)*
					(ownedOperator+=BinaryOperatorCS ownedExpression+=LetExpCS)?
				)
			|	(ownedExpression+=LetExpCS)
			)
		)?
	)
| 	({PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=LetExpCS)
|	LetExpCS;

/* A prefixed expression is elaborates a primary expression with zero or more unary prefix operators. */
PrefixedExpCS returns ExpCS:
	({PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpCS)
| 	PrimaryExpCS;

/* A primary expression identifies the basic expressions from which more complex expressions may be constructed. */
PrimaryExpCS returns ExpCS:
	NestedExpCS
|	IfExpCS
| 	SelfExpCS
| 	PrimitiveLiteralExpCS
| 	TupleLiteralExpCS
| 	CollectionLiteralExpCS
| 	LambdaLiteralExpCS
| 	TypeLiteralExpCS
| 	NameExpCS;

/* A name expression is a generalised rule for expressions that start with a name and which may be followed by square, round or
 * curly bracket clauses and optionally an @pre as well.*/
NameExpCS returns NameExpCS:
	pathName=PathNameCS squareBracketedClauses+=SquareBracketedClauseCS*
	roundBracketedClause=RoundBracketedClauseCS? curlyBracketedClause=CurlyBracketedClauseCS? (atPre?='@' 'pre')?;

/* A curly bracket clause is a generalized rule for the literal arguments of collections, maps, tuples and type constructors.*/
CurlyBracketedClauseCS:
	{CurlyBracketedClauseCS} '{'
		( ((ownedParts+=ConstructorPartCS (',' ownedParts+=ConstructorPartCS)*))?
		| (value=StringLiteral)
		) '}'
	;
	
/* A curly bracket clause is a generalized rule for template specialisations and operations arguments.*/
RoundBracketedClauseCS:
	{RoundBracketedClauseCS} '(' (
		arguments+=NavigatingArgCS (arguments+=NavigatingCommaArgCS)*
		(arguments+=NavigatingSemiArgCS (arguments+=NavigatingCommaArgCS)*)?
		(arguments+=NavigatingBarArgCS (arguments+=NavigatingCommaArgCS)*)?
		)? ')'
	;

/* A square bracket clause is a generalized rule for association class qualifiers and roles.*/
SquareBracketedClauseCS:
	'[' terms+=ExpCS (',' terms+=ExpCS)* ']';

/* A navigating argument is a generalized rule for the first argument in a round bracket clause. This is typically the first operation
 * parameter or an iterator. */
NavigatingArgCS returns NavigatingArgCS:
	name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpCS)?)?;	// Type-less init is an illegal infix expression

/* A navigating bar argument is a generalized rule for a bar-prefixed argument in a round bracket clause. This is typically the body of an iteration. */
NavigatingBarArgCS returns NavigatingArgCS:
	prefix='|' name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpCS)?)?;	// Type-less init is an illegal infix expression

/* A navigating comma argument is a generalized rule for non-first argument in a round bracket clause. These are typically non-first operation
 * parameters or a second iterator. */
NavigatingCommaArgCS returns NavigatingArgCS:
	prefix=',' name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpCS)?)?;	// Type-less init is an illegal infix expression

/* A navigating semi argument is a generalized rule for a semicolon prefixed argument in a round bracket clause. This is typically an iterate accumulator. */
NavigatingSemiArgCS returns NavigatingArgCS:
	prefix=';' name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpCS)?)?;	// Type-less init is an illegal infix expression

NavigatingArgExpCS returns ExpCS: // Intended to be overridden
	ExpCS
	//	'?'	-- defined by Complete OCL
;

IfExpCS returns IfExpCS:
	'if' condition=ExpCS
	'then' thenExpression=ExpCS
	'else' elseExpression=ExpCS
	'endif';

LetExpCS returns LetExpCS:
	'let' variable+=LetVariableCS (',' variable+=LetVariableCS)*
	'in' in=ExpCS;

LetVariableCS returns LetVariableCS:
	name=UnrestrictedName roundBracketedClause=RoundBracketedClauseCS? (':' ownedType=TypeExpCS)? '=' initExpression=ExpCS;

NestedExpCS returns NestedExpCS:
	'(' source=ExpCS ')';

SelfExpCS returns SelfExpCS:
	{SelfExpCS} 'self';
		
